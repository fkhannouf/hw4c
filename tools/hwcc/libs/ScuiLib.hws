/* ScuiLib 0.7b                                               29.10.2009      */
/* -------------------------------------------------------------------------- */
/* APPUNTI                                                                    */
/* SISTEMARE RemoveObject(): deve togliere i gadget anche dai Layout          */

; ^^^^^ ATTENZIONE ALLA BUFFERIZZAZIONE PER RIDURRE IL FLICKERING          ^^^^^
; DEVO GESTIRE LO STACK DEI SELECT BRUSH ALTRIMENTI LE VIRTUAL AREA NON FUNZIO- 
; NERANNO                                                                       

; ==> Il rendering della struttura Vector agganciata alla struttura bevel e'    
; ==> già supportato, creare una tag per il pulsante in modo da poterne usu-    
; ==> fruire da lato utente.                                                    
; ==> Inoltre preparare un set minimo per la gestione delle librerie di vettori 
; ==> LoadLib, SaveLib, se già non ci sono!!                                    

; ==> Visto che la routine di rendering lo prevede potrei implementare le tag   
; ==> l'aspetto DOWN + HILIGHTED dello switch, basta creare il template nelle   
; ==> preferenze e gestire le tag  

; ==> Floating Tips
;
; ==> Pulsanti trasparenti con salvataggio background

; CONTINUARE OTTIMIZZAZIONE/DOCUMENTAZIONE DAL BUTTON


/* -------------------------------------------------------------------------- */
/* //\\//\\//\\//\\//\\//\\ CONSTANTS DECLARATION //\\//\\//\\//\\//\\//\\//\ */
/* -------------------------------------------------------------------------- */
/* RICORDARSI DI AGGIORNARE LE COSTANTI NEL FILE SEPARATO PER VIA DEGLI       */
/* APPLET                                                                     */
/* ---------------------------------------------------------------------------*/

;===| TRANSLATION SYSTEM |======================================================
; Queste costanti sono utilizzate dalla funzione scui.MarkObjects() per indicare
; a quale stato del gadget deve essere abbinata la traduzione della tag.
;---| Costante -------| Valore -------| Stato Gadget ---------------------------
Const #LANG_NORMAL    = 1            ;| Normale
Const #LANG_HILIGHTED = 2            ;| Evidenziato
Const #LANG_PUSHED    = 4            ;| Premuto
Const #LANG_DISABLED  = 8            ;| Disabilitato
Const #LANG_NDISABLED = 16           ;| Disabilitato/Normale
Const #LANG_PDISABLED = 32           ;| Disabilitato/Premuto
Const #LANG_ALL       = 0            ;| Tutti gli stati

;===| UNITA' DI MISURA CAPACITA' DI MEMORIA |===================================
; Costanti utilizzate dalla funzione helpers.FormatSize()
;---| Costante -------| Valore ------------| Significato -----------------------
Const #UNITSIZE_BYTE =  0                 ;| Byte
Const #UNITSIZE_KILO =  1                 ;| Kilobyte
Const #UNITSIZE_MEGA =  2                 ;| Megabyte
Const #UNITSIZE_GIGA =  3                 ;| Gigabyte
Const #UNITSIZE_TERA =  4                 ;| Terabyte
Const #UNITSIZE_AUTO = -1                 ;| Unità automatica
Const #UNITSIZE_BYTE_SHORT = "B"          ;| Abbreviazione byte
Const #UNITSIZE_BYTE_LONG  = "Byte"       ;| Descrizione byte
Const #UNITSIZE_KILO_SHORT = "Kb"         ;| Abbreviazione Kilobyte
Const #UNITSIZE_KILO_LONG  = "Kilobyte"   ;| Descrizione kilobyte
Const #UNITSIZE_MEGA_SHORT = "Mb"         ;| Abbreviazione Megabyte
Const #UNITSIZE_MEGA_LONG  = "Megabyte"   ;| Descrizione Megabyte
Const #UNITSIZE_GIGA_SHORT = "Gb"         ;| Abbreviazione Gigabyte
Const #UNITSIZE_GIGA_LONG  = "Gigabyte"   ;| Descrizione Gigabyte
Const #UNITSIZE_TERA_SHORT = "Tb"         ;| Abbreviazione Terabyte
Const #UNITSIZE_TERA_LONG  = "Terabyte"   ;| Descrizione Terabyte
Const #THOUSANDS_SEPARATOR = "'"          ;| Separatore delle migliaia

;===| DEFINIZIONE TIPI DI BEVEL BOX |===========================================
Const #BEVELTYPE_NONE   = 0 ;                     Nessun BevelBox sarà tracciato
Const #BEVELTYPE_FLAT   = 1 ;                  Bordo piatto (usando il colore 1)
Const #BEVELTYPE_SIMPLE = 2 ;                                           Bordo 3d
Const #BEVELTYPE_SUNKEN = 3 ;              Due bordi 3d consecutivi ma invertiti

;===| DEFINIZIONE ASPETTI PER I BEVEL BOX |=====================================
; Questi due aspetti sono validi  solo  per i bevel box  SIMPE e SUNKEN, inoltre
; l'aspetto in  rilievo o incavato si ottiene dando per scontato che il colore 1
; sia assegnato ai lati chiari, mentre il colore 2 ai lati scuri.
Const #BEVELASPECT_RAISED   = 1 ;          Il bevel assume un aspetto in rilievo
Const #BEVELASPECT_RECESSED = 2 ;            Il bevel assume un aspetto incavato

;===| DEFINIZIONE TIPI DI FILL PER I BEVEL BOX |================================
Const #BEVELFILL_NONE     = 0 ;                  Il bevel box non viene riempito
Const #BEVELFILL_SOLID    = 1 ;      Il bevel box viene riempito con il colore 1
Const #BEVELFILL_GRADIENT = 2 ;     Il bevel box viene riempito con un gradiente
Const #BEVELFILL_METAL    = 3 ;    Il bevel box viene riempito con due gradienti

;===| DEFINIZIONE STILI TESTO PER LE TEXTSTRUCT |===============================
; Questi stili possono anche essere combinati fra loro
Const #TEXTSTYLE_NORMAL    = 0           ;                          Test normale
Const #TEXTSTYLE_BOLD      = #BOLD       ;                             Grassetto
Const #TEXTSTYLE_UNDERLINE = #UNDERLINED ;                          Sottolineato
Const #TEXTSTYLE_ITALIC    = #ITALIC     ;                               Italico
Const #TEXTSTYLE_ANTIALIAS = #ANTIALIAS  ;                  Antialias (solo TTF)

;===| DEFINIZIONE TIPI DI OMBRA PER LE TEXTSTRUCT |=============================
Const #TEXTSHADOW_NONE      = 0              ;        No shadow will be rendered  
Const #TEXTSHADOW_NORTH     = #SHDWNORTH     ;                             North  
Const #TEXTSHADOW_NORTHEAST = #SHDWNORTHEAST ;                      North - East  
Const #TEXTSHADOW_EAST      = #SHDWEAST      ;                              East  
Const #TEXTSHADOW_SOUTHEAST = #SHDWSOUTHEAST ;                      South - East  
Const #TEXTSHADOW_SOUTH     = #SHDWSOUTH     ;                             South  
Const #TEXTSHADOW_SOUTHWEST = #SHDWSOUTHWEST ;                      South - West  
Const #TEXTSHADOW_WEST      = #SHDWWEST      ;                              West  
Const #TEXTSHADOW_NORTHWEST = #SHDWNORTHWEST ;                      North - West  

;===| DEFINIZIONE TIPI DI OUTLINE PER LE TEXTSTRUCT |===========================
Const #TEXTEDGE_NONE   = 0 ;                            No edge will be rendered  
Const #TEXTEDGE_SIMPLE = 1 ;              Renders a flat outline around the text  
Const #TEXTEDGE_3D     = 2 ;                Renders a 3D outline around the text  

;===| DEFINIZIONE TIPO #TEXTEDGE_3D PER LE TEXTSTRUCT |=========================
Const #TEXT3D_RAISED     = 1 ;          The text's 3d edge will look like raised  
Const #TEXT3D_RECESSED   = 2 ;        The text's 3d edge will look like recessed  

;===| DEFINIZIONE TIPI DI ALLINEAMENTO PER LE TEXTSTRUCT |======================
Const #TEXTALIGN_LEFT    = 2      ;                       Align text to the left  
Const #TEXTALIGN_RIGHT   = 4      ;                      Align text to the right  
Const #TEXTALIGN_HCENTER = 8      ;       The text will be centered horizontally  
Const #TEXTALIGN_TOP     = 16     ;                        Align text to the top  
Const #TEXTALIGN_BOTTOM  = 32     ;                     Align text to the bottom  
Const #TEXTALIGN_VCENTER = 64     ;         The text will be centered vertically  
Const #TEXTALIGN_CENTER  = 8 + 64 ;        Vertically and horizontally centering  

;===| DEFINIZIONE TIPI DI ALLINEAMENTO PER LE ICONE |===========================
Const #ICONALIGN_LEFT    = 2      ;                       Align text to the left  
Const #ICONALIGN_RIGHT   = 4      ;                      Align text to the right  
Const #ICONALIGN_HCENTER = 8      ;       The text will be centered horizontally  
Const #ICONALIGN_TOP     = 16     ;                        Align text to the top  
Const #ICONALIGN_BOTTOM  = 32     ;                     Align text to the bottom  
Const #ICONALIGN_VCENTER = 64     ;         The text will be centered vertically  
Const #ICONALIGN_CENTER  = 8 + 64 ;        Vertically and horizontally centering  

; IFOCLASS: Used during the creation a new IFO                                  
Const #IFOCLASS_BEVELBOX       = 1  ;                                Bevel Box  
Const #IFOCLASS_LABEL          = 2  ;                                    Label  
Const #IFOCLASS_BUTTON         = 3  ;                                   Button  
Const #IFOCLASS_SWITCH         = 4  ;                                   Switch  
Const #IFOCLASS_GAUGE          = 5  ;                             Progress bar  
Const #IFOCLASS_GAUGEIN        = 6  ;     INTERNAL -> Progress bar's inner-box  
Const #IFOCLASS_GAUGEOUT       = 7  ;     INTERNAL -> Progress bar's outer-box  
Const #IFOCLASS_LINEEDIT       = 8  ;     INTERNAL ->             * OBSOLETE *  
Const #IFOCLASS_STRINGBOX      = 9  ;                               String Box  
Const #IFOCLASS_OPTIONS        = 10 ;                                  Options  
Const #IFOCLASS_SELECTOR       = 11 ;                             * OBSOLETE *  
Const #IFOCLASS_SIMPLESCROLLER = 12 ;                          Simple Scroller  
Const #IFOCLASS_CYCLE          = 13 ;                                    Cycle  
Const #IFOCLASS_LISTVIEW       = 14 ;                                 ListView  
Const #IFOCLASS_TABS           = 15 ;                                     Tabs  
Const #IFOCLASS_FAKEWINDOW     = 16 ;                             * OBSOLETE *  
Const #IFOCLASS_IMAGE          = 17 ;                                Image Box  
Const #IFOCLASS_VIRTUALAREA    = 18 ;                             Virtual Area  
Const #IFOCLASS_MENU           = 19 ;                                    Menu'  
Const #IFOCLASS_SCROLLER       = 20 ;                                 Scroller  
Const #IFOCLASS_SUBMENU        = 21 ;

; CYCLE: Used  during  a  Cycle  IFO  creation, with  the  tag <GrowDirection>  
;        Defines the grow direction for the cycle option's list                 
Const #CYCLE_GROWUP   = 1 ;                      The options list will grow up  
Const #CYCLE_GROWDOWN = 2 ;                    The options list will grow down  

; IFOTYPE: Used to define the IFO type, not used right now                      
Const #IFOTYPE_BASIC = 1 ;                                      Root IFO class  
Const #IFOTYPE_GROUP = 2 ;                      Container IFO for childs Group  
Const #IFOTYPE_CHILD = 3 ;             Child IFO contained within an IFO Group  

; SCROLLERTYPE: Used during the creation of a Scroller, with  the  tag <Type>,  
;               selects the Scroller orientation                                
Const #SCROLLERTYPE_VERTICAL   = 1 ;                 Build a vertical scroller  
Const #SCROLLERTYPE_HORIZONTAL = 2 ;              Build an horizontal scroller  

; IFO ENABLED STATUS: Used  with  <scui.IFO[n].Enabled>,  keep  track  of  the  
;                     Enabled status of the object                              
Const #IFO_ENABLED  = 1 ;                                The object is Enabled  
Const #IFO_DISABLED = 0 ;                               The object is Disabled  

; IFO VISIBLE STATUS: Used  with  <scui.IFO[n].Visible>,  keep  track  of  the  
;                     Visible status of the object                              
Const #IFO_VISIBLE  = 1 ;                                The object is Visible  
Const #IFO_HIDDEN   = 0 ;                                 The object is Hidden  

; IFO FRAME STATUS: Used  with  <scui.IFO[n].Status>, keep track  of the input  
;                   status and the current frame of the object                  
Const #IFOSTATUS_NORMAL    = 1 ;                                 Normal Status  
Const #IFOSTATUS_HILIGHTED = 2 ;                 Hilighted (mouse over effect)  
Const #IFOSTATUS_PUSHED    = 3 ;                    Pushed (mouse down effect)  

; costanti aggiuntive per la gestione delle icone nei gadget
Const #IFOSTATUS_DISABLED  = 4
Const #IFOSTATUS_ALL       = -1

; INPUT MODE: Used  during   the  creation  of   a  StringBox,  with  the  tag  
;             <InputMode>, selects which character  set  are  allowed  for the  
;             user input                                                        
Const #GETKEY_ALL           = 1 ;                        Accept all characters  
Const #GETKEY_NUMERIC       = 2 ;       Accept only numeric-related characters  
Const #GETKEY_ALPHABETIC    = 3 ;    Accept only alphabetic-related characters  
Const #GETKEY_CUSTOM        = 4 ;         Accept a custom user's character set  

; LINEEDIT: Actually  this  tag  is  not  selectable  by the user, selects the  
;           cursor shape for the StringBox's cursor                             
Const #LINEEDIT_CURSORBLOCK = 1 ;                   Draw the cursor as a block  
Const #LINEEDIT_CURSORUNDER = 2 ;     Draw the cursor as a line under the char  
Const #LINEEDIT_CURSORLINE  = 3 ; Draw the cursor  as  a  vertical line before  
                                ; the character                                 

; EDITTEXT CLIP REGION: Internally used flag  by  the  StringBox IFO, reserved  
;                       Clip Region ID to clip text rendering                   
Const #EDITTEXT_CLIPID      = 999 ; This clip  region  must not be used by the  
                                  ; user                                        

; OPTMODE: Used during the Options IFO creation with  the  tag <Mode>, selects  
;          the working mode of the gadget                                       
Const #OPTMODE_ONLYONE = 1 ;        Options will act as mutual exclude control  
Const #OPTMODE_FREE    = 0 ;     Options will accept multiple options selected  

; OPTSWITCH: Used during the Options IFO creation  with  the tag <SwitchMode>,  
;            selects the layout of the switches                                 
Const #OPTSWITCH_EMPTY     = 0 ;             The Options buttons will be empty  
Const #OPTSWITCH_NUMBER    = 1 ;            The Options buttons will contain a  
                               ;            progressive number                  
Const #OPTSWITCH_FULLWIDTH = 2 ;    The Options buttons will contain the label  
                               ;    text, and labels will not be rendered       

; OPT POSITION: Used  during  the  Options   IFO   creation   with   the   tag  
;               <SwitchPosition>, sets  the label alignment  relative  to  the  
;               option's switch                                                 
Const #OPT_RIGHTSWITCH = 0 ;       Options buttons will be placed to the right  
Const #OPT_LEFTSWITCH  = 1 ;        Options buttons will be placed to the left  

; KEYBOARD HANDLER: Internally  by  the  keyboad  handler, track  the  current  
;                   keyboard input mode                                         
Const #KEYBOARD_IFOMODE   = 1 ;       The keyboard input is parsed to navigate  
                              ;       trought the gui                           
Const #KEYBOARD_INPUTMODE = 2 ;        The keyboard input is redirected to the  
                              ;        currently active StringBox               

; LAYOUT MODES: Used  during the  layout  creation  with the parameter <Mode>,  
;               selects which layout type should be applied to the gadgets      
Const #LAYOUTMODE_FREE       = 0
Const #LAYOUTMODE_VERTICAL   = 1 ;                        Vertical arrangement  
Const #LAYOUTMODE_HORIZONTAL = 2 ;                      Horizontal arrangement  
Const #LAYOUTMODE_GRID       = 3 ;                            Grid Arrangement  

; IMAGE RESIZE MODE: Used during an Image IFO creation with the tag <Resize>    
Const #IMAGERESIZE_NONE  = 1 ;                    The image will not be scaled  
Const #IMAGERESIZE_SCALE = 2 ;                        The image will be scaled  
Const #IMAGERESIZE_ZOOM  = 3 ;                        The image will be zoomed  

; CHILDS MANAGEMENT: Not used at this time                                      
Const #CHILDTYPE_SYSTEM  = 1
Const #CHILDTYPE_USER    = 1

; MISC                                                                          
Const #NOCLIP   = -1             ;            Flag used internally. Means that  
                                 ;               ClipRegion should not be used  
Const #SCREENID = "*SCREEN*"     ;    String used to identify the Screen Layer  
                                 ;                   in the windows management  
Const #MYBRUSH_BACKGROUND1 = 990 ;                           Reserved brush id  
Const #MYBRUSH_BACKGROUND2 = 991 ;                           Reserved brush id  
Const #MYBRUSH_DRAGWINDOW  = 992 ;                           Reserved brush id  
Const #MYBRUSH_GAUGERENDER = 993 ;                           Reserved brush id  
Const #MYBRUSH_SCREENGRAB  = 994 ;                           Reserved brush id  

Const #DIVIDER = -999            ;   Used to insert a blank divider between two 
                                 ;                  objects during gui creation 
Const #REMOVE_TAG = -1

; Gestione delle finestre secondarie                                            
Const #SCUILIB_MASTER = 1        ;                           Master Scui Window 
Const #SCUILIB_CHILD  = 2        ;                            Child Scui Window 

; SCROLLER CLASS                                                                
Const #SCROLLER_SQUAREARROWS = -1   ;              Keep squared button's arrows 

Const #SCROLLER_ARROWS_NONE   =  0  ;                      Hide arrow's buttons 
Const #SCROLLER_ARROWS_BOTTOM =  1  ; Group arrow's buttons to the bottom/right 
Const #SCROLLER_ARROWS_TOP    =  2  ;     Group arrow's buttons to the top/left 
Const #SCROLLER_ARROWS_SIDES  =  3  ;        place arrow's buttons to the sides 

Const #SCROLLER_TEXT_NONE     = 0   ;         Hide any text inside the scroller 
Const #SCROLLER_TEXT_FIXED    = 1   ;                        Use a fixed string 
Const #SCROLLER_TEXT_VALUE    = 2   ;            Use the current scroller value 

Const #SCROLLER_KNOB_NONE  = 0      ;           Hide any cursor's handler glyph 
Const #SCROLLER_KNOB_BOX   = 1      ;                           Use a box glyph 
Const #SCROLLER_KNOB_LINES = 2      ;             Use a group of lines as glyph 

; RWIN COMMANDS (Master -> Child)                                               
Const #MC_NEWOBJECT = "NWOBJ"       ; seguono i parametri di NewObject()        
Const #POPUP_ITEMHEIGHT_AUTO = -1   ; Item automatic height
Const #POPUP_MENUWIDTH_AUTO  = -1   ; Menu automatic width

Const #MENUHEIGHT_AUTO       = -1
/* ************************************************************************** */
/* AGGIUNGERE LE COSTANTI PER IL PARAMETRO <LAYOUT> DI ADDCHILDS()          * */
/* ************************************************************************** */



/* -------------------------------------------------------------------------- */
/* //\\//\\//\\//\\//\\//\\ MAIN DATA STRUCTURES //\\//\\//\\//\\//\\//\\//\/ */
/* -------------------------------------------------------------------------- */
Global helpers  = {}    ;                Table containing all helpers functions 
Global scui     = {}    ;         Root table for all library functions and data 
;scui.ActionStatus = ""  ;              Used to handle correctly the user events 
scui.IFO = { IDCounter = 0 }  ; Table containing the interface objects, they    
                              ; are indexed by a progressive number starting    
										; from 1.                                         
                              ; <IDCounter> stores how many objects are in      
										; defined  in the IFO subtable.                   
scui.Windows  = { }     ; Table storing all defined windows, indexed by the     
								; window alias.                                         
scui.WinOrder = { }     ; Table used to order windows on the screen, the last   
              		      ; window is always the active one, the first in the     
                        ; table is the first that will be rendered on the       
                        ; screen, indexed by a progressive number starting from 
                        ; 0.                
scui.Keyboard = {}
scui.Keyboard[#SCREENID] =               ; <Keyboard> table is used to handle the 
				{ Mode = #KEYBOARD_IFOMODE,  ;  user input from the keyboard and to 
        		  ActiveIFO = -1,            ;   navigate trought the interface and 
        		  Shortcuts = { } }          ; interact with the IFOs using the     
                                         ; keyboard.                            
                        ; <Mode> is the current input mode                      
                        ; <ActiveIFO> is the current active IFO activated by    
                        ;             the keyboard                              
                        ; <Shortcuts> stores the buttons shortcuts              
scui.ActiveWindow = #SCREENID ;        Store the active window (or screen) name 
		                        ; The engine is started with the Screen layer     
                              ; active.                                         
scui.LayoutList = {}          ;                Where all layouts will be stored 
scui.RefreshWindows = False   ;           Used to track the refresh of the FWin 
scui.AutoRendering = True     ; Rendering at creation time, if False sets the   
                              ; flag <NoDraw> automatically                     
scui.LockRMB = False    ;     Used to lock the RMB when a cycle menu' is opened 
scui.RenderStack = { }  ;       Used to handle a rendering stack within brushes 
scui.MasterIFOs = {}    ; Table where all master IFO will be store for the      
                        ; the autoresize feature                                
scui.Menu = {}          ;        Table used to track the currently opened menu' 
scui.Behaviour = #SCUILIB_MASTER ; Used to know if ScuiLib is in master-mode or 
                                 ; in child-mode                                
scui.RWin = { }                  ; Table used to store all RWin in use          
scui.EventHandling = True        ; --> False = Disabled, True = Enabled       

; --- NEW WINDOW MANAGEMENT ---
scui.Win = {}  
scui.Language = {}               ; Language Extension
scui.Language.Current = {}       ; Current Language Definition
scui.Language.MarkList = {}      ; Marked Object to be translated
scui.Icon = {}
scui.Icons = {}
scui.Picture = {}
scui.Pictures = {}
scui.QuickFind = {}

/* -------------------------------------------------------------------------- */
/* //\\//\\//\\//\\//\\ EXTERNAL FILES AND LIBRARIES //\\//\\//\\//\\//\\//\/ */
/* -------------------------------------------------------------------------- */
@INCLUDE "Defaults_Standard.hws" ;                Default Theme and preferences 
@INCLUDE "FilezLib.hws"          ;               Common files operation library 
@INCLUDE "VectorzLib.hws"        ;              Simple vector rendering library 

/* -------------------------------------------------------------------------- */
/* //\\//\\//\\//\\//\\ DYNAMIC BRUSH ID ALLOCATION //\\//\\//\\//\\//\\//\\/ */
/* -------------------------------------------------------------------------- */
Const #BRUSH_FIRST = 501   ;            First brush id available for the system 
Const #BRUSH_LAST  = 899   ;                Last brush available for the system 
Brushes = { id = { } }     ;           Table used to track the brush allocation 

/* Brush table initializazion                                                 */
For Local c = #BRUSH_FIRST To #BRUSH_LAST Do Brushes.id[c] = 0


Function scui.Debug(table) ;----------------------------------------------------
   If Not(scui.prefs.DebugMode) Then Return()
   
   Local cnt = helpers.CountEntries(table)
   If cnt > 0
      For Local i = 0 To cnt - 1
         If GetType(table[i]) = #TABLE
            DebugPrint("      -----DUMPING TABLE-----")
            helpers.DumpTable(table[i], 5)
            DebugPrint("      ---------DONE----------")
         Else
            Local ty
            If GetType(Table[i]) = #NUMBER
               ty = "[NUMBER]"
            ElseIf GetType(table[i]) = #STRING
               ty = "[STRING]"
            ElseIf GetType(table[i]) = #USERDATA
               ty = "[USERDATA]"
            Else
               ty = "[UNKNOWN TYPE]"
            EndIf
            If i = 0
               DebugPrint(table[i])
               If Not(scui.prefs.DebugDetails) Then Return()
            Else
               DebugPrint("     ", ty .. ":" .. table[i])
            EndIf
         EndIf
      Next
      DebugPrint("")
   EndIf
EndFunction
Function helpers.GetBrushID() ;----------------------------------| OBSOLETE |---
   ; Added: v0.6   Docs : 20.12.2008                                            
   ; | Obtain a free brush id                                                  |
   ; | Returns the id of the free brush or -1 if no free brushes are available |
   Local found = -1
   Local c
DebugPrint("***** GetBrushID OBSOLETE *****")
   ; Iterate over the brush table                                               
   For c = #BRUSH_FIRST To #BRUSH_LAST
      If Brushes.id[c] = 0
         ; If we have found a free id (=0), store the id and exit from the loop 
         found = c
         Brushes.id[c] = 1
         Break
      EndIf
   Next

   ; Returns -1 or the free brush id                                            
   Return(found)
EndFunction
Function helpers.FreeBrush(id) ;---------------------------------| OBSOLETE |---
   ; Added: v0.6   Docs : 20.12.2008                                            
   ; | Free a brush previously obtained with <helpers.GetBrushID>              |
   ; | Returns True if the brush has been freed or False if it was already free|
DebugPrint("***** FreeBrush OBSOLETE *****")
   ; Check if the given <id> results busy, if so proceed and free it            
   If Brushes.id[id] = 1
      Brushes.id[id] = 0
      FreeBrush(id)
      Return(True)
   Else
      Return(False)
   EndIf
EndFunction
Function helpers.MyReplace(Source, SubStr, Rep) ;----------------| OBSOLETE |---
   ; Added: v0.5   Docs : 24.12.2008                                            
	; | String replacement function: OBSOLETE                                   |
   DebugPrint("PLEASE REPLACE helpers.MyReplace() function with the native Hollywood function!!")

   ; Find the position of the substring we want to replace                      
   Local n = FindStr(Source, SubStr)
    
   ; Search & Replace until no more occurancies are found                       
   While n >= 0
      Source = LeftStr(Source, n) ..Rep.. RightStr(Source, StrLen(Source) - StrLen(SubStr) - n)
      n = FindStr(Source, SubStr)
  Wend
  Return(Source)
EndFunction
Function helpers.FormatSize(size, target, template, decimals, thousands) ;------
   ; Added: v0.7   Docs : NONE                                                  
	; | Converts the <size> value expressed in bytes to another size unit.      |
	; |  INPUT:                                                                 |
	; |    size			size value to convert expressed in bytes                  |
	; |    target		target unit after conversion, can be:                     |
	; |						#UNITSIZE_BYTE, #UNITSIZE_KILO, #UNITSIZE_MEGA,        |
	; |                  #UNITSIZE_GIGA, #UNITSIZE_TERA, #UNITSIZE_AUTO         |
	; |               #UNITSIZE_AUTO will select automatically an appropriate   |
	; |               coversion unit.                                           |
	; |	template		Template string, can containt the following tags:         |
	; |							$I = Integer                                        |
	; |							$D = Decimal                                        |
	; |							$R = Remaining                                      |
	; |							$P = Plain result                                   |
	; |							$LU = Integer Size unit, long form                  |
	; |							$SU = Integer Size unit, short form                 |
	; |							$LSU = Remaining Size unit, long form               |
	; |							$SSU = Remaining size unit, short form              |
	; |					Examples using <target = #UNITSIZE_MEGA>                  |
	; |							$I.$D$SU		       --> 143.25Mb                     |
	; |							$I$SU, $R$SSU      --> 143Mb, 256B                  |
	; |							$I $LU and $R $LSU --> 143 Megabyte and 256 Byte    |
	; |	decimals		Number of fixed decimal numbers                           |
	; |	thousands	True/False: use or not the thousands separator            |
	
	; Setup default values if needed                                             
	If GetType(size)      = #NIL Then size      = 0
	If GetType(target)    = #NIL Then target    = #UNITSIZE_AUTO
	If GetType(template)  = #NIL Then template  = "$I.$D$SU"
	If GetType(decimals)  = #NIL Then decimals  = 2
	If GetType(thousands) = #NIL Then thousands = True

   ; Initialize the variables                                                   
	Local iResult = 0
	Local dResult = 0
	Local rResult = 0
	Local pResult = 0
	Local iResultS = ""
	Local dResultS = ""

	Local unit1a = ""
	Local unit2a = ""
	Local unit1b = ""
	Local unit2b = ""

	; Handle the AUTO-Target                                                     
	If target = #UNITSIZE_AUTO
		Local i = size / (1024*1024*1024*1024)
		target  = #UNITSIZE_TERA
		While i < 1
			i = i * 1024
			target = target - 1
			If target = #UNITSIZE_BYTE Then Break
		Wend
	EndIf

   ; Handle the target unit conversion                                          
	Switch target
		Case #UNITSIZE_BYTE
			iResult = size
			pResult = size
			dResult = 0
			rResult = 0
			unit1a = #UNITSIZE_BYTE_LONG
			unit1b = #UNITSIZE_BYTE_SHORT

		Case #UNITSIZE_KILO
			o = size/1024
			pResult = o
			ir = Int(o)
			dr = o - ir
			iResult = ir
			dResult = dr
			rResult = Int(dResult * 1024)

			unit1a = #UNITSIZE_KILO_LONG
			unit2a = #UNITSIZE_BYTE_LONG
			unit1b = #UNITSIZE_KILO_SHORT
			unit2b = #UNITSIZE_BYTE_SHORT

		Case #UNITSIZE_MEGA
			o = size/(1024*1024)
			pResult = o
			ir = Int(o)
			dr = o - ir
			iResult = ir
			dResult = dr
			rResult = Int(dResult * 1024)

			unit1a = #UNITSIZE_MEGA_LONG
			unit2a = #UNITSIZE_KILO_LONG
			unit1b = #UNITSIZE_MEGA_SHORT
			unit2b = #UNITSIZE_KILO_SHORT

		Case #UNITSIZE_GIGA
			o = size/(1024*1024*1024)
			pResult = o
			ir = Int(o)
			dr = o - ir
			iResult = ir
			dResult = dr
			rResult = Int(dResult * 1024)

			unit1a = #UNITSIZE_GIGA_LONG
			unit2a = #UNITSIZE_MEGA_LONG
			unit1b = #UNITSIZE_GIGA_SHORT
			unit2b = #UNITSIZE_MEGA_SHORT

		Case #UNITSIZE_TERA
			o = size/(1024*1024*1024*1024)
			pResult = o
			ir = Int(o)
			dr = o - ir
			iResult = ir
			dResult = dr
			rResult = Int(dResult * 1024)

			unit1a = #UNITSIZE_TERA_LONG
			unit2a = #UNITSIZE_GIGA_LONG
			unit1b = #UNITSIZE_TERA_SHORT
			unit2b = #UNITSIZE_GIGA_SHORT
	EndSwitch

   ; Add the thousands separator if requested                                   
	If thousands
		Local ir = StrStr(iResult)
		If StrLen(ir) > 3
			Local dots = Int(StrLen(ir)/3)
			Local Start = Mod(StrLen(ir), 3)

			Local Begin = 0
			Local r = ""
			If Start <> 0 
				r = MidStr(ir, Begin, Start) .. #THOUSANDS_SEPARATOR
			EndIf

			Begin = Begin + Start
			For Local i = 1 To dots
				r = r .. MidStr(ir, Begin, 3)
				If i <> dots Then r = r .. #THOUSANDS_SEPARATOR
				Begin = Begin + 3
			Next

			iResultS = r
		Else
			iResultS = ir
		EndIf
	Else
		iResultS = StrStr(iResult)
	EndIf

	; Handle the decimal part of the conversion                                  
	If decimals > -1
		If decimals = 0
			dResultS = ""
		Else
			Local mul = 10^decimals
			dResult = Int(dResult*mul)
			dResultS = StrStr(dResult)
			Local l = StrLen(dResult)
			Local d = decimals - l
			For Local i = 1 To d
				dResultS = dResultS .. "0"
			Next
		EndIf
	EndIf

   ; Build the string to return parsing the place-holders                       
	template = ReplaceStr(template, "$I", iResultS)
	template = ReplaceStr(template, "$P", pResult)
	template = ReplaceStr(template, "$LU", unit1a)
	template = ReplaceStr(template, "$SU", unit1b)
	template = ReplaceStr(template, "$D", dResultS)
	template = ReplaceStr(template, "$R", rResult)
	template = ReplaceStr(template, "$LSU", unit2a)
	template = ReplaceStr(template, "$SSU", unit2b)

   ; Returns the result                                                         
	Return(template)
EndFunction
Function helpers.DumpTable(table, ident) ;--------------------------------------
   ; Added: v0.5   Docs : 24.12.2008                                            
	; | Dump the table's contents to the console                                |

   ; a -> index, b -> table item, c -> counter                                  
   Local a, b
   Local space = ""

   If helpers.IsNil(ident) = 1 Then ident = 0

   ; Build the identation string                                                
   For Local c = 0 To ident Do space = space .. " "

   ; Process the table recursively...                                           
   a, b = NextItem(table)
   While GetType(a) <> #NIL
      If GetType(b) = #TABLE
         DebugPrint(space .. "[ ", a, " ]", b)
         helpers.DumpTable(b, ident + 3)
      ElseIf GetType(b) = #FUNCTION
         DebugPrint(space .. "[ ", a, " ]", b)
      Else
         DebugPrint(space .. "[ ", a, " ] = ", b)
      EndIf
      a, b = NextItem(table, a)
   Wend
EndFunction
Function helpers.IsNil(value) ;-------------------------------------------------
   ; === INSERITA NEL MODULO HELPERS ===
   
   ; Added: v0.5   Docs : 25.12.2008                                            
	; | Returns TRUE if value is nil otherwise returns FALSE                    |

   If GetType(value) = #NIL Then Return(True) Else Return(False)
EndFunction
Function helpers.FieldIsNil(table, fieldname) ;---------------------------------
   ; === INSERITA NEL MODULO HELPERS ===

   ; Added: v0.5   Docs : 25.12.2008
	; | Returns TRUE if the <fieldname> element is defined within the table     |
   ; | <table>, otherwise returns false.                                       |

   If GetType(table) = #NIL Then Return(True)
   If GetType(RawGet(table, fieldname)) = #NIL Then Return(True) Else Return(False) 
EndFunction
Function helpers.CountEntries(table) ;------------------------------------------
   ; === INSERITA NEL MODULO HELPERS ===

   ; Added: v0.5   Docs : 25.12.2008
	; | Counts how many elements are stored in the given <table>                |

   ; count -> entries count, a -> table index, b -> table element               
   Local count = 0
   Local a, b
    
   ; Scan the given table and count its entries                                 
   a, b = NextItem(table)
   While GetType(a) <> #NIL
      a, b = NextItem(table, a)
      count = count + 1
   Wend
   Return(count)
EndFunction

Function scui.Keyboard_Handler(msg) ;-----------------------------| PRIVATE |---
Local w = scui.Win.FindByHandler(msg.id)
Local wname = w.Name

   ; Added: v0.6   Docs : 20.12.2008                                            
	; | Handle every keystroke the user has inputed, this permit to handle      |
	; | gadget's shortcuts, keystrokes inside the text gadgets and gui          |
	; | navigation using the keyboard.                                          |

   ; Check in which input-mode type the Keyboard_Handler is                     
   ;   #KEYBOARD_IFOMODE means that the received keys must be processed for the 
   ;                     gui navigation                                         
   ;   #KEYBOARD_INPUTMODE means that a StringBox are currently active and must 
   ;                       receive all the keys as user input                   

   ; PROCESS THE #KEYBOARD_IFOMODE                                              
   If scui.Keyboard[wname].Mode = #KEYBOARD_IFOMODE
      If msg.action = "OnKeyDown"
         ; Handle the KEYDOWN event                   +----------------------+
; ----------------------------------------------------| Move to the NEXT IFO |--
         If msg.key = scui.prefs.INav_Next ;          +----------------------+
            If scui.Keyboard[wname].ActiveIFO = -1
               ; If there isn't an active IFO find and activate the first one   
               ; available                                                      
               Local found = scui.Keyboard_FirstAvailableIFO(wname)
               If found <> -1
                  scui.Keyboard[wname].ActiveIFO = found
                  scui.HandleObject( { id = found, action = "OnMouseOver", Keyboard = 1, Display = msg.id } )
               EndIf
            Else
               ; If there is an active IFO search and activate the next one     
               ; available                                                      
               Local found = scui.Keyboard_NextAvailableIFO(wname)
               If found = -1
                  ; No next IFO available, activate the first one               
                  Local ffound = scui.Keyboard_FirstAvailableIFO(wname)
                  If ffound <> -1
                     If scui.Keyboard[wname].ActiveIFO > 0 Then scui.HandleObject( { id = scui.Keyboard[wname].ActiveIFO, action = "OnMouseOut", Keyboard = 1, Display = msg.id })
                     scui.Keyboard[wname].ActiveIFO = ffound
                     scui.HandleObject( { id = ffound, action = "OnMouseOver", Keyboard = 1, Display = msg.id } )
                  EndIf
               Else
                  scui.HandleObject( { id = scui.Keyboard[wname].ActiveIFO, action = "OnMouseOut", Keyboard = 1, Display = msg.id })
                  scui.Keyboard[wname].ActiveIFO = found
                  scui.HandleObject( { id = found, action = "OnMouseOver", Keyboard = 1, Display = msg.id } )
               EndIf
            EndIf    

         ElseIf msg.key = scui.prefs.INav_Prev
            ; move to the previous IFO                                          
            If scui.Keyboard[wname].ActiveIFO = -1
               ; If there isn't an active IFO find and activate the last one    
               ; available                                                      
               Local found = scui.Keyboard_LastAvailableIFO(wname)
               If found <> -1
                  scui.Keyboard[wname].ActiveIFO = found
                  scui.HandleObject( { id = found, action = "OnMouseOver", Keyboard = 1, Display = msg.id } )
               EndIf
            Else
               ; If there is an active IFO search and activate the previous one 
               ; available                                                      
               Local found = scui.Keyboard_PrevAvailableIFO(wname)
               If found = -1
                  ; IFO precedente non disponibile, riparte dalla fine          
                  Local ffound = scui.Keyboard_LastAvailableIFO(wname)
                  If ffound <> -1
                     ; No previous IFO available, activate the last one         
                     If scui.Keyboard[wname].ActiveIFO > 0 Then scui.HandleObject( { id = scui.Keyboard[wname].ActiveIFO, action = "OnMouseOut", Keyboard = 1, Display = msg.id })
                     scui.Keyboard[wname].ActiveIFO = ffound
                     scui.HandleObject( { id = ffound, action = "OnMouseOver", Keyboard = 1, Display = msg.id } )
                  EndIf
               Else
                  scui.HandleObject( { id = scui.Keyboard[wname].ActiveIFO, action = "OnMouseOut", Keyboard = 1, Display = msg.id })
                  scui.Keyboard[wname].ActiveIFO = found
                  scui.HandleObject( { id = found, action = "OnMouseOver", Keyboard = 1, Display = msg.id } )
               EndIf
            EndIf

         ElseIf msg.key = scui.prefs.INav_Activate
            ; Activate the IFO that currently has been hilighted                
            ; ==================================================================
            ; ===== QUESTO IF QUA SOTTO MI SA CHE E' TOTALMENTE INUTILE!!! =====
            ; ==================================================================
            If scui.Keyboard[wname].Mode = #KEYBOARD_IFOMODE
               If scui.Keyboard[wname].ActiveIFO > 0
                  scui.ActiveStatus = ""
                  scui.HandleObject( { id = scui.Keyboard[wname].ActiveIFO, action = "OnMouseDown", Keyboard = 1, Display = msg.id } )
               EndIf
            EndIf

            ; ==================================================================
            ; === ATTENZIONE: MAPPARE ANCHE LA NUOVA CLASSE SCROLLER!!       ===
            ; ==================================================================
         ElseIf msg.key = scui.prefs.INav_ScrollerPlus
            ; Increase the value of the currently active Scroller               
            If scui.Keyboard[wname].ActiveIFO > 0
               If scui.IFO[scui.Keyboard[wname].ActiveIFO].oClass = #IFOCLASS_SIMPLESCROLLER
                  scui.ActiveStatus = ""
                  Local scroller = scui.Get(scui.Keyboard[wname].ActiveIFO)
                  Local newval = scroller.Value + scroller.MinStep
                  If newval > scroller.MMax Then newval = scroller.MMax
                  scui.Set(scroller.oName, { Value = newval }, 1)
               EndIf
            EndIf

            ; ==================================================================
            ; === ATTENZIONE: MAPPARE ANCHE LA NUOVA CLASSE SCROLLER!!       ===
            ; ==================================================================
         ElseIf msg.key = scui.prefs.INav_ScrollerMinus
            ; Decrease the vaule of the currently active Scroller               
            If scui.Keyboard[wname].ActiveIFO > 0
               If scui.IFO[scui.Keyboard[wname].ActiveIFO].oClass = #IFOCLASS_SIMPLESCROLLER
                  scui.ActiveStatus = ""
                  Local scroller = scui.Get(scui.Keyboard[wname].ActiveIFO)
                  Local newval = scroller.Value - scroller.MinStep
                  If newval < scroller.MMin Then newval = scroller.MMin
                  scui.Set(scroller.oName, { Value = newval }, 1)
               EndIf
            EndIf

            ; ==================================================================
            ; === ATTENZIONE: MAPPARE ANCHE LA NUOVA CLASSE SCROLLER!!       ===
            ; ==================================================================
         ElseIf msg.key = scui.prefs.INav_ScrollerHome
            ; Set the minimum value of the currently active Scroller            
            If scui.Keyboard[wname].ActiveIFO > 0
               If scui.IFO[scui.Keyboard[wname].ActiveIFO].oClass = #IFOCLASS_SIMPLESCROLLER
                  scui.ActiveStatus = ""
                  Local scroller = scui.Get(scui.Keyboard[wname].ActiveIFO)
                  scui.Set(scroller.oName, { Value = scroller.MMin }, 1)
               EndIf
            EndIf

            ; ==================================================================
            ; === ATTENZIONE: MAPPARE ANCHE LA NUOVA CLASSE SCROLLER!!       ===
            ; ==================================================================
         ElseIf msg.key = scui.prefs.INav_ScrollerEnd
            ; Set the maximum value of the currently active Scroller            
            If scui.Keyboard[wname].ActiveIFO > 0
               If scui.IFO[scui.Keyboard[wname].ActiveIFO].oClass = #IFOCLASS_SIMPLESCROLLER
                  scui.ActiveStatus = ""
                  Local scroller = scui.Get(scui.Keyboard[wname].ActiveIFO)
                  scui.Set(scroller.oName, { Value = scroller.MMax }, 1)
               EndIf
            EndIf
         Else
            ; === INSERT HERE OTHER PARSING IF NEEDED ==========================
         EndIf

         ; Check if the pressed key correspond to an assigned shortcut          
         If helpers.FieldIsNil(scui.Keyboard[wname].Shortcuts, msg.key) = 0
            If (scui.Keyboard[wname].ActiveIFO > 0) & (scui.Keyboard[wname].ActiveIFO <> scui.Keyboard[wname].Shortcuts[msg.key])
               scui.IFO[scui.Keyboard[wname].ActiveIFO].Status = #IFOSTATUS_NORMAL
               scui.RenderObject(scui.Keyboard[wname].ActiveIFO)
            EndIf

            ; To activate the object that has the shortcut attached, will be    
            ; generated and event of HILIGHT and an event of ACTIVATION sending 
            ; the activation key to the keyboard handler                        
            scui.Keyboard[wname].ActiveIFO = scui.Keyboard[wname].Shortcuts[msg.key]
            If scui.IFO[scui.Keyboard[wname].ActiveIFO].Status <> #IFOSTATUS_HILIGHTED
               scui.IFO[scui.Keyboard[wname].ActiveIFO].Status = #IFOSTATUS_HILIGHTED
            EndIf
            scui.ActiveStatus = ""
            scui.Keyboard_Handler({ key = scui.prefs.INav_Activate, action = "OnKeyDown", id = msg.id})
         EndIf

      ElseIf msg.action = "OnKeyUp"
         ; Handle the KEYUP event                                               
         If msg.key = scui.prefs.INav_Activate
            ; ==================================================================
            ; ===== QUESTO IF QUA SOTTO MI SA CHE E' TOTALMENTE INUTILE!!! =====
            ; ==================================================================
            If scui.Keyboard[wname].Mode = #KEYBOARD_IFOMODE
            ; **** GESTIRE BENE ACTIONSTATUS ****
               scui.ActionStatus = ""
               If scui.Keyboard[wname].ActiveIFO > 0 Then scui.HandleObject( { id = scui.Keyboard[wname].ActiveIFO, action = "OnMouseUp", Keyboard = 1, Display = msg.id } )
            EndIf
         Else
            If helpers.FieldIsNil(scui.Keyboard[wname].Shortcuts, msg.key) = 0 Then scui.Keyboard_Handler({ key = scui.prefs.INav_Activate, action = "OnKeyUp", id = msg.id})
         EndIf
      EndIf

   ; PROCESS THE #KEYBOARD_INPUTMODE                                            
   ElseIf scui.Keyboard[wname].Mode = #KEYBOARD_INPUTMODE
      If msg.action = "OnKeyDown"
         ; Handle KEYDOWN event                                                 
         If msg.key = "ACTIVATE"
            ; Handle a special code send when the StringBox need initialization 
            scui.Keyboard_InitializeInputBox(wname)
            Local Cursor     = 0
            XRenderOffset = 0
            Return
         Else
            ; The active StringBox has been initialized so parse the input from 
            ; the user                                                          
            Local TextStruct   = scui.Keyboard[wname].TextStruct
            Local Area         = scui.Keyboard[wname].Area
            Local oMargins     = scui.Keyboard[wname].oMargins
            Local BevelBox     = scui.Keyboard[wname].BevelBox
            Local CursorPos    = scui.Keyboard[wname].CursorPos
            Local SourceString = scui.Keyboard[wname].SourceString
            Local MaxLen       = scui.Keyboard[wname].MaxLen
            Local Enter        = scui.prefs.INav_Activate

            ; EDIT LOOP                                                         
            KK = msg.key
            If StrLen(KK)=1
               ; Accept only 1 char lenght strings and filter this character    
               ; with the allowed characters mask                               
               ; ===============================================================
               ; === POSSIBILE MIGLIORAMENTO                                   =
               ; === Quando creo uno StringBox posso inizializzare il campo    =
               ; === 'AllowedCharSet' con tutti i caratteri che possono essere =
               ; === accettati, qua sotto a questo punto avro' un solo test che=
               ; === verifica se il carattere premuto e' compreso fra quelli   =
               ; === permessi testando 'AllowedCharSet'. Lo Switch - Case viene=
               ; === eliminato del tutto.                                      =
               ; ===============================================================
               Switch scui.Keyboard[wname].StringBoxInfos.InputType
                  Case #GETKEY_ALPHABETIC
                     If FindStr(scui.prefs.AlphabeticSet, KK, False) < 0 
                        KK = ""
                     Else
                        If helpers.FieldIsNil(scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions, "onkeypress") = 0 Then scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions.OnKeyPress({id = scui.Keyboard[wname].ActiveStringBox, event = "OnKeyPress"})
                     EndIf    
                  Case #GETKEY_NUMERIC
                     If FindStr(scui.prefs.NumericSet, KK, False) < 0
                        KK = ""
                     Else
                        If helpers.FieldIsNil(scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions, "onkeypress") = 0 Then scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions.OnKeyPress({id = scui.Keyboard[wname].ActiveStringBox, event = "OnKeyPress"})
                     EndIf
                  Case #GETKEY_CUSTOM
                     If FindStr(scui.Keyboard[wname].StringBoxInfos.CustomCharacters .. Chr(10), KK, True) < 0
                        KK = ""
                     Else
                        If helpers.FieldIsNil(scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions, "onkeypress") = 0 Then scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions.OnKeyPress({id = scui.Keyboard[wname].ActiveStringBox, event = "OnKeyPress"})
                     EndIf
                  Case #GETKEY_ALL
                     If helpers.FieldIsNil(scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions, "onkeypress") = 0 Then scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions.OnKeyPress({id = scui.Keyboard[wname].ActiveStringBox, event = "OnKeyPress"})
               EndSwitch
            EndIf

            ; PARSE USER INPUT                                                  
            If (KK <> "") and (StrLen(KK)=1) and (KK <> Chr(10))
               t = TextStruct.Content.Values[0]
               ; Handle The String                                              
               If InsertMode = 1
                  If StrLen(TextStruct.Content.Values[0]) < MaxLen
                     ; Insert Mode                                              
                     a = CursorPos - 1
                     b = StrLen(t) - ( CursorPos - 1)
                     If CursorPos > StrLen(t) Then b = 0
                        t = LeftStr(t, a) ..KK.. RightStr(t, b)
                        TextStruct.Content.Values[0] = t
                        KK = "RIGHT-OVER"
                     EndIf
                  Else
                     ; Overwrite Mode                                           
                     a = CursorPos - 1
                     b = StrLen(t) - CursorPos
                     If CursorPos >= StrLen(t) Then b = 0
                     t = LeftStr(t, a) ..KK.. RightStr(t, b)
                     TextStruct.Content.Values[0] = t  
                     KK = "RIGHT-OVER"       
                  EndIf
                  RenderFlag = 1
               EndIf

               ; Parse Cursor and special Keys                                  
               If KK = "RIGHT-OVER"
                  ; --- CHECK RIGHT SCROLL AFTER INSERTION ---------------------
                  ; Calculate Character Width                                   
                  CChar = MidStr(TextStruct.Content.Values[0], CursorPos - 1, 1)
                  CWidth = TextWidth(CChar)
                  ; Check if we have to scroll the string                       
                  If Cursor_xEnd > (Area.xEnd - CWidth  - oMargins.x) Then XRenderOffset = XRenderOffset - CWidth
                  CursorPos = CursorPos + 1
                  ; Check if we have reached the max string lenght              
                  If CursorPos > StrLen(TextStruct.Content.Values[0]) + 1 Then CursorPos = StrLen(TextStruct.Content.Values[0]) + 1            
                  RenderFlag = 1
                  KK = ""
               ElseIf KK = scui.prefs.IBox_Right
                  ; --- MOVE CURSOR TO THE RIGHT -------------------------------
                  ; Calculate Character Width                                   
                  CChar = MidStr(TextStruct.Content.Values[0], CursorPos, 1)
                  CWidth = TextWidth(CChar)
                  ; Check if we have to scroll the string                       
                  If Cursor_xEnd > (Area.xEnd - CWidth  - oMargins.x) Then XRenderOffset = XRenderOffset - CWidth
                  CursorPos = CursorPos + 1
                  ; Check if we have reached the max string lenght              
                  If CursorPos > StrLen(TextStruct.Content.Values[0]) + 1 Then CursorPos = StrLen(TextStruct.Content.Values[0]) + 1            
                  RenderFlag = 1
                  KK = ""
               ElseIf KK = scui.prefs.IBox_Left
                  ; --- MOVE CURSOR TO THE LEFT --------------------------------
                  CChar = MidStr(TextStruct.Content.Values[0], CursorPos - 1, 1)
                  CWidth = TextWidth(CChar)
                  ; Check if we have to scroll the string                       
                  If Cursor_xStart < (Area.xStart + CWidth  + oMargins.x) Then XRenderOffset = XRenderOffset + CWidth
                  CursorPos = CursorPos - 1
                  ; Check if we have reached the max string lenght              
                  If CursorPos < 1 
                     CursorPos = 1
                     XRenderOffset = 0
                  EndIf
                  RenderFlag = 1
                  KK = ""
               ElseIf KK = scui.prefs.IBox_Home
                  ; --- MOVE CURSOR AT THE BEGGINING ---------------------------
                  CursorPos = 1
                  RenderFlag = 1
                  XRenderOffset = 0
                  KK = ""
               ElseIf KK = scui.prefs.IBox_End
                  ; --- MOVE THE CURSOR AT THE END -----------------------------
                  CursorPos = StrLen(TextStruct.Content.Values[0])
                  RenderOffset = 0
                  CChar = RightStr(TextStruct.Content.Values[0], 1)
                  CCharW = TextWidth(CChar)
                  CWidth = TextWidth(TextStruct.Content.Values[0])          
                  XRenderOffset = -CWidth + Area.xEnd - Area.xStart - oMargins.x - CCharW
                  RenderFlag = 1
                  KK = ""
               ElseIf KK = scui.prefs.IBox_Del
                  ; --- DEL: Remove character at the right of the cursor -------
                  t = TextStruct.Content.Values[0]
                  TextStruct.Content.Values[0] = LeftStr(t, CursorPos -1  + RenderOffset)..RightStr(t, StrLen(t) - CursorPos  - RenderOffset)
                  RenderFlag = 1
                  KK = ""
               ElseIf KK = scui.prefs.IBox_Backspace
                  ; --- BACKSPACE: Remove character at le left of the cursor ---
                  If CursorPos > 1
                     t = TextStruct.Content.Values[0]
                     CChar = MidStr(TextStruct.Content.Values[0], CursorPos - 2, 1)
                     TextStruct.Content.Values[0] = LeftStr(t, CursorPos -2  + RenderOffset)..RightStr(t, StrLen(t) - CursorPos +1  - RenderOffset)
                     CWidth = TextWidth(CChar)
                     ; Check if we have to scroll the string                    
                     If Cursor_xStart < (Area.xStart + CWidth  + oMargins.x) Then XRenderOffset = XRenderOffset + CWidth
                     CursorPos = CursorPos - 1
                     ; Check if we have reached the max string lenght           
                     If CursorPos < 1 
                        CursorPos = 1
                        XRenderOffset = 0
                     EndIf
                  EndIf
                  RenderFlag = 1
                  KK = ""
               ElseIf KK = scui.prefs.IBox_Escape
                  ; --- DISCARD CHANGES ----------------------------------------
                  CursorPos = 1
                  TextStruct.Content.Values[0] = SourceString
                  RenderFlag = 1
                  KK = ""
               ElseIf KK = scui.prefs.IBox_Overwrite
                  ; --- ACTIVATE OVERWRITE -------------------------------------
                  If InsertMode = 1 Then InsertMode = 0 Else InsertMode = 1
               ElseIf KK = Chr(10)
                  ; --- EXIT FROM STRING BOX -----------------------------------
                  scui.Keyboard[wname].Mode = #KEYBOARD_IFOMODE
                  KK = ""
                  scui.Set(scui.Keyboard[wname].ActiveStringBox, { Value = TextStruct.Content.Values[0] })
                  If scui.Keyboard[wname].StringBoxState = "IN"
                     scui.IFO[scui.Keyboard[wname].ActiveStringBox].Status = #IFOSTATUS_HILIGHTED
                  Else
                     scui.IFO[scui.Keyboard[wname].ActiveStringBox].Status = #IFOSTATUS_NORMAL
                  EndIf
                  scui.RenderObject(scui.Keyboard[wname].ActiveStringBox)
                  If TextStruct.Content.Values[0] <> SourceString
                     If helpers.FieldIsNil(scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions, "onchange") = 0 Then scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions.OnChange({id = scui.Keyboard[wname].ActiveStringBox, event = "OnChange"})
                  EndIf
                  If helpers.FieldIsNil(scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions, "onexit") = 0 Then scui.IFO[scui.Keyboard[wname].ActiveStringBox].Actions.OnExit({id = scui.Keyboard[wname].ActiveStringBox, event = "OnExit", value = TextStruct.Content.Values[0]})
                  Return
               EndIf
                                    ; ==========================================
               Local RenderFlag = 1 ; <<<<<< MA CHE E' STA ROBA ???? INDAGARE...
                                    ; ==========================================
               If RenderFlag = 1
                  scui.Win.Select(wname)
                  TextStruct.Area.xStart = Area.xStart + XRenderOffset
                  scui.DrawBevel(BevelBox)
                  scui.SafeClipRegion(#EDITTEXT_CLIPID, #BOX, 
                                      Area.xStart, Area.yStart, 
                                      Area.xEnd - Area.xStart - oMargins.x, Area.yEnd - Area.yStart - oMargins.y)
                  SetClipRegion(#EDITTEXT_CLIPID)

                  scui.DrawText(TextStruct, #NOCLIP)
                  SetClipRegion(#NONE)
                  FreeClipRegion(#EDITTEXT_CLIPID)

                  ; Calculate Cursor Starting position                          
                  ; CursorPos is the character number under the cursor          
                  Local LeftSide = LeftStr(TextStruct.Content.Values[0], CursorPos - 1)
                  Local CursorX = TextWidth(LeftSide)                    

                  ; Calculate Cursor Width                                      
                  CursorChar = MidStr(TextStruct.Content.Values[0], CursorPos - 1, 1)
                  CursorWidth = TextWidth(CursorChar)

                  ; Calculate Cursor Height                                     
                  CursorHeight = TextHeight(CursorChar)

                  ; Y Centering                                                 
                  LineHeight = TextHeight(TextToRender) + TextStruct.Content.VerticalOffset
                  If TextStruct.Shadow.Type <> #TEXTSHADOW_NONE Then LineHeight = LineHeight - TextStruct.Shadow.Distance
                  If EdgeFlagSimple = 1 Then LineHeight = LineHeight - (TextStruct.Edge.Size+1) * 2

                  tTextHeight = LineHeight * TextStruct.Content.Lines
                  YArea = (TextStruct.Area.yEnd - TextStruct.Area.yStart) - TextStruct.Margins.y*2 
                  YPosition = (( YArea - tTextHeight ) / 2 ) + TextStruct.Area.yStart + TextStruct.Margins.y + TextStruct.Content.VerticalOffset / 2

                  ; Draw Cursor Box                                             
                  If CursorWidth  = 0 Then CursorWidth = 8
                  If CursorHeight = 0 Then CursorHeight = 8
                  Cursor_xStart = TextStruct.Area.xStart + CursorX + TextStruct.Margins.x
                  Cursor_yStart = YPosition
                  Cursor_xEnd   = Cursor_xStart + CursorWidth
                  Cursor_yEnd   = Cursor_yStart + CursorHeight
                  scui.SafeClipRegion(#EDITTEXT_CLIPID, #BOX, Area.xStart, Area.yStart, Area.xEnd - Area.xStart, Area.yEnd - Area.yStart)
                  SetClipRegion(#EDITTEXT_CLIPID)
                  SetFillStyle(#FILLCOLOR)

                  ; Selezione tipo di cursore                                   
                  If CursorType = #LINEEDIT_CURSORUNDER
                     Box(Cursor_xStart, Cursor_yStart + CursorHeight - 2, CursorWidth, 2, CursorColor)
                  ElseIf CursorType = #LINEEDIT_CURSORLINE
                     Box(Cursor_xStart, Cursor_yStart, 2, CursorHeight, CursorColor)
                  Else
                     Box(Cursor_xStart, Cursor_yStart, CursorWidth, CursorHeight, CursorColor)
                  EndIf

                  ; Draw Character under Cursor                                 
                  SetFontColor(TextCursorColor)                 
                  TextOut(Cursor_xStart, Cursor_yStart, CursorChar)
                  SetClipRegion(#NONE)
                  FreeClipRegion(#EDITTEXT_CLIPID)
                                                  ; ============================
                  RenderFlag = 0                  ; Clear the Render Flag ????  
                                                  ; ============================
               EndIf
               scui.Keyboard[wname].LeftSide  = LeftSide
               scui.Keyboard[wname].LineData  = LineData
               scui.Keyboard[wname].CursorX   = CursorX        
               scui.Keyboard[wname].CursorPos = CursorPos
            EndIf
         Else
            msg.key = ""
      EndIf
   EndIf
EndFunction
Function scui.Keyboard_InitializeInputBox(wname) ;----------------| PRIVATE |---
   ; Added: v0.6   Docs : 20.12.2008                                            
	; | Used to initialize a StringGadget upon its activation.                  |

   ; scui.Keyboard.StringBoxInfos Structure's fields:                           
   ;  .Area                                                                     
   ;  .Value                                                                    
   ;  .Margins                                                                  
   ;  .MaxLen                                                                   
   ;  .InputType                                                                
   ;  .Spec                                                                     

   ; Read the content of the StringBoxInfos structure
   Local SBI       = scui.Keyboard[wname].StringBoxInfos
   Local Options   = SBI.Spec
   Local Area      = SBI.Area
   Local oMargins  = SBI.Margins
   Local MaxLen    = SBI.MaxLen
   Local oString   = SBI.Value
   Local InputType = SBI.InputType

   ; Check the tag <Clear1st> and if we have to clear the StringBox contents    
   If scui.IFO[scui.Keyboard[wname].ActiveStringBox].Clear1st = 1
      If helpers.FieldIsNil(scui.IFO[scui.Keyboard[wname].ActiveStringBox], "cleared") = 1
         scui.IFO[scui.Keyboard[wname].ActiveStringBox].Cleared = "Yes"
         oString.Values[0] = ""
      EndIf
   EndIf

   Local temp_TextStruct = { Area = { xStart = Area.xStart, yStart = Area.yStart, 
                                      xEnd   = Area.xEnd,   yEnd   = Area.yEnd },
                             Margins = { x = oMargins.x, 
                                         y = oMargins.y },
                             Content = { Values = { oString.Values[0] }, Lines = 1},
                             FontName = Options.FontName, 
                             FontSize = Options.FontSize }
   Local temp_DLineEditText = scui.theme.StringBox_EditText   
   If helpers.FieldIsNil(Options, "spec") = 0 Then temp_DLineEditText = scui.NewText(temp_DLineEditText,Options.Spec)
   Local TextStruct = scui.NewText(temp_DLineEditText, temp_TextStruct)
   Local temp_Bevel = { Position = { x = Area.xStart, 
                                     y = Area.yStart },
                        Size     = { x = Area.xEnd - Area.xStart,
                                     y = Area.yEnd - Area.yStart } }
   Local BevelBox = scui.NewBevel(scui.theme.StringBox_EditBox, temp_Bevel)

   ; If <Options> doesn't exists get the default ones                           
   ; ***************************************************************************
   ; *** A VEDERE COSI' IL CODICE SEMBREREBBE CHE SE OPTIONS NON ESISTE IL   ***
   ; *** PROGRAMMA DOVREBBE DARE ERRORE A CAUSA DELL'ASSEGNAZIONE ALLA RIGA  ***
   ; *** 1011, CONTROLLARE BENE.                                             ***
   ; ***************************************************************************
   If helpers.IsNil(Options) = 1 Then Options = scui.theme.StringBoxParams

   ; Options parsing                                                            
   If helpers.FieldIsNil(Options, "insertmode"     ) = 0 Then InsertMode      = Options.InsertMode      Else InsertMode      = scui.theme.StringBoxParams.InsertMode
   If helpers.FieldIsNil(Options, "waitunit"       ) = 0 Then WaitUnit        = Options.WaitUnit        Else WaitUnit        = scui.theme.StringBoxParams.WaitUnit
   If helpers.FieldIsNil(Options, "firstwait"      ) = 0 Then FirstWait       = Options.FirstWait       Else FirstWait       = scui.theme.StringBoxParams.FirstWait
   If helpers.FieldIsNil(Options, "autorepeat"     ) = 0 Then AutoRepeat      = Options.AutoRepeat      Else AutoRepeat      = scui.theme.StringBoxParams.AutoRepeat
   If helpers.FieldIsNil(Options, "cursorcolor"    ) = 0 Then CursorColor     = Options.CursorColor     Else CursorColor     = scui.theme.StringBoxParams.CursorColor
   If helpers.FieldIsNil(Options, "cursortype"     ) = 0 Then CursorType      = Options.CursorType      Else CursorType      = scui.theme.StringBoxParams.CursorType
   If helpers.FieldIsNil(Options, "textcursorcolor") = 0 Then TextCursorColor = Options.TextCursorColor Else TextCursorColor = scui.theme.StringBoxParams.TextCursorColor
   If helpers.FieldIsNil(Options, "inputtype"      ) = 0 Then InputType       = Options.InputType       Else InputType       = scui.theme.StringBoxParams.InputType

   ; Store the original content & setup a temp container                        
   Local SourceString = TextStruct.Content.Values[0]
   Local TempString   = SourceString

   ; Setup the rendering area & create a clip region                            
   TextStruct.Area = { xStart = Area.xStart, yStart = Area.yStart, 
                       xEnd   = Area.xEnd,   yEnd   = Area.yEnd }

   ; Setup some variables                                                       
   Local CursorPos     = 1                       ; Starting Cursor Position     
   Local Timeout       = 0                       ; Reset Timeout for Autorepeat 
   Local Previous      = ""                      ; Previous pressed key         
   Local PreviousText  = SourceString            ; Previous stored text         
   Local RenderFlag    = 1                       ; 1 = Need a render            
   Local ExitFlag      = 0                       ; 1 = Editing terminated       
   Local RenderOffset  = 0                       ; Offset for scrolling         
   Local XRenderOffset = 0                       ; ???                          

   ; Cut the string if beyond its max lenght                                    
   If StrLen(TextStruct.Content.Values[0]) > MaxLen Then TextStruct.Content.Values[0] = LeftStr(TextStruct.Content.Values[0], MaxLen)
    
   scui.Keyboard[wname].TextStruct   = TextStruct
   scui.Keyboard[wname].Area         = Area
   scui.Keyboard[wname].oMargins     = oMargins
   scui.Keyboard[wname].BevelBox     = BevelBox
   scui.Keyboard[wname].CursorPos    = 1
   scui.Keyboard[wname].SourceString = TextStruct.Content.Values[0]
   scui.Keyboard[wname].MaxLen       = MaxLen

   ; Calculate Cursor Starting position                                         
   ; Note that <CursorPos> is the character number under the cursor             
   scui.Keyboard[wname].LeftSide = LeftStr(TextStruct.Content.Values[0], CursorPos - 1)
   scui.Keyboard[wname].CursorX = TextWidth(LeftSide)

   ; Render the current StringBox                                               
   ; ===========================================================================
   ; === VERIFICARE PIU' IN BASSO!!! QUA SEMBRA CHE LA STRINGBOX SIA         ===
   ; === RENDERIZZATA DUE VOLTE DI SEGUITO!!                                 ===
   ; ===========================================================================
   scui.DrawBevel(BevelBox)
   scui.SafeClipRegion(#EDITTEXT_CLIPID, #BOX, 
                       Area.xStart, 
                       Area.yStart, 
                       Area.xEnd - Area.xStart - oMargins.x, 
                       Area.yEnd - Area.yStart - oMargins.y)
   SetClipRegion(#EDITTEXT_CLIPID)

   scui.DrawText(TextStruct, #NOCLIP)
   SetClipRegion(#NONE)
   FreeClipRegion(#EDITTEXT_CLIPID)
                                 ; =============================================
   Local RenderFlag = 1          ; <<<< ??? SEMBRA NON NECESSARIO            ===
                                 ; =============================================
   If RenderFlag = 1
      TextStruct.Area.xStart = Area.xStart + XRenderOffset
      scui.DrawBevel(BevelBox)
      scui.SafeClipRegion(#EDITTEXT_CLIPID, #BOX, 
                          Area.xStart, 
                          Area.yStart, 
                          Area.xEnd - Area.xStart - oMargins.x, 
                          Area.yEnd - Area.yStart - oMargins.y)
      SetClipRegion(#EDITTEXT_CLIPID)

      scui.DrawText(TextStruct, #NOCLIP)
      SetClipRegion(#NONE)
      FreeClipRegion(#EDITTEXT_CLIPID)

      ; Calculate Cursor Starting position                                      
      ; Note that <CursorPos> is the character number under the cursor          
      Local LeftSide = LeftStr(TextStruct.Content.Values[0], CursorPos - 1)
      Local CursorX = TextWidth(LeftSide)                    

      ; Calculate Cursor Width                                                  
      CursorChar = MidStr(TextStruct.Content.Values[0], CursorPos - 1, 1)
      CursorWidth = TextWidth(CursorChar)

      ; Calculate Cursor Height                                                 
      CursorHeight = TextHeight(CursorChar)

      ; Y Centering                                                             
      LineHeight = TextHeight(TextToRender) + TextStruct.Content.VerticalOffset
      If TextStruct.Shadow.Type <> #TEXTSHADOW_NONE Then LineHeight = LineHeight - TextStruct.Shadow.Distance
      If EdgeFlagSimple = 1 Then LineHeight = LineHeight - (TextStruct.Edge.Size+1) * 2

      tTextHeight = LineHeight * TextStruct.Content.Lines
      YArea = (TextStruct.Area.yEnd - TextStruct.Area.yStart) - TextStruct.Margins.y*2 
      YPosition = (( YArea - tTextHeight ) / 2 ) + TextStruct.Area.yStart + TextStruct.Margins.y + TextStruct.Content.VerticalOffset / 2

      ; Draw Cursor Box                                                         
      If CursorWidth  = 0 Then CursorWidth = 8
      If CursorHeight = 0 Then CursorHeight = 8
      Cursor_xStart = TextStruct.Area.xStart + CursorX + TextStruct.Margins.x
      Cursor_yStart = YPosition
      Cursor_xEnd   = Cursor_xStart + CursorWidth
      Cursor_yEnd   = Cursor_yStart + CursorHeight
      scui.SafeClipRegion(#EDITTEXT_CLIPID, #BOX, Area.xStart, 
                                                  Area.yStart, 
                                                  Area.xEnd - Area.xStart, 
                                                  Area.yEnd - Area.yStart)
      SetClipRegion(#EDITTEXT_CLIPID)
      SetFillStyle(#FILLCOLOR)

      ; Select which cursor type we have to render                              
      If CursorType = #LINEEDIT_CURSORUNDER
         ; Horizontal Line under the character                                  
         Box(Cursor_xStart, Cursor_yStart + CursorHeight - 2, CursorWidth, 2, CursorColor)
      ElseIf CursorType = #LINEEDIT_CURSORLINE
         ; Vertical Line at the character left                                  
         Box(Cursor_xStart, Cursor_yStart, 2, CursorHeight, CursorColor)
      Else
         ; Box cursor over the character                                        
         Box(Cursor_xStart, Cursor_yStart, CursorWidth, CursorHeight, CursorColor)
      EndIf

      ; Draw Character under Cursor                                             
      SetFontColor(TextCursorColor)                 
      TextOut(Cursor_xStart, Cursor_yStart, CursorChar)
      SetClipRegion(#NONE)
      FreeClipRegion(#EDITTEXT_CLIPID)
                                      ; ========================================
      RenderFlag = 0                  ; Clear the Render Flag ????              
                                      ; ========================================
   EndIf
EndFunction
Function scui.Keyboard_FirstAvailableIFO(wname) ;-----------------| PRIVATE |---
   ; Added: v0.6   Docs : 20.12.2008                                            
	; | Returns the ID of the first available IFO                               |

   Local i
   Local found = -1
   For i = 1 To scui.IFO.IDCounter
      If helpers.FieldIsNil(scui.IFO[i], "deleted") = 1
         If scui.IFO[i].Owner = wname And scui.IFO[i].oInteractive = 1 And scui.IFO[i].Enabled = #IFO_ENABLED
            found = i
            Break
         EndIf
      EndIf
   Next
   Return(found)
EndFunction
Function scui.Keyboard_LastAvailableIFO(wname) ;------------------| PRIVATE |---
   ; Added: v0.6   Docs : 20.12.2008                                            
	; | Returns the ID of the last available IFO                                |

   Local i
   Local found = -1
   For i = scui.IFO.IDCounter To 1 Step -1
      If helpers.FieldIsNil(scui.IFO[i], "deleted") = 1
         If scui.IFO[i].Owner = wname And scui.IFO[i].oInteractive = 1 And scui.IFO[i].Enabled = #IFO_ENABLED
            found = i
            Break
         EndIf
      EndIf
   Next
   Return(found)
EndFunction
Function scui.Keyboard_NextAvailableIFO(wname) ;------------------| PRIVATE |---
   ; Added: v0.6   Docs : 20.12.2008                                            
	; | Returns the ID of the next available IFO relative to the IFO stored in  |
   ; | scui.Keyboard.ActiveIFO                                                 |

   Local i
   Local found = -1
   For i = scui.Keyboard[wname].ActiveIFO + 1 To scui.IFO.IDCounter
      If helpers.FieldIsNil(scui.IFO[i], "deleted") = 1
         If scui.IFO[i].Owner = wname And scui.IFO[i].oInteractive = 1 And scui.IFO[i].Enabled = #IFO_ENABLED
            found = i
            Break
         EndIf
      EndIf
   Next
   Return(found)
EndFunction
Function scui.Keyboard_PrevAvailableIFO(wname) ;------------------| PRIVATE |---
   ; Added: v0.6   Docs : 20.12.2008                                            
	; | Returns the ID of the previous available IFO relative to the IFO stored |
   ; | in scui.Keyboard.ActiveIFO                                              |

   Local i
   Local found = -1
   For i = scui.Keyboard[wname].ActiveIFO - 1 To 1 Step -1
      If helpers.FieldIsNil(scui.IFO[i], "deleted") = 1
         If scui.IFO[i].Owner = wname And scui.IFO[i].oInteractive = 1 And scui.IFO[i].Enabled = #IFO_ENABLED
            found = i
            Break
         EndIf
      EndIf
   Next
   Return(found)
EndFunction

Function scui.DisableGadgets(owner) ;-----------------------------| PRIVATE |---
   Local count = scui.IFO.IDCounter
   For Local i = 1 To count
      ; If the IFO has the right owner will be enabled, but only if its Enabled 
      ; flag is on                                                              
      If helpers.FieldIsNil(scui.IFO[i], "deleted") = 1
         If scui.IFO[i].Owner = owner
            ; The field <oInteractive> states if the IFO has an active zone     
            ; (hollywood button) attached or not.                               
            If scui.IFO[i].oInteractive = 1
               DisableButton(i)
            EndIf
         EndIf
      EndIf
   Next
EndFunction
Function scui.EnableGadgets(owner) ;------------------------------| PRIVATE |---
   Local count = scui.IFO.IDCounter
   For Local i = 1 To count
      ; If the IFO has the right owner will be enabled, but only if its Enabled 
      ; flag is on                                                              
      If helpers.FieldIsNil(scui.IFO[i], "deleted") = 1
         If scui.IFO[i].Owner = owner
            ; The field <oInteractive> states if the IFO has an active zone     
            ; (hollywood button) attached or not.                               
            If scui.IFO[i].oInteractive = 1
               If scui.IFO[i].Enabled = #IFO_ENABLED Then EnableButton(i)
            EndIf
         EndIf
      EndIf
   Next
EndFunction
Function scui.EnableOwner(owner) ;--------------------------------| PRIVATE |---
   ; Added: v0.5   Docs : 24.12.2008                                            
	; | Enable all <owner>'s' gadgets and disable all the other ones            |

   ; Check all IFOs and enable the ones which have the appropriate field <Owner>
   Local count = scui.IFO.IDCounter
   For Local i = 1 To count
      ; If the IFO has the right owner will be enabled, but only if its Enabled 
      ; flag is on                                                              
      If helpers.FieldIsNil(scui.IFO[i], "deleted") = 1
         If scui.IFO[i].Owner = owner
            ; The field <oInteractive> states if the IFO has an active zone     
            ; (hollywood button) attached or not.                               
            If scui.IFO[i].oInteractive = 1
               If scui.IFO[i].Enabled = #IFO_ENABLED Then EnableButton(i)
            EndIf
         Else
            If scui.IFO[i].oInteractive = 1
               DisableButton(i)
            EndIf
         EndIf
      EndIf
   Next
EndFunction

Function helpers.AddColor255( component, amount ) ;-----------------------------
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | Adds <amount> to <component> and returns the resuoting value            |

   component = component + amount
   Return(Limit(component, 0, 255))
EndFunction
Function helpers.BrightColorRGB(r, g, b, amount) ;------------------------------
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | Adds <amount> to the single color components passed and returns the     |
   ; | resulting color value                                                   |

   r = helpers.AddColor255(r, amount)
   g = helpers.AddColor255(g, amount)
   b = helpers.AddColor255(b, amount)
   Return(RGB(r, g, b), r, g, b)
EndFunction
Function helpers.DarkColorRGB(r, g, b, amount) ;--------------------------------
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | Subtracts <amount> to the single color components passed and returns the|
   ; | resulting color value                                                   |

   r = helpers.AddColor255( r, -amount )
   g = helpers.AddColor255( g, -amount )
   b = helpers.AddColor255( b, -amount )
   Return(RGB(r, g, b), r, g, b)
EndFunction
Function helpers.BrightColor(color, amount) ;-----------------------------------
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | Adds <amount> to the single color components passed and returns the     |
   ; | resulting color components                                              |

   newcolor = {}
   newcolor.r = helpers.AddColor255(color.r, amount)
   newcolor.g = helpers.AddColor255(color.g, amount)
   newcolor.b = helpers.AddColor255(color.b, amount)
   Return(newcolor)
EndFunction
Function helpers.DarkColor(color, amount) ;-------------------------------------
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | Subtract <amount> from the single color components passed and returns   |
   ; | the resulting color components                                          |

   newcolor = {}
   newcolor.r = helpers.AddColor255( color.r, -amount )
   newcolor.g = helpers.AddColor255( color.g, -amount )
   newcolor.b = helpers.AddColor255( color.b, -amount )
   Return(newcolor)
EndFunction

Function scui.DrawText(TextStruct, ClipMode) ;--------------------| PRIVATE |---
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | Draw to the screen the given <TextStruct>                               |

   If helpers.IsNil(TextStruct) = 1 Then Return

   ; If requested setup a clip region                                           
   Local xs, ys, xe, ye

   If ClipMode <> #NOCLIP 
      ; Calculate the region coordinates                                        
      xs = TextStruct.Area.xStart
      ys = TextStruct.Area.yStart
      xe = TextStruct.Area.xEnd - TextStruct.Area.xStart - TextStruct.Margins.x
      ye = TextStruct.Area.yEnd - TextStruct.Area.yStart - TextStruct.Margins.y
      scui.SafeClipRegion(#EDITTEXT_CLIPID, #BOX, xs, ys, xe, ye)
      SetClipRegion(#EDITTEXT_CLIPID)
   EndIf

   ; PRIMA DI RENDERIZZARE IL TESTO VERIFICO SE DEVO GESTIRE UNA ICONA
   ; Variabili da usare successivamente per allineare il testo
   Local icon_size = { 0, 0 }

   If Not(helpers.FieldIsNil(TextStruct, "icon"))
      Local xpos = TextStruct.Area.xStart + TextStruct.Margins.x
      Local ypos = TextStruct.Area.yStart + TextStruct.Margins.y
      
      Local bid = scui.Icons[TextStruct.Icon.Name].BrushId
      icon_size = { GetAttribute(#BRUSH, bid, #ATTRWIDTH) + TextStruct.Icon.Gap, GetAttribute(#BRUSH, bid, #ATTRHEIGHT ) + TextStruct.Icon.Gap}
      
      If (TextStruct.Icon.Align & #TEXTALIGN_LEFT) = #TEXTALIGN_LEFT
         ; Lascio così
         
         If TextStruct.Icon.AdjText
            If (TextStruct.Alignment & #TEXTALIGN_LEFT) = #TEXTALIGN_LEFT
               ; OK COSI'
            ElseIf (TextStruct.Alignment & #TEXTALIGN_HCENTER) = #TEXTALIGN_HCENTER
               icon_size[0] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_RIGHT) = #TEXTALIGN_RIGHT
               ; OK COSI'
            EndIf
         EndIf
             
      ElseIf (TextStruct.Icon.Align & #TEXTALIGN_RIGHT) = #TEXTALIGN_RIGHT
         ; Allineo a destra
         xpos = TextStruct.Area.xEnd - TextStruct.Margins.x - GetAttribute(#BRUSH, bid, #ATTRWIDTH)

         If TextStruct.Icon.AdjText
            If (TextStruct.Alignment & #TEXTALIGN_LEFT) = #TEXTALIGN_LEFT
               icon_size[0] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_HCENTER) = #TEXTALIGN_HCENTER
               icon_size[0] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_RIGHT) = #TEXTALIGN_RIGHT
               icon_size[0] = -icon_size[0]
            EndIf
         EndIf
         
      ElseIf (TextStruct.Icon.Align & #TEXTALIGN_HCENTER) = #TEXTALIGN_HCENTER
         ; Centro l'icona
         Local xsize = TextStruct.Area.xEnd - xpos - TextStruct.Margins.x
         xpos = xpos + xsize/2 - GetAttribute(#BRUSH, bid, #ATTRWIDTH)/2
         
         If TextStruct.Icon.AdjText
            If (TextStruct.Alignment & #TEXTALIGN_LEFT) = #TEXTALIGN_LEFT
               icon_size[0] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_HCENTER) = #TEXTALIGN_HCENTER
               icon_size[0] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_RIGHT) = #TEXTALIGN_RIGHT
               icon_size[0] = 0
            EndIf
           
         EndIf
      EndIf
      
      If (TextStruct.Icon.Align & #TEXTALIGN_TOP) = #TEXTALIGN_TOP
         ; Lascio così

         If TextStruct.Icon.AdjText
            If (TextStruct.Alignment & #TEXTALIGN_TOP) = #TEXTALIGN_TOP
               ; OK COSI'
            ElseIf (TextStruct.Alignment & #TEXTALIGN_VCENTER) = #TEXTALIGN_VCENTER
               icon_size[1] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_BOTTOM) = #TEXTALIGN_BOTTOM
               ; OK COSI'
            EndIf
         EndIf
         
      ElseIf (TextStruct.Icon.Align & #TEXTALIGN_BOTTOM) = #TEXTALIGN_BOTTOM
         ; Allineo in basso
         ypos = TextStruct.Area.yEnd - TextStruct.Margins.y - GetAttribute(#BRUSH, bid, #ATTRHEIGHT)

         If TextStruct.Icon.AdjText
            If (TextStruct.Alignment & #TEXTALIGN_TOP) = #TEXTALIGN_TOP
               icon_size[1] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_VCENTER) = #TEXTALIGN_VCENTER
               icon_size[1] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_BOTTOM) = #TEXTALIGN_BOTTOM
               icon_size[1] = -icon_size[1]
            EndIf
         EndIf
         
      ElseIf (TextStruct.Icon.Align & #TEXTALIGN_VCENTER) = #TEXTALIGN_VCENTER
         ; Centro l'icona
         Local ysize = TextStruct.Area.yEnd - ypos - TextStruct.Margins.y
         ypos = ypos + ysize/2 - GetAttribute(#BRUSH, bid, #ATTRHEIGHT)/2
         
         If TextStruct.Icon.AdjText
            If (TextStruct.Alignment & #TEXTALIGN_TOP) = #TEXTALIGN_TOP
               icon_size[1] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_VCENTER) = #TEXTALIGN_VCENTER
               icon_size[1] = 0
            ElseIf (TextStruct.Alignment & #TEXTALIGN_BOTTOM) = #TEXTALIGN_BOTTOM
               icon_size[1] = 0
            EndIf
         EndIf
         
      EndIf

      DisplayBrush(bid, xpos, ypos)  
      
   EndIf
   
   
   
   
   ; Setup Font and Size                                                        
   Local TextColor = RGB( TextStruct.Color.r, TextStruct.Color.g, TextStruct.Color.b )
   Local tbl = {}
   ;If (TextStruct.FontName = #SANS) Or (TextStruct.FontName = #SERIF) Or (TextStruct.FontName = #MONOSPACE)
      tbl = { Engine = #FONTENGINE_INBUILT, Chache = True }
   ;EndIf
   SetFont(TextStruct.FontName, TextStruct.FontSize, tbl)
   SetFontStyle(#NORMAL)

   ; Edge Handling                                                              
   Local EdgeFlag3D     = 0
   Local EdgeFlagSimple = 0
   Local EdgeColor      = 0
   Local ShadowColor    = 0

   If TextStruct.Edge.Type = #TEXTEDGE_NONE
      ; Nothing for now                                                         
   ElseIf TextStruct.Edge.Type = #TEXTEDGE_SIMPLE
      EdgeColor = RGB(TextStruct.Edge.Color.r, TextStruct.Edge.Color.g, TextStruct.Edge.Color.b)
      SetFontStyle(#EDGE, ARGB(TextStruct.Edge.Color.a, EdgeColor), TextStruct.Edge.Size)
      EdgeFlagSimple = 1
   ElseIf TextStruct.Edge.Type = #TEXTEDGE_3D
      EdgeFlag3D = 1
   Else
      scui.Error("SCUI ERROR",
                 "You have tried to draw a TextStruct with an undefined TextEdge type.\n"..
                 "Not supperted TextEdge is '" .. TextStruct.Edge.Type .. "'\n\n" ..
                 "What do you want to do?")
                 Return
   EndIf

   ; Shadow Handling                                                            
   If TextStruct.Shadow.Type = #TEXTSHADOW_NONE
      ; Nothing for now                                                         
   Else
      ShadowColor = RGB(TextStruct.Shadow.Color.r, TextStruct.Shadow.Color.g, TextStruct.Shadow.Color.b)
      SetFontStyle(#SHADOW, ARGB(TextStruct.Shadow.Color.a, ShadowColor), TextStruct.Shadow.Distance, TextStruct.Shadow.Type)
   EndIf

   ; Style Handling                                                             
   If TextStruct.Style <> #TEXTSTYLE_NORMAL Then SetFontStyle(TextStruct.Style)
 
   ; Vertical Centering                                                         
   Local LineHeight  = TextHeight(TextStruct.Content.Values[0]) + TextStruct.Content.VerticalOffset
   Local YPosition   = -99999
   Local Text_Height = LineHeight * TextStruct.Content.Lines
   Local YArea       = (TextStruct.Area.yEnd - TextStruct.Area.yStart) - TextStruct.Margins.y * 2 
   If (TextStruct.Alignment & #TEXTALIGN_VCENTER) = #TEXTALIGN_VCENTER
      ; Vertically centered                                                     
      YPosition   = (( YArea - Text_Height - ios_pos_y ) / 2 ) + TextStruct.Area.yStart + TextStruct.Margins.y + TextStruct.Content.VerticalOffset / 2
   ElseIf (TextStruct.Alignment & #TEXTALIGN_TOP) = #TEXTALIGN_TOP
      ; Top aligned                                                             
      YPosition = TextStruct.Area.yStart + TextStruct.Margins.y
   ElseIf (TextStruct.Alignment & #TEXTALIGN_BOTTOM) = #TEXTALIGN_BOTTOM
      ; Bottom aligned                                                          
      YPosition = YArea - Text_Height + TextStruct.Area.yStart + TextStruct.Margins.y
   EndIf

   ; Y Centering by Default for the <MultiCol> rendering                        
   Local MultiCol = False
   If helpers.FieldIsNil(TextStruct, "multicol") = 0
      If TextStruct.MultiCol = True 
         YPosition   = -99999
         Text_Height = LineHeight
         MultiCol = True
      EndIf
   EndIf

   ; Calculate the vertical centering                                           
   If YPosition = -99999 Then YPosition = (( YArea - Text_Height ) / 2 ) + TextStruct.Area.yStart + TextStruct.Margins.y + TextStruct.Content.VerticalOffset / 2
   YPosition = YPosition + icon_size[1]
   
   ; Horizontal Centering + Horizontal Alignment + Rendering                    
   Local SubArea = helpers.CloneTable(TextStruct.Area)
   Local XArea   = ( TextStruct.Area.xEnd - TextStruct.Area.xStart )

   For l = 0 to TextStruct.Content.Lines - 1
      Local tline = TextStruct.Content.Values[l]
      Local HWidth = 0
      
      If MultiCol
         ; MultiCol Mode                                    
         Local LineWidth = TextWidth(TextStruct.Content.Values[l])
         HWidth = Int(XArea * TextStruct.ColSizes[l] / 100)

         If l < 1
            SubArea.xEnd = SubArea.xStart + HWidth
         Else
            SubArea.xStart = SubArea.xEnd
            SubArea.xEnd = SubArea.xStart + HWidth
         EndIf
            
         Local XPosition = -99999
         If (TextStruct.Alignment & #TEXTALIGN_HCENTER) = #TEXTALIGN_HCENTER
            XPosition = (( HWidth - LineWidth ) / 2 ) + SubArea.xStart + TextStruct.Margins.x
         ElseIf (TextStruct.Alignment & #TEXTALIGN_LEFT) = #TEXTALIGN_LEFT
            XPosition = SubArea.xStart + TextStruct.Margins.x
         ElseIf (TextStruct.Alignment & #TEXTALIGN_RIGHT) = #TEXTALIGN_RIGHT
            XPosition = HWidth - LineWidth + SubArea.xStart
         EndIf
            
         ; X Centering by default                                               
         If XPosition = -99999 Then XPosition = (( XArea - LineWidth ) / 2 ) + SubArea.xStart + TextStruct.Margins.x
            
         If EdgeFlag3D = 1
            Local offset    = 1
            Local DarkCol   = helpers.DarkColorRGB(TextStruct.Edge.Color.r, TextStruct.Edge.Color.g, TextStruct.Edge.Color.b, TextStruct.Edge.Color.Contrast)
            Local BrightCol = helpers.BrightColorRGB(TextStruct.Edge.Color.r, TextStruct.Edge.Color.g, TextStruct.Edge.Color.b, TextStruct.Edge.Color.Contrast)
            If TextStruct.Edge.Style = #TEXT3D_RECESSED
               Local Dummy = BrightCol
               BrightCol   = DarkCol
               DarkCol     = Dummy
            EndIf
                
            ; Draw the 3d fx
            For Local e = 1 to TextStruct.Edge.Size
               SetFontColor(ARGB(TextStruct.Edge.Color.a, BrightCol))
               
               TextOut(XPosition - offset, YPosition , tline)
               TextOut(XPosition - offset, YPosition - offset, tline)
               TextOut(XPosition, YPosition - offset, tline)
               TextOut(XPosition - offset, YPosition + offset, tline)
               TextOut(XPosition + offset, YPosition - offset, tline)
               SetFontColor(ARGB(TextStruct.Edge.Color.a, DarkCol))
               TextOut(XPosition + offset, YPosition , tline)
               TextOut(XPosition + offset, YPosition + offset, tline)
               TextOut(XPosition, YPosition + offset, tline)
               Offset = Offset + 1
            Next
         EndIf
            
         ; Text Rendering                                                       
         SetFontColor(TextColor)
         If ClipMode <> #NOCLIP
            SetClipRegion(#NONE)
            FreeClipRegion(#EDITTEXT_CLIPID)
              
            If l > 0
If HWidth > 0
               If TextStruct.ColBreak.DrawLines
                  Local Col1 = helpers.BrightColorRGB(TextStruct.ColBreak.Color.r, TextStruct.ColBreak.Color.g, TextStruct.ColBreak.Color.b, TextStruct.ColBreak.Color.Contrast)
                  Local Col2 = helpers.DarkColorRGB(TextStruct.ColBreak.Color.r, TextStruct.ColBreak.Color.g, TextStruct.ColBreak.Color.b, TextStruct.ColBreak.Color.Contrast)                        
                  Line(SubArea.xStart, SubArea.yStart, SubArea.xStart, SubArea.yEnd, Col1)
                  Line(SubArea.xStart-1, SubArea.yStart, SubArea.xStart-1, SubArea.yEnd, Col2)
               EndIf
EndIf
            EndIf

            scui.SafeClipRegion(#EDITTEXT_CLIPID, #BOX,SubArea.xStart, SubArea.yStart, HWidth, SubArea.yEnd - SubArea.yStart)
            SetClipRegion(#EDITTEXT_CLIPID)            
         EndIf
         TextOut(XPosition, YPosition, tline)

      Else
         ; Non MultiCol Mode                                                    
         Local LineWidth = TextWidth(TextStruct.Content.Values[l])
         Local XArea     = (TextStruct.Area.xEnd - TextStruct.Area.xStart) - TextStruct.Margins.x*2
           
         Local XPosition = -99999
         If (TextStruct.Alignment & #TEXTALIGN_HCENTER) = #TEXTALIGN_HCENTER
            XPosition = (( XArea - LineWidth ) / 2 ) + TextStruct.Area.xStart + TextStruct.Margins.x
         ElseIf (TextStruct.Alignment & #TEXTALIGN_LEFT) = #TEXTALIGN_LEFT
            XPosition = TextStruct.Area.xStart + TextStruct.Margins.x
         ElseIf (TextStruct.Alignment & #TEXTALIGN_RIGHT) = #TEXTALIGN_RIGHT
            XPosition = XArea - LineWidth + TextStruct.Area.xStart + TextStruct.Margins.x
         EndIf
            
         ; X Center by default                                                  
         If XPosition = -99999
            XPosition = (( XArea - LineWidth ) / 2 ) + TextStruct.Area.xStart + TextStruct.Margins.x
         EndIf
         
         XPosition = XPosition + icon_size[0]
         
         ; Correzione per icona
         /* If ios_pos_x <> 0
            XPosition = XPosition + ios_pos_x + TextStruct.Margins.x
         EndIf
         If ios_pos_y <> 0
            YPosition = YPosition + TextStruct.Margins.x
         EndIf */
            
         If EdgeFlag3D = 1
            Local offset = 1
            Local DarkCol   = helpers.DarkColorRGB(TextStruct.Edge.Color.r, TextStruct.Edge.Color.g, TextStruct.Edge.Color.b, TextStruct.Edge.Color.Contrast)
            Local BrightCol = helpers.BrightColorRGB(TextStruct.Edge.Color.r, TextStruct.Edge.Color.g, TextStruct.Edge.Color.b, TextStruct.Edge.Color.Contrast)
            If TextStruct.Edge.Style = #TEXT3D_RECESSED
               Local Dummy = BrightCol
               BrightCol   = DarkCol
               DarkCol     = Dummy
            EndIf
                
            ; Draw the 3d fx
            For Local e = 1 to TextStruct.Edge.Size
               SetFontColor(ARGB(TextStruct.Edge.Color.a, BrightCol))
               TextOut(XPosition - offset, YPosition , tline)
               TextOut(XPosition - offset, YPosition - offset, tline)
               TextOut(XPosition, YPosition - offset, tline)
               TextOut(XPosition - offset, YPosition + offset, tline)
               TextOut(XPosition + offset, YPosition - offset, tline)
               SetFontColor(ARGB(TextStruct.Edge.Color.a, DarkCol))
               TextOut(XPosition + offset, YPosition , tline)
               TextOut(XPosition + offset, YPosition + offset, tline)
               TextOut(XPosition, YPosition + offset, tline)
               Offset = Offset + 1
            Next
         EndIf
            
         ; Text Rendering     
         SetFontColor(TextColor)
         TextOut(XPosition, YPosition, tline)
         YPosition = YPosition + LineHeight - YShadowAdjusting
      EndIf
   Next
    
   ; Free the clip region                                                       
   If ClipMode <> #NOCLIP
      SetClipRegion(#NONE)
      FreeClipRegion(#EDITTEXT_CLIPID)
   EndIf
EndFunction
Function scui.DrawPattern(BrushID, Position, Size, DestBrush, BGColor)

   Local clipid
   Local holdpos = {}
   If helpers.IsNil(DestBrush)
      Clipid = CreateClipRegion(Nil, #BOX, Position.x, Position.y, Size.x, Size.y)
      SetClipRegion(clipid)
   Else
      holdpos = helpers.CloneTable(Position)
      Position.x = 0
      Position.y = 0
   EndIf
   
   Local BrushSize = {}
   BrushSize.x = GetAttribute(#BRUSH, BrushID, #ATTRWIDTH)
   BrushSize.y = GetAttribute(#BRUSH, BrushID, #ATTRHEIGHT)
   
   Local HSteps = Int(Size.x / BrushSize.x) + 1
   Local VSteps = Int(Size.y / BrushSize.y) + 1
   
   Local destid
   If Not(helpers.IsNil(DestBrush))
      destid = CreateBrush(Nil, Size.x, Size.y, BGColor)
      SelectBrush(destid)

   EndIf
   
   For r = 1 To VSteps
      For c = 1 To HSteps
         DisplayBrush(BrushID, Position.x + (c-1)*BrushSize.x, Position.y + (r-1)*BrushSize.y)
      Next
   Next

   If helpers.IsNil(DestBrush)
      FreeClipRegion(clipid)
   Else
      EndSelect
      DisplayBrush( destid, holdpos.x, holdpos.y)
      Position.x = holdpos.x
      Position.y = holdpos.y
      FreeBrush(destid)
   EndIf

EndFunction
Function scui.DrawBevel(BevelStruct) ;----------------------------| PRIVATE |---
   ; Added: v0.5   Docs : 26.12.2008
	; | Draw to the screen the given <BevelStruct>                              |

   If helpers.IsNil(BevelStruct) Then Return

   ; Get the fill colors                                                        
   Local FillColor1 = RGB(BevelStruct.Colors.Fill1.r, BevelStruct.Colors.Fill1.g, BevelStruct.Colors.Fill1.b)
   Local FillColor2 = RGB(BevelStruct.Colors.Fill2.r, BevelStruct.Colors.Fill2.g, BevelStruct.Colors.Fill2.b)
   Local FillColor3 = helpers.DarkColorRGB(BevelStruct.Colors.Fill2.r, BevelStruct.Colors.Fill2.g, BevelStruct.Colors.Fill2.b, scui.theme.MetalDelta)

   ; Select the fill mode
   ; ************************************************************************
   ; * ADD FEATURE: #BEVELFILL_TEXTURE, #BEVELFILL_IMAGE                    *
   ; ************************************************************************
   
If Not(helpers.FieldIsNil(BevelStruct, "picture"))
   BevelStruct.FillMode = #BEVELFILL_NONE
   BevelStruct.Height   = 0
EndIf

   Switch BevelStruct.FillMode
      Case #BEVELFILL_NONE
         SetFillStyle(#FILLNONE)

      Case #BEVELFILL_SOLID
         SetFillStyle(#FILLCOLOR)

      Case #BEVELFILL_GRADIENT
         SetFillStyle(#FILLGRADIENT, #LINEAR, FillColor1, FillColor2, BevelStruct.GradientAngle)

      Case #BEVELFILL_METAL
         SetFillStyle(#FILLGRADIENT, #LINEAR, FillColor1, FillColor2, BevelStruct.GradientAngle)

      Default:
         SetFillStyle(#FILLNONE)
         scui.Error("SCUI ERROR",
                    "You have tried to draw a BevelStruct with an undefined Fill Mode.\n"..
                    "Not supperted Fill Mode is '" .. TextStruct.Alignment .. "'\n\n" ..
                    "What do you want to do?")
                    Return
   EndSwitch

   ; Draw the background                                                        
   If BevelStruct.FillMode <> #BEVELFILL_NONE
      If BevelStruct.FillMode = #BEVELFILL_METAL
         Local Half1Y = (BevelStruct.Size.y + 1) / 2
         Local Half2Y = BevelStruct.Size.y + 1 - Half1Y
         Box(BevelStruct.Position.x, BevelStruct.Position.y,
             BevelStruct.Size.x + 1, Half1Y,
             FillColor1)
         SetFillStyle(#FILLGRADIENT, #LINEAR, FillColor3, FillColor2, BevelStruct.GradientAngle)
         Box(BevelStruct.Position.x, BevelStruct.Position.y + Half1Y - 1, 
             BevelStruct.Size.x + 1, Half2Y + 1, 
             FillColor2)
      Else
         Box(BevelStruct.Position.x, BevelStruct.Position.y,
             BevelStruct.Size.x + 1, BevelStruct.Size.y + 1,
             FillColor1)
      EndIf
   Else
      ; Verifica se deve tracciare una immagine
      If Not(helpers.FieldIsNil(BevelStruct, "picture"))
      
         Switch BevelStruct.Picture.Mode
            Case 1 ; PATTERN
               scui.DrawPattern(scui.Picture.GetBrushID(BevelStruct.Picture.Name), 
                                BevelStruct.Position,
                                BevelStruct.Size, Nil )

            Case 2 ; IMAGE
               ; Scala l'immagine
               Local source = scui.Picture.GetBrushID(BevelStruct.Picture.Name)
               Local dest   = CopyBrush(source, Nil)
               ScaleBrush(dest, BevelStruct.Size.x + 1, BevelStruct.Size.y + 1, True)
               DisplayBrush(dest, BevelStruct.Position.x, BevelStruct.Position.y)
               FreeBrush(dest)
               
            Case 3 ; SKIN
               Local BS = BevelStruct
               Local Source = scui.Picture.GetBrushID(BS.Picture.Name)
               Local Width  = GetAttribute(#BRUSH, Source, #ATTRWIDTH)
               Local Height = GetAttribute(#BRUSH, Source, #ATTRHEIGHT)
               Local xPiece = Width  / 3
               Local yPiece = Height / 3

               ; Skin Mode
               ; ANGOLI
               ; - Top/Left
               DisplayBrushPart(Source, 0, 0, BS.Position.x, BS.Position.y, xPiece, yPiece)
               ; - Bottom/Left
               DisplayBrushPart(Source, 0, yPiece * 2, BS.Position.x, BS.Position.y + BS.Size.y - yPiece, xPiece, yPiece)
               ; - Top/Right
               DisplayBrushPart(Source, xPiece * 2, 0, BS.Position.x + BS.Size.x - xPiece, BS.Position.y, xPiece, yPiece)
               ; - Bottom/Right
               DisplayBrushPart(Source, xPiece * 2, yPiece * 2, BS.Position.x + BS.Size.x - xPiece, BS.Position.y + BS.Size.y - yPiece, xPiece, yPiece)
               
               ; RIEMPIMENTI
               ; Top Area
               Local cr = CreateClipRegion(Nil, #BOX, BS.Position.x + xPiece,
                                                      BS.Position.y,
                                                      BS.Size.x - xPiece * 2,
                                                      yPiece)
               SetClipRegion(cr)

               Local H_IT = (BS.Size.x / xPiece) - 1
               For Local i = 1 To H_IT
                  DisplayBrushPart(Source, xPiece, 0,
                                           BS.Position.x + i * xPiece,
                                           BS.Position.y,
                                           xPiece, yPiece)
               Next
               FreeClipRegion(cr)
               
               ; Bottom Area
               Local cr = CreateClipRegion(Nil, #BOX, BS.Position.x + xPiece,
                                                      BS.Position.y + BS.Size.y - yPiece,
                                                      BS.Size.x - xPiece * 2,
                                                      yPiece)
               SetClipRegion(cr)

               Local H_IT = (BS.Size.x / xPiece) - 1
               For Local i = 1 To H_IT
                  DisplayBrushPart(Source, xPiece, yPiece * 2,
                                           BS.Position.x + i * xPiece,
                                           BS.Position.y + BS.Size.y - yPiece,
                                           xPiece, yPiece)
               Next
               FreeClipRegion(cr)

               ; Mid Area
               Local cr = CreateClipRegion(Nil, #BOX, BS.Position.x + xPiece,
                                                      BS.Position.y + yPiece,
                                                      BS.Size.x - xPiece * 2,
                                                      BS.Size.y - yPiece * 2)
               SetClipRegion(cr)

               Local H_IT = (BS.Size.x / xPiece) - 1
               Local V_IT = (BS.Size.y / yPiece) - 1
               For Local k = 1 To V_IT
                  For Local i = 1 To H_IT
                     DisplayBrushPart(Source, xPiece, yPiece,
                                              BS.Position.x + i * xPiece,
                                              BS.Position.y + k * yPiece,
                                              xPiece, yPiece)
                  Next
               Next
               FreeClipRegion(cr)

               ; Left Area
               Local cr = CreateClipRegion(Nil, #BOX, BS.Position.x,
                                                      BS.Position.y + yPiece,
                                                      xPiece,
                                                      BS.Size.y - yPiece * 2)
               SetClipRegion(cr)

               Local V_IT = (BS.Size.y / yPiece) - 1
               For Local i = 1 To V_IT
                  DisplayBrushPart(Source, 0, yPiece,
                                           BS.Position.x,
                                           BS.Position.y + i * yPiece,
                                           xPiece, yPiece)
               Next
               FreeClipRegion(cr)

               ; Right Area
               Local cr = CreateClipRegion(Nil, #BOX, BS.Position.x + BS.Size.x - xPiece,
                                                      BS.Position.y + yPiece,
                                                      xPiece,
                                                      BS.Size.y - yPiece * 2)
               SetClipRegion(cr)

               Local V_IT = (BS.Size.y / yPiece) - 1
               For Local i = 1 To V_IT
                  DisplayBrushPart(Source, xPiece * 2, yPiece,
                                           BS.Position.x + BS.Size.x - xPiece,
                                           BS.Position.y + i * yPiece,
                                           xPiece, yPiece)
               Next
               FreeClipRegion(cr)


               /*
               Local region = CreateClipRegion(Nil, #BOX, BevelStruct.Position.x, BevelStruct.position.y,
                                                          BevelStruct.Size.x + 1, BevelStruct.Size.y + 1)
               SetClipRegion(region)
               
               Local xStart = BevelStruct.Position.x
               Local yStart = BevelStruct.Position.y
               Local source = scui.Picture.GetBrushID(BevelStruct.Picture.Name)
               Local Width  = GetAttribute(#BRUSH, source, #ATTRWIDTH)
               Local Height = GetAttribute(#BRUSH, source, #ATTRHEIGHT)
               Local xPiece = Width  / 3
               Local yPiece = Height / 3

               Local H_It = BevelStruct.Size.x / xPiece - 1
               
               ; BORDO SUPERIORE
               ; Top Left
               DisplayBrushPart(source, 0, 0, BevelStruct.Position.x, BevelStruct.Position.y, xPiece, yPiece)
               ; Top Right
               DisplayBrushPart(source, Width - xPiece, 0, BevelStruct.Position.x + BevelStruct.Size.x - xPiece + 1, BevelStruct.Position.y, xPiece, yPiece)


               ; Top Mid
               Local TopRegion = CreateClipRegion(Nil, #BOX, BevelStruct.Position.x + xPiece,
                                                             BevelStruct.position.y,
                                                             BevelStruct.Size.x - xPiece * 2,
                                                             yPiece)
               SetClipRegion(TopRegion)
               For Local i = 1 To H_It
                  DisplayBrushPart(source, xPiece, 0, BevelStruct.Position.x + xPiece * i, BevelStruct.Position.y, xPiece, yPiece)
               Next
               FreeClipRegion(TopRegion)

               Local V_It = BevelStruct.Size.y / yPiece
               For Local i = 1 To V_It
                  ; MidLeft
                  DisplayBrushPart(source, 0, yPiece, BevelStruct.Position.x, BevelStruct.Position.x + yPiece * i, xPiece, yPiece)
                  ; MidRight
                  DisplayBrushPart(source, Width - xPiece, yPiece, BevelStruct.Position.x + BevelStruct.Size.x - xPiece + 1, BevelStruct.Position.y + yPiece * i, xPiece, yPiece)
               Next

               Local xRegion = CreateClipRegion(Nil, #BOX, BevelStruct.Position.x + xPiece,
                                                             BevelStruct.position.y,
                                                             BevelStruct.Size.x - xPiece * 2,
                                                             BevelStruct.Size.y - xPiece)
               SetClipRegion(xRegion)

               For Local i = 1 To V_It
                  ; MidMid
                  For Local ii = 1 To H_It
                     DisplayBrushPart(source, xPiece, yPiece, BevelStruct.Position.x + xPiece * ii, BevelStruct.Position.y + yPiece * i, xPiece, yPiece)
                  Next
               Next
               FreeClipRegion(xRegion)
               
               ; Bottom Left
               DisplayBrushPart(source, 0, yPiece*2, BevelStruct.Position.x, BevelStruct.Position.y + BevelStruct.Size.y - yPiece + 1, xPiece, yPiece)
               ; Bottom Right
               DisplayBrushPart(source, Width - xPiece, Height - yPiece, BevelStruct.Position.x + BevelStruct.Size.x - xPiece + 1, BevelStruct.Position.y + BevelStruct.Size.y - yPiece + 1, xPiece, yPiece)
               
               ; Bottom Mid
               Local BottomRegion = CreateClipRegion(Nil, #BOX, BevelStruct.Position.x + xPiece,
                                                             BevelStruct.position.y + BevelStruct.Size.y - yPiece + 1,
                                                             BevelStruct.Size.x - xPiece * 2,
                                                             yPiece)
               SetClipRegion(BottomRegion)

               For Local i = 1 To H_It
                  DisplayBrushPart(source, xPiece, yPiece*2, BevelStruct.Position.x + xPiece * i, BevelStruct.Position.y + BevelStruct.Size.y - yPiece + 1, xPiece, yPiece)
               Next
               FreeClipRegion(BottomRegion)
               FreeClipRegion(region)
               
               */
         EndSwitch
      EndIf
   EndIf

   ; Draw the surrounding Bevel box                                             
   Local BrightCol = helpers.BrightColorRGB(BevelStruct.Colors.Edges.r, BevelStruct.Colors.Edges.g, BevelStruct.Colors.Edges.b, BevelStruct.Colors.Edges.Contrast)
   Local DarkCol   = helpers.DarkColorRGB(BevelStruct.Colors.Edges.r, BevelStruct.Colors.Edges.g, BevelStruct.Colors.Edges.b, BevelStruct.Colors.Edges.Contrast)
   Local NormalColor = RGB(BevelStruct.Colors.Edges.r, BevelStruct.Colors.Edges.g, BevelStruct.Colors.Edges.b)
   Local Smooth    = BevelStruct.Smooth
   Local SmoothMul = 1

   Switch BevelStruct.Aspect
      Case #BEVELASPECT_RAISED
         ; Nothing here                                                         
      Case #BEVELASPECT_RECESSED
         ; Swap colors                                                          
         Local Dummy = BrightCol
         BrightCol   = DarkCol
         DarkCol     = Dummy
         SmoothMul   = -1

      Default:
         scui.Error("SCUI ERROR",
                    "You have tried to draw a BevelStruct with an undefined Bevel Aspect.\n"..
                    "Not supperted Bevel Aspect is '" .. TextStruct.Alignment .. "'\n\n" ..
                    "What do you want to do?")
                    Return
   EndSwitch

   ; Get the coordinates and dimensions                                         
   Local sx = BevelStruct.Position.x
   Local sy = BevelStruct.Position.y
   Local ex = BevelStruct.Position.x + BevelStruct.Size.x
   Local ey = BevelStruct.Position.y + BevelStruct.Size.y
   Local os = 0
   ; Center                                                                     
   Local center = { sx + BevelStruct.Size.x/2, sy + BevelStruct.Size.y/2 }
   Local scale = Min(BevelStruct.Size.x, BevelStruct.Size.y)

   ; Draw the box                                                               
   Switch BevelStruct.Type
      Case #BEVELTYPE_NONE
         ; nothing to draw                                                      
      Case #BEVELTYPE_FLAT
         SetFillStyle(#FILLNONE)
         For t = 1 to bevelStruct.Height    
            Box(sx + os, sy + os, ex - sx - os*2 + 1, ey - sy - os*2 + 2, NormalColor)
            os = os + 1
         Next
      Case #BEVELTYPE_SIMPLE
         Local BC = BrightCol
         Local DC = DarkCol
         If Smooth <> 0
            If SmoothMul = 1
               Local tBC = helpers.DarkColor({r = Red(BC), g = Green(BC), b = Blue(BC)}, Smooth * BevelStruct.Height)
               BC = RGB(tBC.r, tBC.g, tBC.b)
            Else
               Local tBC = helpers.BrightColor({r = Red(BC), g = Green(BC), b = Blue(BC)}, Smooth * BevelStruct.Height)
               BC = RGB(tBC.r, tBC.g, tBC.b)
            EndIf
         EndIf
         For t = 1 to BevelStruct.Height
            Line(sx + os, sy + os, ex - os, sy + os, BC, 1)    ; Top            
            Line(sx + os, sy + os, sx + os, ey - os, BC, 1)    ; Left           
            Line(sx + os, ey - os, ex - os, ey - os, DC, 1)    ; Bottom         
            Line(ex - os, sy + os, ex - os, ey - os, DC, 1)    ; Right          
            os = os + 1
            If Smooth <> 0
               If SmoothMul = 1
                  Local t = helpers.BrightColor({ r = Red(BC), g = Green(BC), b = Blue(BC) }, Smooth)
                  BC = RGB(t.r, t.g, t.b)
                  Local t = helpers.BrightColor({ r = Red(DC), g = Green(DC), b = Blue(DC) }, Smooth)
                  DC = RGB(t.r, t.g, t.b)
               Else
                  Local t = helpers.DarkColor({ r = Red(BC), g = Green(BC), b = Blue(BC) }, Smooth)
                  BC = RGB(t.r, t.g, t.b)
                  Local t = helpers.DarkColor({ r = Red(DC), g = Green(DC), b = Blue(DC) }, Smooth)
                  DC = RGB(t.r, t.g, t.b)
               EndIf
            EndIf   
         Next
      Case #BEVELTYPE_SUNKEN
         Local BC = BrightCol
         Local DC = DarkCol
         If Smooth <> 0
            If SmoothMul = 1
               Local tBC = helpers.DarkColor({r = Red(BC), g = Green(BC), b = Blue(BC)}, Smooth * BevelStruct.Height)
               BC = RGB(tBC.r, tBC.g, tBC.b)
            Else
               Local tBC = helpers.BrightColor({r = Red(BC), g = Green(BC), b = Blue(BC)}, Smooth * BevelStruct.Height)
               BC = RGB(tBC.r, tBC.g, tBC.b)
            EndIf
         EndIf
         For t = 1 to BevelStruct.Height   
            Line(sx + os, sy + os, ex - os, sy + os, BC, 1)    ; Top            
            Line(sx + os, sy + os, sx + os, ey - os, BC, 1)    ; Left           
            Line(sx + os, ey - os, ex - os, ey - os, DC, 1)    ; Bottom         
            Line(ex - os, sy + os, ex - os, ey - os, DC, 1)    ; Right          
            os = os + 1
            If Smooth <> 0
               If SmoothMul = 1
                  Local t = helpers.BrightColor({ r = Red(BC), g = Green(BC), b = Blue(BC) }, Smooth)
                  BC = RGB(t.r, t.g, t.b)
                  Local t = helpers.BrightColor({ r = Red(DC), g = Green(DC), b = Blue(DC) }, Smooth)
                  DC = RGB(t.r, t.g, t.b)
               Else
                  Local t = helpers.DarkColor({ r = Red(BC), g = Green(BC), b = Blue(BC) }, Smooth)
                  BC = RGB(t.r, t.g, t.b)
                  Local t = helpers.DarkColor({ r = Red(DC), g = Green(DC), b = Blue(DC) }, Smooth)
                  DC = RGB(t.r, t.g, t.b)
               EndIf
            EndIf   
         Next
        
         Local BC = BrightCol
         Local DC = DarkCol    
         If Smooth <> 0
            If SmoothMul = 1
               Local tDC = helpers.BrightColor({r = Red(DC), g = Green(DC), b = Blue(DC)}, Smooth * BevelStruct.Height)
               DC = RGB(tDC.r, tDC.g, tDC.b)
            Else
               Local tDC = helpers.DarkColor({r = Red(DC), g = Green(DC), b = Blue(DC)}, Smooth * BevelStruct.Height)
               DC = RGB(tDC.r, tDC.g, tDC.b)
            EndIf
         EndIf
         For t = 1 to BevelStruct.Height   
            Line(sx + os, sy + os, ex - os, sy + os, DC, 1)    ; Top            
            Line(sx + os, sy + os, sx + os, ey - os, DC, 1)    ; Left           
            Line(sx + os, ey - os, ex - os, ey - os, BC, 1)    ; Bottom         
            Line(ex - os, sy + os, ex - os, ey - os, BC, 1)    ; Right          
            os = os + 1
            If Smooth <> 0
               If SmoothMul = 1
                  Local t = helpers.DarkColor({ r = Red(BC), g = Green(BC), b = Blue(BC) }, Smooth)
                  BC = RGB(t.r, t.g, t.b)
                  Local t = helpers.DarkColor({ r = Red(DC), g = Green(DC), b = Blue(DC) }, Smooth)
                  DC = RGB(t.r, t.g, t.b)
               Else
                  Local t = helpers.BrightColor({ r = Red(BC), g = Green(BC), b = Blue(BC) }, Smooth)
                  BC = RGB(t.r, t.g, t.b)
                  Local t = helpers.BrightColor({ r = Red(DC), g = Green(DC), b = Blue(DC) }, Smooth)
                  DC = RGB(t.r, t.g, t.b)
               EndIf
            EndIf   
         Next
         Default:
            scui.Error("SCUI ERROR",
                       "You have tried to draw a BevelStruct with an undefined Bevel Type.\n"..
                       "Not supperted Bevel Type is '" .. TextStruct.Alignment .. "'\n\n" ..
                       "What do you want to do?")
                       Return
   EndSwitch

   ; Draw the Bevel Outline                                                     
   ; Get the position and dimensions                                            
   sx = BevelStruct.Position.x
   sy = BevelStruct.Position.y
   ex = BevelStruct.Position.x + BevelStruct.Size.x
   ey = BevelStruct.Position.y + BevelStruct.Size.y
   os = 1

   BrightCol   = helpers.BrightColorRGB(BevelStruct.Colors.Outline.r, BevelStruct.Colors.Outline.g, BevelStruct.Colors.Outline.b, BevelStruct.Colors.Outline.Contrast)
   DarkCol     = helpers.DarkColorRGB(BevelStruct.Colors.Outline.r, BevelStruct.Colors.Outline.g, BevelStruct.Colors.Outline.b, BevelStruct.Colors.Outline.Contrast)
   NormalColor = RGB(BevelStruct.Colors.Outline.r, BevelStruct.Colors.Outline.g, BevelStruct.Colors.Outline.b)

   Switch BevelStruct.Outline.Aspect
      Case #BEVELASPECT_RAISED
         ; --- nothing here                                                     
      Case #BEVELASPECT_RECESSED
         ; --- Swap colors                                                      
         Dummy     = BrightCol
         BrightCol = DarkCol
         DarkCol   = Dummy

      Default:
         scui.Error("SCUI ERROR",
                    "You have tried to draw a BevelStruct with an undefined Outline Aspect.\n"..
                    "Not supperted Outline Aspect is '" .. TextStruct.Alignment .. "'\n\n" ..
                    "What do you want to do?")
                    Return
   EndSwitch

   Switch BevelStruct.Outline.Type
      Case #BEVELTYPE_NONE
         ; --- Nothing to draw                                                  
      Case #BEVELTYPE_FLAT
         SetFillStyle(#FILLNONE)
         For t = 1 to bevelStruct.Outline.Size1    
            Box(sx - os, sy - os, ex - sx + os*2 +1, ey - sy + os*2+1, NormalColor)
            os = os + 1
         Next
      Case #BEVELTYPE_SIMPLE
         For t = 1 to BevelStruct.Outline.Size1   
            Line(sx - os, sy - os, ex + os, sy - os, BrightCol, 1)  ; Top       
            Line(sx - os, sy - os, sx - os, ey + os, BrightCol, 1)  ; Left      
            Line(sx - os, ey + os, ex + os, ey + os, DarkCol, 1)    ; Bottom    
            Line(ex + os, sy - os, ex + os, ey + os, DarkCol, 1)    ; Right     
            os = os + 1
         Next
      Case #BEVELTYPE_SUNKEN
         For t = 1 to BevelStruct.Outline.Size2   
            Line(sx - os, sy - os, ex + os, sy - os, BrightCol, 1)  ; Top       
            Line(sx - os, sy - os, sx - os, ey + os, BrightCol, 1)  ; Left      
            Line(sx - os, ey + os, ex + os, ey + os, DarkCol, 1)    ; Bottom    
            Line(ex + os, sy - os, ex + os, ey + os, DarkCol, 1)    ; Right     
            os = os + 1
         Next
         For t = 1 to BevelStruct.Outline.Size1   
            Line(sx - os, sy - os, ex + os, sy - os, DarkCol, 1)    ; Top       
            Line(sx - os, sy - os, sx - os, ey + os, DarkCol, 1)    ; Left      
            Line(sx - os, ey + os, ex + os, ey + os, BrightCol, 1)  ; Bottom    
            Line(ex + os, sy - os, ex + os, ey + os, BrightCol, 1)  ; Right     
            os = os + 1
         Next

      Default:
         scui.Error("SCUI ERROR",
                    "You have tried to draw a BevelStruct with an undefined Outline Type.\n"..
                    "Not supperted Outline Type is '" .. TextStruct.Alignment .. "'\n\n" ..
                    "What do you want to do?")
                    Return
   ; ************************************************************************
   ; * FEATURE ADD: Vector / Icon                                           *
   ; ************************************************************************
   EndSwitch

   ; Vectors handling                                                           
   If helpers.FieldIsNil(BevelStruct, "vector") = 0
      Vectorz.Render(BevelStruct.Vector, center, scale)
   EndIf
EndFunction
Function scui.HandleCycle(msg) ;----------------------------------| PRIVATE |---
   ; Identifica quale elemento è stato selezionato
   Local Cycle = scui.Get(scui.IFO[msg.id].CycleName)
   Local work  = SplitStr(scui.IFO[msg.id].oName, "*")
   Local ItemID= Val(UnrightStr(work[1], 5))
   Local Item  = Cycle.Options[ItemID]
   
   ; Aggiorna il cycle & Genera l'evento
   scui.Set(scui.IFO[msg.id].CycleName, { Value = ItemID + 1 }, 1)
   
   Local cyclegad = scui.GetIFOID(scui.IFO[msg.id].CycleName)
   If Not(helpers.FieldIsNil(scui.IFO[cyclegad].Actions, "onchanged")) Then scui.IFO[cyclegad].Actions.OnChanged()
      
EndFunction
Function scui.RedrawObjects( DblBuffer, Owner ) ;-------------------------------
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | Redraw the active Owner's gadgets or all defined gadgets if owner is nil 

   ; Check if we must use DoubleBuffer commands                                 
   Local dbb = IIf(helpers.IsNil(DblBuffer) = 0, 1, 0)
   If dbb = 1 Then BeginDoubleBuffer()

   Local id = 0
   If helpers.IsNil(Owner) = 1
      ; OWNER is NIL: draw all objects                                          
      For id = 1 to scui.IFO.IDCounter
         ; Check if the Object exists (Really need it? Maybe I've to check the )
         ; <deleted> flag? CHECK REMOVEOBJECT() ********************************
         ; === USARE LA FUNZIONE APPOSITA: scui.ObjectExists()               ===
         If helpers.IsNil(scui.IFO[id])=0
            ; Childs objects will not be drawn directly                         
            If helpers.FieldIsNil(scui.IFO[id], "parent") = 1
               scui.RenderObject(id)
            Else
               ; This is a child, skip drawing (Their parents will redraw them) 
            EndIf
         EndIf
      Next
   Else
      ; OWNER is not NIL: draw Owner's objects                                  
      For id = 1 to scui.IFO.IDCounter
         ; Check if the Object exists (Really need it? Maybe I've to check the )
         ; <deleted> flag? CHECK REMOVEOBJECT() ********************************
         ; === USARE LA FUNZIONE APPOSITA: scui.ObjectExists()               ===
         If helpers.IsNil(scui.IFO[id])=0
            If scui.IFO[id].Owner = Owner
               If helpers.FieldIsNil(scui.IFO[id], "parent")=1
                  scui.RenderObject(id)
               Else
                  ; This is a child, skip drawing                               
               EndIf
            EndIf
         EndIf
      Next
   EndIf

   ; Performs Flip and end DoubleBuffer if needed                               
   If dbb = 1 Then Flip()
   If dbb = 1 Then EndDoubleBuffer()
EndFunction
Function scui.RenderObject( id ) ;----------------------------------------------
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | Render the given object to the screen using its id or its name          |
   ; | This function can handle overlapping windows                            |

   ; STA ROBA NON SERVE PIU', E NEANCHE LA FUNZIONE QUA SOTTO
   If scui.AutoRendering = False Then Return
   scui.RenderObjectX(id)

EndFunction
Function scui.RenderObjectX( id ) ;-------------------------------| PRIVATE |---
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | Render the given object to the screen using its id or its name          |
   ; | This function don't handle overlapping windows                          |
 
   If GetType(id) = #STRING Then id = scui.GetIFOID(id)
   If id < 0 Then Return

   ; Check if the Object exists                                                 
   If scui.ObjectExists(id)
      ; Check if the object is visible                                          
      If scui.IFO[id].Visible = #IFO_VISIBLE
         Local Obj = scui.IFO[id]
   	   Local VirtualAreaFlag = False
         Local VirtualAreaID = -1
			Local VAJustRenderd = False

         ; CONTROLLO L'OWNER PER GESTIRE CORRETTAMENTE IL RENDERING
         ; NELLE FINESTRE
         ; Questo if credo che non serva
         ;If scui.IFO[id].Owner = #SCREENID
         ;   scui.Win.Select(#SCREENID)
         ;Else
            scui.Win.Select(scui.IFO[id].Owner)
         ;EndIf
         
			; Verifico se l'oggetto appartiene ad una Virtual Area                  
			If helpers.FieldIsNil(Obj, "oparent") = 0
				Local ParentID = scui.GetMasterParent(id)
				If scui.IFO[ParentID].oClass = #IFOCLASS_VIRTUALAREA
					VirtualAreaFlag = True
					VirtualAreaID   = ParentID
               scui.RenderStack_Put(scui.IFO[ParentID].Brush)
				EndIf
			EndIf
            
         ; Select the appropriate drawing routine according to the IFO class    
         Switch Obj.oClass
            ;                                                   +-----------+   
            ; --------------------------------------------------| BEVEL BOX |---
            ;                                                   +-----------+   
            Case #IFOCLASS_BEVELBOX
               scui.DrawBevel(Obj.oData.Bevel)
               
            ;                                                       +-------+   
            ; ------------------------------------------------------| LABEL |---
            ;                                                       +-------+   
            Case #IFOCLASS_LABEL
            /* Modifica ifo_Text & ifo_Bevel in caso di GroupFrame            */
               If Obj.GroupFrame
                  Local lines = helpers.CountEntries(Obj.oData.Text.Content.Values)
                  If Obj.oData.Text.Content.Lines < lines Then lines = Obj.oData.Text.Content.Lines
                  SetFont(Obj.oData.Text.FontName, Obj.oData.Text.FontSize, { Engine = #FONTENGINE_INBUILT, Chache = True })
                  Local largest = 0
                  For Local l = 0 To lines-1
                     Local w = TextWidth(Obj.oData.Text.Content.Values[l])
                     If w > largest Then largest = w
                  Next
                  
                  Local w_margins = scui.theme.Label_GF_WMargins              
                  Local h_margins = scui.theme.Label_GF_HMargins   
                  Local w_Offset  = scui.theme.Label_GF_WOffset
                  
                  Local Text_H = h_margins * 2 + Obj.oData.Text.FontSize * lines + Obj.oData.Text.Content.VerticalOffset * (lines-1)
                  Local Text_W = largest + w_margins * 2
                  
                  Local TempBevel = helpers.CloneTable(Obj.oData.Bevel)
                  Local TempText  = helpers.CloneTable(Obj.oData.Text)
                  TempBevel.Position.y = Obj.oData.Bevel.Position.y + Text_H/2
                  TempBevel.Size.y = Obj.oData.Bevel.Size.y - Text_H/2
                  TempText.Area.yStart = TempBevel.Position.y - Text_H/2
                  TempText.Area.yEnd   = TempBevel.Position.y + Text_H/2
                  TempText.Area.xStart = TempBevel.Position.x + w_Offset
                  TempText.Area.xEnd   = TempText.Area.xStart + Text_W
                  
                  ; Bevel temporaneo per il BG della label                      
                  Local BGLab = helpers.CloneTable(scui.theme.Label_GFBevel)
                  helpers.SetTable(BGLab, { Position = { x = TempText.Area.xStart,
                                                         y = TempText.Area.yStart },
                                            Size     = { x = TempText.Area.xEnd - TempText.Area.xStart,
                                                         y = TempText.Area.yEnd - TempText.Area.yStart } }, 
                                           False)
                  
                  scui.DrawBevel(TempBevel)
                  scui.DrawBevel(BGLab)
                  scui.DrawText(TempText)
                  
               Else
                  ; Rendering di una label normale     
                  scui.DrawBevel(Obj.oData.Bevel)
                  scui.DrawText(Obj.oData.Text)
               EndIf
            ;                                                      +--------+   
            ; -----------------------------------------------------| BUTTON |---
            ;                                                      +--------+   
            Case #IFOCLASS_BUTTON
               If Obj.Enabled = #IFO_DISABLED
                  ; Disabled Button Aspect                                      
                  scui.DrawBevel(Obj.oData.DBevel)
                  scui.DrawText(Obj.oData.DText)
               Else
                  ; The button is <ACTIVE>                                      
                  Switch Obj.Status
                     Case #IFOSTATUS_NORMAL
                        ; Normal Button Aspect                                  
                        scui.DrawBevel(Obj.oData.Bevel)
                        scui.DrawText(Obj.oData.Text)
                     Case #IFOSTATUS_HILIGHTED
                        ; Hilighted Button Aspect                               
                        scui.DrawBevel(Obj.oData.HBevel)
                        scui.DrawText(Obj.oData.HText)
                     Case #IFOSTATUS_PUSHED
                        ; Pushed Button Aspect   
                        scui.DrawBevel(Obj.oData.PBevel)
                        scui.DrawText(Obj.oData.PText)
                  EndSwitch
               EndIf
            ;                                                      +--------+   
            ; -----------------------------------------------------| SWITCH |---
            ;                                                      +--------+   
            Case #IFOCLASS_SWITCH
               If Obj.Enabled = #IFO_DISABLED
                  ; The switch is <DISABLED>                                    
                  If Obj.Value = 0
                     ; Disabled and "UP" Switch Aspect                          
                     scui.DrawBevel(Obj.oData.DNBevel)
                     scui.DrawText(Obj.oData.DNText)
                  Else
                     ; Disabled and "DOWN" Switch Aspect                        
                     scui.DrawBevel(Obj.oData.DPBevel)
                     scui.DrawText(Obj.oData.DPText)
                  EndIf                            
               Else
                  ; The switch is <ACTIVE>                                      
                  Switch Obj.Status
                     Case #IFOSTATUS_NORMAL
                        ; Normal Switch Aspect  
                        If Obj.Value = 0
                           ; Normal and "UP" Switch Aspect                      
                           scui.DrawBevel(Obj.oData.Bevel)
                           scui.DrawText(Obj.oData.Text)
                        Else
                           ; Normal and "DOWN" Switch Aspect                    
                           scui.DrawBevel(Obj.oData.PBevel)
                           scui.DrawText(Obj.oData.PText)
                        EndIf                        
                     Case #IFOSTATUS_HILIGHTED
                        ; Hilighted Switch Aspect                               
                        If Obj.Value = 0
                           ; Hilighted and "UP" Switch Aspect                   
                           scui.DrawBevel(Obj.oData.HBevel)
                           scui.DrawText(Obj.oData.HText)
                        Else
                           ; Hilighted and "DOWN" Switch Aspect                 
                           scui.DrawBevel(Obj.oData.PBevel)
                           scui.DrawText(Obj.oData.PText)
                        EndIf
                     Case #IFOSTATUS_PUSHED
                        ; Pushed Switch Aspect                                  
                        scui.DrawBevel(Obj.oData.PBevel)
                        scui.DrawText(Obj.oData.PText)
                  EndSwitch
               EndIf
               ;                                                +-----------+   
               ; -----------------------------------------------| GAUGE BAR |---
               ;                                                +-----------+   
               Case #IFOCLASS_GAUGE
                  ; Calculate the brush dimensions                              
                  Local bw = Obj.oData.Container.Size.x + 1
                  Local bh = Obj.oData.Container.Size.y + 1
                  Local osx = 0
                  Local osy = 0
                  If Obj.oData.Container.Outline.Type <> #BEVELTYPE_NONE
                     If Obj.oData.Container.Outline.Type = #BEVELTYPE_SIMPLE
                        bw = bw + (Obj.oData.Container.Outline.Size1 * 2)
                        bh = bh + (Obj.oData.Container.Outline.Size1 * 2)
                        osx = Obj.oData.Container.Outline.Size1
                        osy = Obj.oData.Container.Outline.Size1
                     ElseIf Obj.oData.Container.Outline.Type = #BEVELTYPE_SUNKEN
                        bw = bw + (Obj.oData.Container.Outline.Size1 + Obj.oData.Container.Outline.Size2) * 2
                        bh = bh + (Obj.oData.Container.Outline.Size1 + Obj.oData.Container.Outline.Size2) * 2
                        osx = Obj.oData.Container.Outline.Size1 + Obj.oData.Container.Outline.Size2
                        osy = Obj.oData.Container.Outline.Size1 + Obj.oData.Container.Outline.Size2
                     EndIf
                  EndIf
                  CreateBrush(#MYBRUSH_GAUGERENDER, bw, bh, #WHITE)
                  scui.RenderStack_Put(#MYBRUSH_GAUGERENDER)
                  ; Draw the External box                                       
                  Local TempContainer = helpers.CloneTable(Obj.oData.Container)
                  TempContainer.Position.x = osx
                  TempContainer.Position.y = osy
                  scui.DrawBevel(TempContainer)
                  ; Get position and dimentions                                 
                  Local d = Obj.Values.MMax - Obj.Values.MMin
                  If d = 0 Then d = 1
                  Local e = Obj.BarSize
                  If e = 0 Then e = 1
                  Local gstep    = e / d
                  Local progress = Obj.Values.Current - Obj.Values.MMin
                  Local size     = gstep * progress
                  Obj.oData.Cursor.Size.x = size

                  Local TempCursor = helpers.CloneTable(Obj.oData.Cursor)
					   Local Offset = Obj.oData.Cursor.Position.x - Obj.oData.Container.Position.x
                  TempCursor.Position.x = osx + Offset
                  TempCursor.Position.y = osy + Offset
                  scui.DrawBevel(TempCursor)
                  ; Update text string according to current value               
                  Local mmin = Obj.Values.MMin
                  Local mmax = Obj.Values.MMax
                  Local diff = mmax - mmin
                  If diff = 0 Then diff = 1
                  Local perc = progress / diff * 100
                  Local curr = progress
                  Local t    = Obj.oData.Format
                  /*
                  t = helpers.MyReplace(t, "$CURRENT", StrStr(curr))
                  t = helpers.MyReplace(t, "$MIN", StrStr(mmin))
                  t = helpers.MyReplace(t, "$MAX", StrStr(mmax))
                  t = helpers.MyReplace(t, "$PERCENT", StrStr(perc))
                  */
                  t = ReplaceStr(t, "$CURRENT", StrStr(curr))
                  t = ReplaceStr(t, "$MIN",     StrStr(mmin))
                  t = ReplaceStr(t, "$MAX",     StrStr(mmax))
                  t = ReplaceStr(t, "$PERCENT", StrStr(perc))
                  
                  Obj.oData.Text.Content.Values = { t }
                  Obj.oData.Text.Content.Lines  = 1

                  Local TempText = helpers.CloneTable(Obj.oData.Text)
                  TempText.Area.xStart = TempCursor.Position.x
                  TempText.Area.yStart = TempCursor.Position.y
; *** NUOVA TAG PER IL TESTO, con il metodo commentato centra il testo all'interno       
; *** della barra di avanzamento, altrimenti all'interno del container                   
; TempText.Area.xEnd   = TempText.Area.xStart + TempCursor.Size.x - TempCursor.Height * 2
; TempText.Area.yEnd   = TempText.Area.yStart + TempCursor.Size.y - TempCursor.Height * 2
                  TempText.Area.xEnd   = TempText.Area.xStart + TempContainer.Size.x - TempContainer.Height * 2
                  TempText.Area.yEnd   = TempText.Area.yStart + TempContainer.Size.y - TempContainer.Height * 2
                  scui.DrawText(TempText) 
                  scui.RenderStack_Get()
                   DisplayBrush(#MYBRUSH_GAUGERENDER, Obj.oData.Container.Position.x - osx, Obj.oData.Container.Position.y - osy)
                   FreeBrush(#MYBRUSH_GAUGERENDER)
               ;                                               +------------+   
               ; ----------------------------------------------| STRING BOX |---
               ;                                               +------------+   
               Case #IFOCLASS_STRINGBOX
                  If Obj.Enabled = #IFO_DISABLED
                     ; The StringBox is <DISABLED>                              
                     scui.DrawBevel(Obj.oData.DBevel)
                     scui.DrawText(Obj.oData.DText)
                  Else
                     ; The StringBox is <ENABLED>                               
                     Switch Obj.Status
                         Case #IFOSTATUS_NORMAL
                            ; <ENABLED> and <NORMAL>                            
                            scui.DrawBevel(Obj.oData.Bevel)
                            scui.DrawText(Obj.oData.Text)
                         Case #IFOSTATUS_HILIGHTED
                            ; <ENABLED> and <HILIGHTED>                         
                            scui.DrawBevel(Obj.oData.HBevel)
                            scui.DrawText(Obj.oData.HText)
                         Case #IFOSTATUS_PUSHED
                            ; <ENABLED> and <PUSHED>                            
                            scui.DrawBevel(Obj.oData.PBevel)
                            scui.DrawText(Obj.oData.PText)
                     EndSwitch
                  EndIf
               ;                                          +-----------------+   
               ; -----------------------------------------| SIMPLE SCROLLER |---
               ;                                          +-----------------+   
               Case #IFOCLASS_SIMPLESCROLLER
                  If Obj.Enabled = #IFO_DISABLED
                     ; The SimpleScroller is <DISABLED>                         
                     scui.DrawBevel(Obj.oData.DContainer)
                     scui.DrawBevel(Obj.oData.DCursor)
                     scui.DrawText(Obj.oData.DText)
                  Else
                     ; The SimpleScroller is <ENABLED>                          
                     Switch Obj.Status
                        Case #IFOSTATUS_NORMAL
                           ; <ENABLED> and <NORMAL>                             
                           scui.DrawBevel(Obj.oData.Container)
                           scui.DrawBevel(Obj.oData.Cursor)
                           scui.DrawText(Obj.oData.Text)
                        Case #IFOSTATUS_HILIGHTED
                           ; <ENABLED> and <HILIGHTED>                          
                           scui.DrawBevel(Obj.oData.HContainer)
                           scui.DrawBevel(Obj.oData.HCursor)
                           scui.DrawText(Obj.oData.HText)
                        Case #IFOSTATUS_PUSHED
                           ; <ENABLED> and <PUSHED>                             
                           scui.DrawBevel(Obj.oData.HContainer)
                           scui.DrawBevel(Obj.oData.PCursor)
                           scui.DrawText(Obj.oData.PText)
                     EndSwitch
                  EndIf
               ;                                                 +----------+   
               ; ------------------------------------------------| SCROLLER |---
               ;                                                 +----------+   
               Case #IFOCLASS_SCROLLER
                  Switch Obj.TextMode
                     ; *********************************************************
                     ; *** SOSTITUIRE I VALORI FISSI CON DELLE COSTANTI!!    ***
                     ; *********************************************************
                     Case 0
                        Obj.oData.Text.Content.Values  = { "" }
                        Obj.oData.hText.Content.Values = { "" }
                        Obj.oData.pText.Content.Values = { "" }
                        Obj.oData.dText.Content.Values = { "" }
                     Case 1
                        Obj.oData.Text.Content.Values  = Obj.TextContent
                        Obj.oData.hText.Content.Values = Obj.TextContent
                        Obj.oData.pText.Content.Values = Obj.TextContent
                        Obj.oData.dText.Content.Values = Obj.TextContent
                     Case 2
                        Obj.oData.Text.Content.Values  = { StrStr(Int(Obj.FirstItem) + Obj.ValueOffset) }
                        Obj.oData.hText.Content.Values = { StrStr(Int(Obj.FirstItem) + Obj.ValueOffset) }
                        Obj.oData.pText.Content.Values = { StrStr(Int(Obj.FirstItem) + Obj.ValueOffset) }
                        Obj.oData.dText.Content.Values = { StrStr(Int(Obj.FirstItem) + Obj.ValueOffset) }
                  EndSwitch

                  ; Render the scroller using a brush                           
                  Local bid = -1 ; helpers.GetBrushID()
                  bid = CreateBrush(Nil, Obj.oData.Container.Position.x + Obj.oData.Container.Size.x + 1,  Obj.oData.Container.Position.y + Obj.oData.Container.Size.y + 1)
                  SelectBrush(bid)

                  If Obj.Enabled = #IFO_DISABLED
                     ; The Scroller is <DISABLED>                               
                     scui.DrawBevel(Obj.oData.DContainer)
                     scui.DrawBevel(Obj.oData.DCursor)
                     scui.DrawText(Obj.oData.DText)
                  Else
                     ; The Scroller is <ENABLED>                                
                     Switch Obj.Status
                        Case #IFOSTATUS_NORMAL
                           ; <ENABLED> and <NORMAL>        
                           scui.DrawBevel(Obj.oData.Container)
                           scui.DrawBevel(Obj.oData.Cursor)
                           scui.DrawText(Obj.oData.Text)
                        Case #IFOSTATUS_HILIGHTED
                           ; <ENABLED> and <HILIGHTED>                          
                           scui.DrawBevel(Obj.oData.HContainer)
                           scui.DrawBevel(Obj.oData.HCursor)
                           scui.DrawText(Obj.oData.HText)
                        Case #IFOSTATUS_PUSHED
                           ; <ENABLED> and <PUSHED>                             
                           scui.DrawBevel(Obj.oData.HContainer)
                           scui.DrawBevel(Obj.oData.PCursor)
                           scui.DrawText(Obj.oData.PText)
                     EndSwitch
                  EndIf
                  ; Renders the childs if they exists (arrows)                  
                  If Obj.ChildCount > 0
                     scui.RenderObject(Obj.Childs[1])
                     scui.RenderObject(Obj.Childs[2])
                  EndIf
                  ; If needed renders the handle, but only if no text is        
                  ; rendered inside the cursor's body                           
					   If Obj.TextMode = #SCROLLER_TEXT_NONE
						   If Obj.HandleType = #SCROLLER_KNOB_BOX
						      ; HANDLE KNOB TYPE                                      
						      ; Create a BevelStruct copy based on the cursor's       
						      ; model and apply the theme variations                  
								Local knob = {}
								If Obj.Status = #IFOSTATUS_NORMAL
								   knob = scui.NewBevel(Obj.oData.Cursor, scui.theme.Scroller_Box_NAspect)
								ElseIf Obj.Status = #IFOSTATUS_HILIGHTED
								   knob = scui.NewBevel(Obj.oData.HCursor, scui.theme.Scroller_Box_HAspect)
								ElseIf Obj.Status = #IFOSTATUS_PUSHED
							      knob = scui.NewBevel(Obj.oData.PCursor, scui.theme.Scroller_Box_PAspect)
								Else
								   knob = scui.NewBevel(Obj.oData.DCursor, scui.theme.Scroller_Box_DAspect)
								EndIf
								Local dimx = Int(knob.Size.x / scui.theme.Scroller_BoxFraction)
								Local dimy = Int(knob.Size.y / scui.theme.Scroller_BoxFraction)
 								Local px = Int(knob.Size.x / 2)
								Local py = Int(knob.Size.y / 2)

							   Local d = Min(dimx, dimy)
								scui.ResizeBevel(knob, d, d)
								scui.MoveBevel(knob, px - knob.Size.x/2, py - knob.Size.y/2, 1)
								scui.DrawBevel(knob)

						   ElseIf Obj.HandleType = #SCROLLER_KNOB_LINES
						      ; HANDLE LINES TYPE                                     
								; Renders 3d lines as the handle                        
								; Calculate the color to use based on the cursor's color
								Local CursCol = Obj.oData.Cursor.Colors.Edges
								Local Bri = helpers.BrightColorRGB(CursCol.r, CursCol.g, CursCol.b, CursCol.Contrast/2)
								Local Drk = helpers.DarkColorRGB(CursCol.r, CursCol.g, CursCol.b, CursCol.Contrast/2)

								; Calculate the cursor's center                         
								Local cx = Obj.oData.Cursor.Position.x + Obj.oData.Cursor.Size.x / 2
								Local cy = Obj.oData.Cursor.Position.y + Obj.oData.Cursor.Size.y / 2
								If Obj.Type = #SCROLLERTYPE_VERTICAL
								   ; Vertical Scroller case                             
									Local brd = Obj.oData.Cursor.Size.x / 5
									Local dist = scui.theme.Scroller_LinesDist
									Local odist = dist
									Local xs = Obj.oData.Cursor.Position.x + brd
									Local xe = Obj.oData.Cursor.Position.x + Obj.oData.Cursor.Size.x - brd
									; Render the first line (mandatory)                  
									Line(xs, cy, xe, cy, Drk)
									Line(xs, cy+1, xe, cy+1, Bri)
									; Loop to render the additional lines                
									For Local i = 1 To scui.theme.Scroller_LinesRepeat
									   If cx - odist > Obj.oData.Cursor.Position.x
											Line(xs, cy-odist, xe, cy-odist, Drk)
											Line(xs, cy-odist+1, xe, cy-odist+1, Bri)
											Line(xs, cy+odist, xe, cy+odist, Drk)
											Line(xs, cy+odist+1, xe, cy+odist+1, Bri)
											odist = odist + dist
										Else
										   ; Break the loop as soon as the lines are going
										   ; beyond the cursor's borders                  
											Break
										EndIf
									Next
								Else
								   ; Vertical Scroller case                             
									Local brd = Obj.oData.Cursor.Size.y / 5
									Local dist = scui.theme.Scroller_LinesDist
									Local odist = dist
									Local ys = Obj.oData.Cursor.Position.y + brd
									Local ye = Obj.oData.Cursor.Position.y + Obj.oData.Cursor.Size.y - brd
									; Render the first line (mandatory)                  
									Line(cx  , ys, cx  , ye, Drk)
									Line(cx+1, ys, cx+1, ye, Bri)
									; Loop to render the additional lines                
									For Local i = 1 To scui.theme.Scroller_LinesRepeat
									   If cx - odist > Obj.oData.Cursor.Position.x
											Line(cx-odist  , ys, cx-odist  , ye, Drk)
											Line(cx+1-odist, ys, cx+1-odist, ye, Bri)
											Line(cx+odist  , ys, cx+odist  , ye, Drk)
											Line(cx+1+odist, ys, cx+1+odist, ye, Bri)
											odist = odist + dist
										Else
										   ; Break the loop as soon as the lines are going
										   ; beyond the cursor's borders                  
											Break
										EndIf
									Next
								EndIf
							EndIf
						EndIf
                  EndSelect
                  ; Renders the brush to the screen                             
                  CropBrush(bid, Obj.oData.Container.Position.x, Obj.oData.Container.Position.y, Obj.oData.Container.Size.x + 1, Obj.oData.Container.Size.y + 1 )
                  DisplayBrush(bid, Obj.oData.Container.Position.x, Obj.oData.Container.Position.y)
                  FreeBrush(bid)
               ;                                                  +---------+   
               ; -------------------------------------------------| OPTIONS |---
               ;                                                  +---------+   
               Case #IFOCLASS_OPTIONS
                  ; Render The OptionsBox's Container                           
                  scui.DrawBevel(Obj.oData.Container)
                  ; Renders the available Options                               
                  For Local o = 1 To Obj.ChildCount
                     Local Child = Obj.Childs[o]
                     scui.RenderObject(Child)
                  Next
               ;                                                     +------+   
               ; ----------------------------------------------------| MENU |---
               ;                                                     +------+   
               Case #IFOCLASS_MENU
                  ; Renders all the menu' items                                 
                  For Local o = 1 To Obj.ChildCount
                     Local Child = Obj.Childs[o]
                     scui.RenderObject(Child)
                  Next
               ;                                                    +-------+   
               ; ---------------------------------------------------| CYCLE |---
               ;                                                    +-------+   
               Case #IFOCLASS_CYCLE
                  Local CycleID  = scui.IFO[id].Childs[1]
                  scui.RenderObject(CycleID)
               ;                                                 +----------+   
               ; ------------------------------------------------| LISTVIEW |---
               ;                                                 +----------+   
               Case #IFOCLASS_LISTVIEW
                  ; Container                                                   
                  scui.DrawBevel(Obj.oData.Container)
                  ; Scroller if available                                       
                  If helpers.FieldIsNil(Obj, "scrollerid") = 0 Then scui.RenderObject(Obj.ScrollerID)
                  ; Childs (Headers & Rows)                                     
                  Local o = 0
                  For o = 1 To Obj.ChildCount
                     Local Child = Obj.Childs[o]
                     scui.RenderObject(Child)
                  Next
               ;                                                     +------+   
               ; ----------------------------------------------------| TABS |---
               ;                                                     +------+   
               Case #IFOCLASS_TABS
                  ; Draw the container                                          
                  scui.DrawBevel(Obj.oData.SmallContainer)
                  scui.DrawBevel(Obj.oData.BigContainer)
                  scui.DrawBevel(Obj.oData.ContentFrame)
                  ; Draw the page selector                                      
                  scui.RenderObject(Obj.PageSelectorID)
                  Local pagecount
                  Local Active = Obj.ActivePage
                  For pagecount = 0 To Obj.PageCount - 1
                     Local childcount = helpers.CountEntries(Obj.TabChilds[pagecount])
                     Local c
                     ; Draw Object assigned to the active page                  
                     If pagecount = Active
                        For c = 0 To childcount - 1
                           scui.RenderObject(Obj.TabChilds[pagecount][c].Id)
                        Next
                     Else
                        ; nothing here for now                                  
                     EndIf
                  Next
               ;                                                    +-------+   
               ; ---------------------------------------------------| IMAGE |---
               ;                                                    +-------+   
               Case #IFOCLASS_IMAGE
                   ; Calculate the outline border                               
                   Local olb = 0
                   Switch Obj.oData.Container.Outline.Type
                     Case #BEVELTYPE_NONE
                        olb = 0
                     Case #BEVELTYPE_FLAT
                        olb = Obj.oData.Container.Outline.Size1
                     Case #BEVELTYPE_SIMPLE
                        olb = Obj.oData.Container.Outline.Size1
                     Case #BEVELTYPE_SUNKEN
                        olb = Obj.oData.Container.Outline.Size1 + Obj.oData.Container.Outline.Size2
                   EndSwitch

                   ; Use a brush to smoot the gadget rendering                  
                   Local bid = -1 ; helpers.GetBrushID()
                   bid = CreateBrush(Nil, Obj.oData.Container.Position.x + Obj.oData.Container.Size.x + 1 + olb * 2,  Obj.oData.Container.Position.y + Obj.oData.Container.Size.y + 1 + olb * 2)
                   SelectBrush(bid)

                  ; Draw The Container                                          
                   Switch Obj.Status
                      Case #IFOSTATUS_NORMAL
                         ; <NORMAL>                                             
                         scui.DrawBevel(Obj.oData.Container)
                      Case #IFOSTATUS_HILIGHTED
                         ; <HILIGHTED>                                          
                         scui.DrawBevel(Obj.oData.HContainer)
                      Default
                         ; <PUSHED>                                             
                         scui.DrawBevel(Obj.oData.Container)
                   EndSwitch

                  ; Calculate the clip area                                     
                  Local offset = IIF(Obj.oData.Container.Type = #BEVELTYPE_NONE, 0, IIF(Obj.oData.Container.Type = #BEVELTYPE_SIMPLE, 1, 2) ) * Obj.oData.Container.Height
                  Local width  = Obj.oData.Container.Size.x - offset * 2 + 1
                  Local height = Obj.oData.Container.Size.y - offset * 2 + 1
                  scui.SafeClipRegion(#EDITTEXT_CLIPID, #BOX, Obj.oData.Container.Position.x + offset, Obj.oData.Container.Position.y + offset, width, height)
                  SetClipRegion(#EDITTEXT_CLIPID)

                  ; Center brush (if requested)                                 
                  Local xc = 0
                  Local yc = 0
                  If Obj.CenterImage
                     Local bw = GetAttribute(#BRUSH, Obj.ImageBrush, #ATTRWIDTH)
                     Local bh = GetAttribute(#BRUSH, Obj.ImageBrush, #ATTRHEIGHT)
                     xc = (width  - bw)/2
                     yc = (height - bh)/2
                  EndIf

                  DisplayBrush(Obj.ImageBrush, Obj.oData.Container.Position.x + Obj.XOffset + offset + xc, 
                                               Obj.oData.Container.Position.y + Obj.YOffset + offset + yc )
                  EndSelect
                  CropBrush(bid, Obj.oData.Container.Position.x - olb, Obj.oData.Container.Position.y - olb, Obj.oData.Container.Size.x + 1 + olb*2, Obj.oData.Container.Size.y + 1 + olb*2)
                  DisplayBrush(bid, Obj.oData.Container.Position.x - olb, Obj.oData.Container.Position.y - olb)
                  FreeBrush(bid)

                  SetClipRegion(#NONE)
                  FreeClipRegion(#EDITTEXT_CLIPID)
               ;                                             +--------------+   
               ; --------------------------------------------| VIRTUAL AREA |---
               ;                                             +--------------+   
               Case #IFOCLASS_VIRTUALAREA
					   ; Draw the container                                          
					   scui.DrawBevel(Obj.oData.Container)

					   ; Calculate the active zone areas                             
					   Local NewArea = {}
					   Local ccnt = Obj.ChildCount
					   Local i = 0
					   ; Check all childs (all IFOs included in the virtual area)    
					   For i = 1 To ccnt
						   If (scui.IFO[Obj.Childs[i]].oInteractive = 1) Or (scui.IFO[Obj.Childs[i]].oClass = #IFOCLASS_CYCLE)
						 	   ; Handle the active zone of the interactive gadgets only
                        If scui.IFO[Obj.Childs[i]].oClass = #IFOCLASS_CYCLE
                        Local temp = scui.Get(scui.IFO[Obj.Childs[i]].Childs[1])
   						   Local temparea = { xStart = temp.Position.x, yStart = temp.Position.y,
   							 					    xEnd = temp.Position.x + temp.Size.x, yEnd = temp.Position.y + temp.Size.y }
   			    		   ; Modify the original active zone                       
   						   temparea.xStart = temparea.xStart + Obj.Viewport.xStart - Obj.Offset.x
   						   temparea.yStart = temparea.yStart + Obj.Viewport.yStart - Obj.Offset.y
   						   temparea.xEnd = temparea.xStart + temp.Size.x
   						   temparea.yEnd = temparea.yStart + temp.Size.y
   						   ; Execute the zone cropping inside the virtual area     
   						   NewArea = helpers.SmartAreaCrop(Obj.Viewport, temparea)
   						   If helpers.IsNil(NewArea) = 0
   						      ; If needed regenerate the button inside the VA      
   							   Local ChildObj = scui.IFO[scui.IFO[Obj.Childs[i]].Childs[1]]
   							   DeleteButton(scui.IFO[Obj.Childs[i]].Childs[1])
   							   MakeButton(scui.IFO[Obj.Childs[i]].Childs[1], #SIMPLEBUTTON, 
   							  			     NewArea.xStart, NewArea.yStart, 
   											  NewArea.xEnd - NewArea.xStart + 1, NewArea.yEnd - NewArea.yStart + 1, 
   											  { OnMouseOver = scui.HandleObject, OnMouseOut  = scui.HandleObject, OnMouseDown = scui.HandleObject, OnMouseUp   = scui.HandleObject } )                  
                           If ChildObj.Visible = #IFO_HIDDEN Or ChildObj.Enabled = #IFO_DISABLED Then DisableButton(Obj.Childs[i])
   						   Else
   							   ; If the button is not visible disable the zone      
   							   DisableButton(scui.IFO[Obj.Childs[i]].Childs[1])
   						   EndIf
                     Else
                        Local temp = scui.Get(Obj.Childs[i])
  							   Local temparea = { xStart = temp.Position.x, yStart = temp.Position.y,
   													 xEnd = temp.Position.x + temp.Size.x, yEnd = temp.Position.y + temp.Size.y }
   						   ; Modify the original active zone                       
   						   temparea.xStart = temparea.xStart + Obj.Viewport.xStart - Obj.Offset.x
   						   temparea.yStart = temparea.yStart + Obj.Viewport.yStart - Obj.Offset.y
   						   temparea.xEnd = temparea.xStart + temp.Size.x
   						   temparea.yEnd = temparea.yStart + temp.Size.y
   						   ; Execute the zone cropping inside the virtual area     
   						   NewArea = helpers.SmartAreaCrop(Obj.Viewport, temparea)

  							   Local ChildObj = scui.IFO[Obj.Childs[i]]
   						   If helpers.IsNil(NewArea) = 0
   						      ; If needed regenerate the button inside the VA      
								   If ChildObj.oClass = #IFOCLASS_CYCLE
									   DeleteButton(scui.IFO[Obj.Childs[i]].Childs[1])
								   Else
	   							   DeleteButton(Obj.Childs[i])
	   							   MakeButton(Obj.Childs[i], #SIMPLEBUTTON, 
	   											  NewArea.xStart, NewArea.yStart, 
	   											  NewArea.xEnd - NewArea.xStart + 1, NewArea.yEnd - NewArea.yStart + 1, 
	   											  { OnMouseOver = scui.HandleObject, OnMouseOut  = scui.HandleObject, OnMouseDown = scui.HandleObject, OnMouseUp   = scui.HandleObject } )                  
	                           If ChildObj.Visible = #IFO_HIDDEN Or ChildObj.Enabled = #IFO_DISABLED Then DisableButton(Obj.Childs[i])
								   EndIf
							   Else
   							   ; If the button is not visible disable the zone      
								   If ChildObj.oClass = #IFOCLASS_CYCLE
									   DisableButton(scui.IFO[Obj.Childs[i]].Childs[1])
								   Else
									   DisableButton(Obj.Childs[i])
								   EndIf
   						   EndIf
                     EndIf
					   EndIf
			      Next

               ; ***************************************************************
               ; ***** ATTENZIONE ALLA PARTE FINALE DELLA ROUTINE: perchè viene 
               ; ***** mostrato qua il brush e non nella parte finale?          
               ; ***** Qui non viene chiamato scui.RenderStack_Get(): come mai? 
               ; ***************************************************************
				   ; Brush's coordinates                                            
				   xPos = Obj.ViewPort.xStart
				   yPos = Obj.ViewPort.yStart

				   ; Calculate the brush's portion to display                       
				   br_xStart = Obj.Offset.x
				   br_yStart = Obj.Offset.y
				   br_xSize  = Obj.ViewPort.xEnd - Obj.ViewPort.xStart
				   br_ySize  = Obj.ViewPort.yEnd - Obj.ViewPort.yStart

				   ; Display the rendered brush                                     
				   DisplayBrushPart(Obj.Brush, br_xStart, br_yStart, xPos, yPos, br_xSize, br_ySize)
				   VAJustRenderd = True

			   EndSwitch

            ;    +-----------------------------+                                
            ; ---| RENDERS ALL GADGET'S CHILDS |--------------------------------
            ;    +-----------------------------+                                
            If helpers.FieldIsNil(Obj, "childlist") = 0
               Local GrpCnt = helpers.CountEntries(Obj.ChildList)
				   For Local g = 1 To GrpCnt
					   Local childs = helpers.CountEntries(Obj.ChildList[g])
	               For Local cnt = 1 To childs
	                  scui.RenderObject(Obj.ChildList[g][cnt].Id)
	               Next
				   Next
            EndIf

            ;    +-----------------------------------+                          
            ; ---| HANDLE THE VIRTUAL AREA RENDERING |--------------------------
            ;    +-----------------------------------+                          
			   If VirtualAreaFlag
               scui.RenderStack_Get()
				   If VAJustRender = False
					   ; Brush's coordinates                                         
                  Local Objj = scui.IFO[VirtualAreaID]
                  xPos = Objj.ViewPort.xStart
                  yPos = Objj.ViewPort.yStart
                  ; Calculate the brush's coordinates                           
                  br_xStart = Objj.Offset.x
                  br_yStart = Objj.Offset.y
                  br_xSize  = Objj.ViewPort.xEnd - Objj.ViewPort.xStart
                  br_ySize  = Objj.ViewPort.yEnd - Objj.ViewPort.yStart
						
					   DisplayBrushPart(Objj.Brush, br_xStart, br_yStart, xPos, yPos, br_xSize, br_ySize)
				   EndIf
			   EndIf
      EndIf
   EndIf
EndFunction
Function scui.HandleCloseMenu(name) ;----------------------------| OBSOLETE |---
   ; Added: v0.5   Docs : 27.12.2008                                            
	; | Called automatically when the user close a menu'                        |

   RemoveItem(scui.Menu)
   scui.FWin_Free(name, True)
EndFunction
Function scui.HandleObject(msg) ;---------------------------------| PRIVATE |---
   ; Added: v0.5   Docs : 26.12.2008                                            
	; | This function handles all the events generated by the active IFOs       |

   ; Discard the event if the event handling has been stopped   
      
   If Not(scui.EventHandling) Then Return

   If scui.prefs.DebugMode 
      ; Print to the console event's informations                               
      debugprint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "[ HANDLE OBJECT ] Message From IFO:", msg.id, ", Action:", msg.action, ", Class:", scui.IFO[msg.id].oClass, ", Owner:", scui.IFO[msg.id].Owner)
   EndIf

   Local www = scui.Win.FindByHandler(msg.Display)
   
   ; Se l'evento proviene da una finestra chiusa me ne esco
   If Not(scui.Windows[www.id].Opened) Then Return()
   
   ; Sembra che quando attivo una finestra premendo i gadget mi arrivi la seguente sequenza:
   ; - ActiveDisplay   
   ; - OnMouseDown
   ; - OnMouseOver
   ; Pertanto posso identificare questo comportamento perche' ricevo un evento
   ; da un gadget che risiede in una finestra momentaneamente inattiva
   ; quindi:
   If msg.action = "OnMouseDown"
      If Not(helpers.FieldIsNil(scui, "justactivated"))
         If scui.JustActivated
            scui.IFO[msg.id].Status = #IFOSTATUS_HILIGHTED
            scui.JustActivated = False
         EndIf
      EndIf
   EndIf
   
   If msg.action = "OnMouseDown"
      scui.Windows[www.id].ActionStatus = "OnMouseDown"
   EndIf

   If msg.Action = "OnMouseOver" And scui.Windows[www.id].ActionStatus = "OnMouseDown"
      If IsLeftMouse()
         scui.IFO[msg.id].Status = #IFOSTATUS_HILIGHTED
         msg.Action = "OnMouseDown"
      EndIf
   EndIf
   
   ; Check if the event is coming from the keyboard, if this is not the case    
   ; uncheck the object selected by the keyboard ond proceed normally           
   If helpers.FieldIsNil(msg, "keyboard") = 1
      If scui.Keyboard[www.Name].ActiveIFO > 0
         scui.HandleObject( { id = scui.Keyboard[www.Name].ActiveIFO, action = "OnMouseOut", Keyboard = 1, Display = msg.Display } )
         scui.Keyboard[www.Name].ActiveIFO = -1
         scui.Windows[www.id].ActionStatus = ""
      EndIf
   EndIf

   ; Check if there is an activated StringBox while the left mouse button is    
   ; pressed, in this case deactivate the StringBox sending a <Return> message  
   If scui.Keyboard[www.Name].Mode = #KEYBOARD_INPUTMODE And msg.action = "OnMouseDown"
      If msg.id <> scui.Keyboard[www.Name].ActiveStringBox Then scui.Keyboard_Handler( { key = Chr(10), action = "OnKeyDown", id = msg.Display } )
   EndIf

   ; Store the IFO to a variable to speedup the accessing time                  
   Local Obj = scui.IFO[msg.id]

   ; Ignore messages coming from non-active owners                              
   ;If scui.ActiveWindow <> scui.IFO[msg.id].Owner Then Return

   ; If there is opened windows and this message is sent by a screen object     
   ; ignore the event (see documentation for more infos)                        
   ;Local c = helpers.CountEntries(scui.WinOrder)
   ;If (c > 0) And (scui.ActiveWindow = #SCREENID) Then Return

   ; For each gadget class select the appropriate handling routine              
   Switch Obj.oClass
      Case #IFOCLASS_MENU
         Local ParentWin = scui.IFO[msg.callfrom].Owner
         Local Father = scui.IFO[msg.callfrom].oParent
         Local Free   = scui.IFO[father].Free

         ; Search the sub-menu' we have to open                                 
         Local item = -1
         For Local i = 1 To Obj.ChildCount
            If Obj.Childs[i] = msg.callfrom
               item = i - 1
               Break
            EndIf
         Next

         If GetType(Obj.Menu[item][1]) = #FUNCTION
            Local tmp = scui.Get(msg.callfrom)
            Obj.Menu[item][1]({ item = Obj.Menu[item][0],
                                menu = tmp.Owner })
            If Free = False
               For Local i = helpers.CountEntries(scui.Menu) - 1 To 0 Step -1
                  scui.FWin_Close(scui.Menu[i])
               Next
            EndIf
         Else
            Local HBorder = scui.theme.Menu_HBorder
            Local VBorder = scui.theme.Menu_VBorder
            Local HItem   = scui.theme.Menu_ItemWidth
            Local VItem   = scui.theme.Menu_ItemHeight
            Local VWHeader = scui.theme.FWin_MNTitleText.FontSize + (scui.theme.FWin_MNTitleBox.Height * IIF(scui.theme.FWin_MNTitleBox.Type = #BEVELTYPE_SUNKEN, 2, 1))*2 + Max(scui.theme.FWin_MActiveBody.Height, scui.theme.FWin_MInactiveBody.Height)*2
            Local HWBorder = Max(scui.theme.FWin_MActiveBody.Height, scui.theme.FWin_MInactiveBody.Height)
            Local xBack = scui.theme.Menu_BackPixels
            Local tmp = scui.Get(msg.callfrom)
            Local smName = tmp.oName
            Local smOffset = { x = tmp.Size.x - xBack, y = tmp.Size.y / 2 }
            Local smPos = { x = tmp.Position.x + smOffset.x,
                           y = tmp.Position.y + smOffset.y }
            Local SubMenu = Obj.Menu[item][1]
            Local Name  = Obj.Menu[item][0]
            Local WinID = ""
            Local smc = helpers.CountEntries(scui.Menu)
            If smc = 0
              WinID = "Menu." .. Name
            Else
              WinID = ParentWin .. "." .. Name
            EndIf

            If scui.FWin_Exists(WinID)
               scui.FWin_Activate(WinID)
               Return
            EndIf

            scui.Menu[smc] = WinID
            scui.PauseObjectRendering()
            Local cnt = helpers.CountEntries(SubMenu)
            scui.FWin_New(WinID, 
                            { Position = smPos,
                              Size = { x = HBorder*2 + HItem + HWBorder*2, 
                                       y = VBorder*2 + (VItem+1)*cnt + VWHeader } }, 
                              Name, 
                              nil, 
                              { scui.NewObject(#IFOCLASS_MENU, Name,
                                               { x = HBorder, y = VBorder },
                                               { x = HItem,   y = VItem   },
                                               nil,
                                               { Menu = SubMenu,
                                                 Mode = 2,
                                                 Free = Free } ) },
                              { OnClose = scui.HandleCloseMenu },
                              { Modal = IIF(Free = False, True, False),
                                MenuAspect = True } )
            scui.ResumeObjectRendering()
            scui.FWin_Open(WinID)
         EndIf
         ;                                                          +-------+   
         ; ---------------------------------------------------------| IMAGE |---
         ;                                                          +-------+   
         Case #IFOCLASS_IMAGE
            ; ACTIONS: OnClick, OnIn, OnOut                                     
                                     
            If Obj.Enabled = #IFO_ENABLED And Obj.Visible = #IFO_VISIBLE                     
                Switch msg.action
                    Case "OnMouseOver"
                        Obj.Status = #IFOSTATUS_HILIGHTED
                        scui.RenderObject(msg.id)
								If helpers.FieldIsNil(Obj.Actions, "onin")=0 Then Obj.Actions.OnIn({id=msg.id, event="OnIn"})
                    Case "OnMouseOut"
                        Obj.Status = #IFOSTATUS_NORMAL
                        scui.RenderObject(msg.id)
								If helpers.FieldIsNil(Obj.Actions, "onout")=0 Then Obj.Actions.OnOut({id=msg.id, event="OnOut"})
                    Case "OnMouseDown"
                        If Obj.Status = #IFOSTATUS_HILIGHTED
                            Obj.Status = #IFOSTATUS_PUSHED
                            scui.RenderObject(msg.id)
                            ; Check if this obj is a child checking its parent  
                            If helpers.FieldIsNil(Obj, "oparent")=0
                                Local Parent = Obj.oParent
                                Local ParentMsg = { id       = Parent,
                                                    action   = "OnDown",
                                                    callfrom = msg.id,
                                                    event    = "UP->DOWN",
                                                    display  = msg.Display }
                                If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
                                scui.HandleObject(ParentMsg)
                            EndIf
                            If helpers.FieldIsNil(Obj.Actions, "ondown")=0 Then Obj.Actions.OnDown({id=msg.id, event="OnDown"})
                        EndIf
                    Case "OnMouseUp"
                        If Obj.Status = #IFOSTATUS_PUSHED
                            Obj.Status = #IFOSTATUS_HILIGHTED
                            scui.RenderObject(msg.id)
                            ; Check if it's a child                             
                            If helpers.FieldIsNil(Obj, "oparent")=1
                                If helpers.FieldIsNil(Obj.Actions, "onup")=0 Then Obj.Actions.OnUp({id=msg.id, event="OnUp"})
                            EndIf
                        EndIf
                EndSwitch
            EndIf
        ;                                                          +--------+   
        ; ---------------------------------------------------------| BUTTON |---
        ;                                                          +--------+   
        Case #IFOCLASS_BUTTON
            ; ACTIONS: OnPushed, OnDown                                         

            If Obj.Enabled = #IFO_ENABLED And Obj.Visible = #IFO_VISIBLE                     
                Switch msg.action
                    Case "OnMouseOver"
                        Obj.Status = #IFOSTATUS_HILIGHTED
                        scui.RenderObject(msg.id)
                    Case "OnMouseOut"
                        Obj.Status = #IFOSTATUS_NORMAL
                        scui.RenderObject(msg.id)
                    Case "OnMouseDown"
                        If Obj.Status = #IFOSTATUS_HILIGHTED
                            Obj.Status = #IFOSTATUS_PUSHED
                            scui.RenderObject(msg.id)
                            
                            ; Chiama la funzione di callback: OnDown
								    If Not(helpers.FieldIsNil(Obj.Actions, "ondown"))
                               Local w = scui.Win.FindByName(Obj.Owner)
                               Obj.Actions.OnDown({ id      = msg.id, 
                                                    event   = "OnDown",
                                                    Owner   = Obj.Owner,
                                                    ObjPtr  = Obj,
                                                    display = w.HWId,
                                                    name    = Obj.oName })
                            EndIf
                        EndIf
                    Case "OnMouseUp"
                        If Obj.Status = #IFOSTATUS_PUSHED
                            Obj.Status = #IFOSTATUS_HILIGHTED
                            scui.RenderObject(msg.id)
                            ; Verifica se il pulsante e' associato ad un PopUp
                            Local WinName = Obj.Owner
                            Local w = scui.Win.FindByName(WinName)
                            If Not(helpers.FieldIsNil(scui.Windows[w.id], "ismenu"))
                              ; Tutti i pulsanti hanno il campo <menu_item>
                              ; se questo e' uguale ad 1 significa che questo pulsante
                              ; dovra' aprire un submenu', altrimenti, se 0, si tratta
                              ; di una scelta ed il popup dovra' essere chiuso
                              If Obj.menu_item = 0
                                 scui.ClosePopUp()
                              ElseIf Obj.menu_item = -1
                                 ; SI TRATTA DI UN PULSANTE DI CAMBIO PAGINA
                                 win = scui.Windows[w.id]
                                 If RightStr(Obj.oName, 4) = "Next"
                                    ; NEXT PAGE
                                    Local gprev = scui.Get(WinName .. "*Pager*Prev")
                                    If gprev.Enabled = #IFO_DISABLED
                                       scui.Set(WinName .. "*Pager*Prev", { Enabled = #IFO_ENABLED }, 1)
                                    EndIf
                                    win.FirstShowed = win.FirstShowed + win.ItemsPerPage
                                    scui.Win.PopUp_MakeItems(WinName, Obj.CycleName)
                                    If win.LastPage
                                       scui.Set(WinName .. "*Pager*Next", { Enabled = #IFO_DISABLED }, 1)
                                    EndIf
                                 Else
                                    ; PREV PAGE
                                    Local gnext = scui.Get(WinName .. "*Pager*Next")
                                    If gnext.Enabled = #IFO_DISABLED
                                       scui.Set(WinName .. "*Pager*Next", { Enabled = #IFO_ENABLED }, 1)
                                    EndIf
                                    win.FirstShowed = win.FirstShowed - win.ItemsPerPage
                                    scui.Win.PopUp_MakeItems(WinName, Obj.CycleName)
                                    If win.FirstShowed = 0
                                       scui.Set(WinName .. "*Pager*Prev", { Enabled = #IFO_DISABLED }, 1)
                                    EndIf
                                    win.LastPage = False
                                 EndIf
                              Else
                                 ; Apre submenu'
                                 Local w = scui.Win.FindByName(WinName)
                                 Local item_count = helpers.CountEntries(Obj.menu_sub)
                                 If item_count > 0
                                    Local position = { MouseX() + GetAttribute(#DISPLAY, w.HWId, #ATTRXPOS),
                                                       MouseY() + GetAttribute(#DISPLAY, w.HWId, #ATTRYPOS) + GetAttribute(#DISPLAY, w.HWId, #ATTRBORDERTOP) }
                                    scui.Win.PopUp(position, Obj.menu_sub)
                                 EndIf
                 
                              EndIf
                            EndIf
                            
                            ; Check if this obj is a child checking its parent  
                            If Not(helpers.FieldIsNil(Obj, "oparent"))
                                Local Parent = Obj.oParent
                                Local ParentMsg = { id       = Parent,
                                                    action   = "OnDown",
                                                    callfrom = msg.id,
                                                    event    = "UP->DOWN",
                                                    display  = msg.Display }
                                If Not(helpers.FieldIsNil(msg, "keyboard")) Then ParentMsg.Keyboard = 1
                                scui.HandleObject(ParentMsg)
                            Else
                                If Not(helpers.FieldIsNil(Obj.Actions, "onpushed"))
                                   ; Chiama la funzione di callback: OnPushed
                                   Local w = scui.Win.FindByName(Obj.Owner)
                                   If helpers.IsNil(w) Then w = { HWID = -1 }
                                   Obj.Actions.OnPushed({ id      = msg.id, 
                                                          event   = "OnPushed",
                                                          Owner   = Obj.Owner,
                                                          ObjPtr  = Obj,
                                                          display = w.HWId,
                                                          name    = Obj.oName })
                                EndIf
                            EndIf
                        EndIf
                EndSwitch
            EndIf
            
            
            
            
            
            
            
            
        ; -------------------------------------------------------| SWITCH |---
        Case #IFOCLASS_SWITCH
            ; ACTIONS
            ; > OnChanged : Every time the switch change its value
            ; ________________________________________________________________
            If Obj.Enabled = #IFO_ENABLED And Obj.Visible = #IFO_VISIBLE
                Switch msg.action 
                    Case "OnMouseOver"                  
                        Obj.Status = #IFOSTATUS_HILIGHTED
                        If Obj.Value = 0 Then scui.RenderObject(msg.id)
                    Case "OnMouseOut"
                        Obj.Status = #IFOSTATUS_NORMAL
                        If Obj.Value = 0 Then scui.RenderObject(msg.id)
                    Case "OnMouseDown"
                        If Obj.Status = #IFOSTATUS_HILIGHTED
                            Obj.Status = #IFOSTATUS_PUSHED
                            scui.RenderObject(msg.id)
                        EndIf
                    Case "OnMouseUp"
                        If Obj.Value = 0
                            ; Switch Change: UP --> DOWN
                            Obj.Value = 1
                            Obj.Status = #IFOSTATUS_HILIGHTED
                            scui.RenderObject(msg.id)
                            ; Is this a CHILD?                            
                            If helpers.FieldIsNil(Obj, "oparent")=0
                                Local Parent = Obj.oParent
                                Local ParentMsg = { id       = Parent,
                                                    action   = "OnChanged",
                                                    callfrom = msg.id,
                                                    event    = "UP->DOWN",
                                                    display  = msg.Display }
                                If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
                                scui.HandleObject(ParentMsg)
                            Else
                                ; Event Handle
                                If helpers.FieldIsNil(Obj.Actions, "onchanged")=0 Then Obj.Actions.OnChanged({id=msg.id, event="OnChanged", type="Down"})
                            EndIf
                            
                        ElseIf Obj.Value = 1
                            ; Swicth Change: DOWN --> UP
                                Obj.Value = 0
                                Obj.Status = #IFOSTATUS_HILIGHTED
                                scui.RenderObject(msg.id)
                            ; Is this a CHILD?
                            If helpers.FieldIsNil(Obj, "oparent")=0
                                Local Parent = Obj.oParent
                                Local ParentMsg = { id       = Parent,
                                                    action   = "OnChanged",
                                                    callfrom = msg.id,
                                                    event    = "DOWN->UP",
                                                    display  = msg.Display }
                                If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
                                scui.HandleObject(ParentMsg)
                                
                            Else
                                ; Not a child

                                ; Event Handler
                                If helpers.FieldIsNil(Obj.Actions, "onchanged")=0 Then Obj.Actions.OnChanged({id=msg.id, event="OnChanged", type="Up"})
                            EndIf
                        EndIf
                EndSwitch
            EndIf
        ; ---------------------------------------------------| STRING BOX |---
        Case #IFOCLASS_STRINGBOX
            ; ACTIONS
            ; > OnExit    : When we exit from the control (hitting RETURN)
            ; > OnChanged : When, upon exit, the starting value is changed
            ; ________________________________________________________________
            ; Se lo StringBox è attualmente attivo ignora completamente i suoi eventi
            ; ma tiene comunque traccia degli eventi MouseOut e Over per ripristinare
            ; il giusto aspetto all'uscita del controllo
            If scui.Keyboard[www.Name].Mode = #KEYBOARD_INPUTMODE And scui.Keyboard[www.Name].ActiveStringBox = msg.id
               If msg.action = "OnMouseOut"
                  scui.Keyboard[www.Name].StringBoxState = "OUT"
               ElseIf msg.action = "OnMouseOver"
                  scui.Keyboard[www.Name].StringBoxState = "IN"
               EndIf
               Return
            EndIf
            
            If Obj.Enabled = #IFO_ENABLED And Obj.Visible = #IFO_VISIBLE
                Switch msg.action
                    Case "OnMouseOver"
                        Obj.Status = #IFOSTATUS_HILIGHTED
                        scui.RenderObject(msg.id)
                    Case "OnMouseOut"
                        Obj.Status = #IFOSTATUS_NORMAL
                        scui.RenderObject(msg.id)
                    Case "OnMouseDown"
                        If Obj.Status = #IFOSTATUS_HILIGHTED
                            Obj.Status = #IFOSTATUS_PUSHED
                            scui.RenderObject(msg.id)
                        EndIf
                    Case "OnMouseUp"
                        If Obj.Status = #IFOSTATUS_PUSHED
                            Obj.Status = #IFOSTATUS_HILIGHTED
                            scui.RenderObject(msg.id)
                            Local objA = Obj.oData.Text.Area
                            Local objT = Obj.oData.Text.Content
                            Local objM = Obj.oData.Text.Margins
                            ; Launch the Input Handler
                            scui.Keyboard[www.Name].ActiveStringBox = msg.id
                            scui.Keyboard[www.Name].Mode = #KEYBOARD_INPUTMODE
                            scui.Keyboard[www.Name].StringBoxInfos = { Area      = { xStart = objA.xStart, yStart = objA.yStart,
                                                                           xEnd   = objA.xEnd,   yEnd   = objA.yEnd },
                                                             Value     = { Values = { objT.Values[0] }, Lines  = 1 },                                               
                                                             Margins   = { x = objM.x, y = objM.y }, 
                                                             MaxLen    = Obj.MaxLen, 
                                                             InputType = Obj.InputType,
                                                             Spec      = { FontName = Obj.oData.Text.FontName,
                                                                           FontSize = Obj.oData.Text.FontSize },
                                                             StartingText = ObjT.Values[0]
                                                            }
                            If Obj.InputType = #GETKEY_CUSTOM Then scui.Keyboard[www.Name].StringBoxInfos.CustomCharacters = Obj.CustomCharacters
                            
                            ; Lancia l'evento associato ad <OnClick>
                            If helpers.FieldIsNil(Obj.Actions, "onclick")=0 Then Obj.Actions.OnClick({id=msg.id, event="OnClick"})
                            
                            ; Forza l'attivazione inserendo un carattere speciale
                            scui.Keyboard[www.Name].StringBoxState = "IN"
                            scui.Keyboard_Handler({ key = "ACTIVATE", action = "OnKeyDown", id = msg.Display })
                        EndIf
                EndSwitch
            EndIf
        ; ----------------------------------------------| SIMPLE SCROLLER |---
        Case #IFOCLASS_SIMPLESCROLLER
            ; ACTIONS
            ; OnDrag   : Every time the Cursor is dragged
            ; OnChange : Every time the Scroller is moved
            ; ________________________________________________________________
            If Obj.Enabled = #IFO_ENABLED And Obj.Visible = #IFO_VISIBLE
                Switch msg.action
                    Case "OnMouseOver"
                        Obj.Status = #IFOSTATUS_HILIGHTED
                        scui.RenderObject(msg.id)

                    Case "OnMouseOut"
                        Obj.Status = #IFOSTATUS_NORMAL
                        scui.RenderObject(msg.id)
                    
                    Case "OnMouseDown"
                        If Obj.Status = #IFOSTATUS_HILIGHTED
                            ; User has clicked inside the scroller container
                            ; Check if he has clicked inside the cursor or not
                            Local LimitA = 0
                            Local LimitB = 0
                            Local MousePos
                            Local enddrag
                            Local MousePos2
                            Local StartingPos
                            Local DeltaPos
                            Local MoveStep
                            Local ModStep
                            Local CursorSize
                            Local CursorBlock
                            Local CursBottom
                            Local ContBottom
                            Local ttx
									 ; ATTENZIONE: Modifico a mano le coordinate del mouse nel  
									 ; caso in cui lo Scroller si trovi in una Virtual Area     
									 Local VA_OffsetX
									 Local VA_OffsetY
									 Local Master = scui.GetMasterParent(msg.id)
									 If helpers.IsNil(Master) = 0
										If scui.IFO[Master].oClass = #IFOCLASS_VIRTUALAREA
											VA_OffsetX = scui.IFO[Master].ViewPort.xStart - scui.IFO[Master].Offset.x
											VA_OffsetY = scui.IFO[Master].ViewPort.yStart - scui.IFO[Master].Offset.y
										EndIf
									EndIf
                            If Obj.Type = #SCROLLERTYPE_VERTICAL
                                MousePos = MouseY() - VA_OffsetY
                                LimitA   = LimitA + Obj.Cursor.yStart
                                LimitB   = LimitB + Obj.Cursor.yEnd
                            Else
                                MousePos = MouseX() - VA_OffsetX
                                LimitA   = LimitA + Obj.Cursor.xStart
                                LimitB   = LimitB + Obj.Cursor.xEnd
                            EndIf

                            If LimitA <= MousePos And MousePos <= LimitB
                                ; Click inside the scroller cursor
                                Obj.Status = #IFOSTATUS_PUSHED
                                ; Redraw the object (for pushed aspect)
                                scui.RenderObject(msg.id)
                                
                                ; Dragging Code Starts here
                                If Obj.Type = #SCROLLERTYPE_VERTICAL                                
                                    enddrag = 0 
                                    MousePos2 = MouseX(); + VA_OffsetX
                                    MousePos  = -999  
                                    StartingPos = MouseY() - VA_OffsetY                 
                                    While enddrag = 0             
                                        If IsLeftMouse()
                                            ; Dragging code                                        
                                            If (MouseY() - VA_OffsetY) <> (MousePos - VA_OffsetY)
                                                ; Limits vertical dragging
                                                If (MouseY() - VA_OffsetY) < Obj.oData.Container.Position.y + 1 Then MovePointer(MousePos2, Obj.oData.Container.Position.y + 1 + VA_OffsetY) 
                                                If (MouseY() - VA_OffsetY) > Obj.oData.Container.Position.y + Obj.oData.Container.Size.y - 1 Then MovePointer(MousePos2, Obj.oData.Container.Position.y + Obj.oData.Container.Size.y - 1 + VA_OffsetY)
                                                MousePos = MouseY(); - VA_OffsetY
                                                
                                                ; Lock horizontal mouse movements
                                                MovePointer(MousePos2, MousePos)
    
                                                ; Check if the user has dragged enough for a cursor movement
                                                DeltaPos = Abs((MouseY() - VA_OffsetY) - StartingPos)
                                                If DeltaPos > Obj.PixelUnit
                                                    ; Calculate the new cursor's position
                                                    MoveStep = Int(DeltaPos/Obj.PixelUnit)
                                                    ModStep = Mod(DeltaPos, Obj.PixelUnit)
                                                                                    
                                                    ; Check in which direction we have to move the cursor
                                                    If (MouseY() - VA_OffsetY) > StartingPos
                                                        ; Moving Down
                                                        Obj.Values.Current = Obj.Values.Current + MoveStep
                                                        If Obj.Values.Current > Obj.Values.MMax Then Obj.Values.Current = Obj.Values.MMax
                                                        StartingPos = (MouseY() - VA_OffsetY) - ModStep
                                                    Else
                                                        ; Moving Up
                                                        Obj.Values.Current = Obj.Values.Current - MoveStep
                                                        If Obj.Values.Current < Obj.Values.MMin Then Obj.Values.Current = Obj.Values.MMin
                                                        StartingPos = (MouseY() - VA_OffsetY) + ModStep    
                                                    EndIf
    
                                                    ; Redefine the cursor position
                                                    CursSize = IIF( Obj.PixelUnit >= scui.theme.SScroller_MinCursorSize, Obj.PixelUnit, scui.theme.SScroller_MinCursorSize )
                                                    CursorBlock = { Position = { x = Obj.oData.Cursor.Position.x,
                                                                                 y = Obj.oData.Container.Position.y + Obj.CursorOffset + (Obj.Values.Current - Obj.Values.MMin) * Obj.PixelUnit },
                                                                    Size     = { x = Obj.oData.Cursor.Size.x, 
                                                                                 y = CursSize } }
                                                    ; Check that the cursor don't falls over the container
                                                    CursBottom = CursorBlock.Position.y + CursorBlock.Size.y
                                                    ContBottom = Obj.oData.Container.Position.y + Obj.oData.Container.Size.y - Obj.CursorOffset
                                                    If CursBottom > ContBottom
                                                        ; Over Limit! Correcting...
                                                        Delta = CursBottom - ContBottom
                                                        CursorBlock.Position.y = CursorBlock.Position.y - Delta 
                                                    EndIf                                                  
                                                    ; Redefine the cursor and its various aspects
                                                    Obj.oData.Cursor = scui.NewBevel(Obj.oData.Cursor, CursorBlock)
                                                    Obj.oData.HCursor = scui.NewBevel(Obj.oData.HCursor, CursorBlock)
                                                    Obj.oData.PCursor = scui.NewBevel(Obj.oData.PCursor, CursorBlock) 
                                                    Obj.Cursor = { xStart = CursorBlock.Position.x, yStart = CursorBlock.Position.y,
                                                                                xEnd = CursorBlock.Position.x + CursorBlock.Size.x, 
                                                                                yEnd = CursorBlock.Position.y + CursorBlock.Size.y}
                                                    ; Recalculate and draw the text inside the cursor
; ****************************************************************************
; * FEATURE ADD: During Dragging this text could be the current scroller     *
; *              value                                                       *
; ****************************************************************************                                                    
                                                    Local mul = 1
                                                    If Obj.oData.Cursor.Type = #BEVELTYPE_SUNKEN Then mul = 2
                                                    ttx = { Content = { Values = Obj.oData.Text.Content.Values,
                                                                        Lines  = Obj.oData.Text.Content.Lines },
                                                            Margins = { x = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder, 
                                                                        y = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder },
                                                            Area    = { xStart = CursorBlock.Position.x, 
                                                                        yStart = CursorBlock.Position.y,
                                                                        xEnd   = CursorBlock.Position.x + CursorBlock.Size.x,
                                                                        yEnd   = CursorBlock.Position.y + CursorBlock.Size.y } }
                                                    Obj.oData.Text = scui.NewText(Obj.oData.Text, ttx)
                                                    Obj.oData.HText = scui.NewText(Obj.oData.HText, ttx)
                                                    Obj.oData.PText = scui.NewText(Obj.oData.PText, ttx)    
                                                    ; Redraw the updated object
                                                    scui.RenderObject(msg.id)
                                                    ; Event Handler
                                                    ; It's a child?
                                                    If helpers.FieldIsNil(Obj, "oparent")=0
                                                        Local Parent = Obj.oParent
                                                        Local ParentMsg = { id       = Parent,
                                                                            action   = "OnScrollerChange",
                                                                            callfrom = msg.id,
                                                                            event    = "Drag",
                                                                            current  = Obj.Values.Current,
                                                                            display  = msg.Display }
                                                        If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
                                                        scui.HandleObject(ParentMsg)
                                                    EndIf
                                                    
                                                    If helpers.FieldIsNil(Obj.Actions, "ondrag")=0 Then Obj.Actions.OnDrag({id=msg.id, event="OnDrag"})
                                                EndIf
                                                
                                            Else
                                                ; Force the horizontal coordinate
                                                ; MovePointer(MousePos2, MousePos)
                                            EndIf        
                                        
                                        Else
                                            ; End dragging
                                            enddrag = 1
                                        EndIf
                                    Wend
                                Else
                                ; HORIZONTAL SCROLLER
                                    enddrag = 0 
                                    MousePos2 = MouseY() ;- VA_OffsetY)  
                                    MousePos  = -999  
                                    StartingPos = MouseX() - VA_OffsetX

                                    While enddrag = 0             
                                        If IsLeftMouse()
                                            ; Dragging code                                        
                                            If (MouseX() - VA_OffsetX) <> MousePos
                                                ; Limits the mouse vertical mevements
                                                If (MouseX() - VA_OffsetX) < Obj.oData.Container.Position.x + 1 Then MovePointer(Obj.oData.Container.Position.x + 1 + VA_OffsetX, MousePos2) 
                                                If (MouseX() - VA_OffsetX) > Obj.oData.Container.Position.x + Obj.oData.Container.Size.x - 1 Then MovePointer(Obj.oData.Container.Position.x + Obj.oData.Container.Size.x - 1 + VA_OffsetX, MousePos2)
                                                MousePos = MouseX() ;- VA_OffsetX)
                                                
                                                ; Lock the mouse horizontal movements
                                                MovePointer(MousePos, MousePos2)
    
                                                ; Check if the mouse has moved enough for a cursor movement
                                                DeltaPos = Abs((MouseX() - VA_OffsetX) - StartingPos)
                                                If DeltaPos > Obj.PixelUnit
                                                    ; Calculate the new position of the cursor
                                                    MoveStep = Int(DeltaPos/Obj.PixelUnit)
                                                    ModStep = Mod(DeltaPos, Obj.PixelUnit)
                                                                                    
                                                    ; Check in which direction we have to move the cursor
                                                    If (MouseX() - VA_OffsetX) > StartingPos
                                                        ; Right
                                                        Obj.Values.Current = Obj.Values.Current + MoveStep
                                                        If Obj.Values.Current > Obj.Values.MMax Then Obj.Values.Current = Obj.Values.MMax
                                                        StartingPos = (MouseX() - VA_OffsetX) - ModStep
                                                    Else
                                                        ; Left
                                                        Obj.Values.Current = Obj.Values.Current - MoveStep
                                                        If Obj.Values.Current < Obj.Values.MMin Then Obj.Values.Current = Obj.Values.MMin
                                                        StartingPos = (MouseX() - VA_OffsetX) + ModStep    
                                                    EndIf
    
                                                    ; Redefine the cursor at the new position
                                                    CursSize = IIF( Obj.PixelUnit >= scui.theme.SScroller_MinCursorSize, Obj.PixelUnit, scui.theme.SScroller_MinCursorSize )
                                                    CursorBlock = { Position = { x = Obj.oData.Container.Position.x  + Obj.CursorOffset + (Obj.Values.Current - Obj.Values.MMin) * Obj.PixelUnit,
                                                                                 y = Obj.oData.Cursor.Position.y },
                                                                    Size     = { x = CursSize, 
                                                                                 y = Obj.oData.Cursor.Size.y } }
                                                    ; Check that the cursor will not falls over the container
                                                    CursBottom = CursorBlock.Position.x + CursorBlock.Size.x
                                                    ContBottom = Obj.oData.Container.Position.x + Obj.oData.Container.Size.x - Obj.CursorOffset
                                                    If CursBottom > ContBottom
                                                        ; Limits passed! Correcting...
                                                        Delta = CursBottom - ContBottom
                                                        CursorBlock.Position.x = CursorBlock.Position.x - Delta 
                                                    EndIf                                                  
                                                    ; Recreate the cursor and its variants
                                                    Obj.oData.Cursor = scui.NewBevel(Obj.oData.Cursor, CursorBlock)
                                                    Obj.oData.HCursor = scui.NewBevel(Obj.oData.HCursor, CursorBlock)
                                                    Obj.oData.PCursor = scui.NewBevel(Obj.oData.PCursor, CursorBlock) 
                                                    Obj.Cursor = { xStart = CursorBlock.Position.x, yStart = CursorBlock.Position.y,
                                                                                xEnd = CursorBlock.Position.x + CursorBlock.Size.x, 
                                                                                yEnd = CursorBlock.Position.y + CursorBlock.Size.y}
                                                    ; Handle the text inside the cursor 
                                                    Local mul = 1
                                                    If Obj.oData.Cursor.Type = #BEVELTYPE_SUNKEN Then mul = 2
                                                    ttx = { Content = { Values = Obj.oData.Text.Content.Values,
                                                                        Lines  = Obj.oData.Text.Content.Lines },
                                                            Margins = { x = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder, 
                                                                        y = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder },
                                                            Area    = { xStart = CursorBlock.Position.x, 
                                                                        yStart = CursorBlock.Position.y,
                                                                        xEnd   = CursorBlock.Position.x + CursorBlock.Size.x,
                                                                        yEnd   = CursorBlock.Position.y + CursorBlock.Size.y } }
                                                    Obj.oData.Text = scui.NewText(Obj.oData.Text, ttx)
                                                    Obj.oData.HText = scui.NewText(Obj.oData.HText, ttx)
                                                    Obj.oData.PText = scui.NewText(Obj.oData.PText, ttx)    
                                                    ; Draw the updated object
                                                    scui.RenderObject(msg.id)
                                                    ; Event Handler
                                                    ; Check if this object is a child
                                                    If helpers.FieldIsNil(Obj, "oparent")=0
                                                        Local Parent = Obj.oParent
                                                        Local ParentMsg = { id       = Parent,
                                                                            action   = "OnScrollerChange",
                                                                            callfrom = msg.id,
                                                                            event    = "Drag",
                                                                            current  = Obj.Values.Current,
                                                                            display  = msg.Display }
                                                        If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
                                                        scui.HandleObject(ParentMsg)
                                                    EndIf
                                                    
                                                    If helpers.FieldIsNil(Obj.Actions, "ondrag")=0 Then Obj.Actions.OnDrag({id=msg.id, event="OnDrag"}) 
                                                EndIf
                                                
                                            Else
                                                ; Force the x coordinate
                                                ; MovePointer(MousePos, MousePos2)
                                            EndIf        
                                        
                                        Else
                                            ; End dragging
                                            enddrag = 1     
                                        EndIf
                                    Wend
                                EndIf
                                
                            ElseIf Obj.Type = #SCROLLERTYPE_VERTICAL
                                If Obj.Cursor.yStart > MousePos
                                    ; The user has clicked above the cursor, decrease the scroller value
                                    Obj.Values.Current = Obj.Values.Current - Obj.Values.MinStep
                                    If Obj.Values.Current < Obj.Values.MMin Then Obj.Values.Current = Obj.Values.MMin
                                        ; Define the cursor
                                        CursSize = IIF( Obj.PixelUnit >= scui.theme.SScroller_MinCursorSize, Obj.PixelUnit, scui.theme.SScroller_MinCursorSize )
                                        CursorBlock = { Position = { x = Obj.oData.Cursor.Position.x,
                                                                     y = Obj.oData.Container.Position.y + Obj.CursorOffset + (Obj.Values.Current - Obj.Values.MMin) * Obj.PixelUnit },
                                                        Size     = { x = Obj.oData.Cursor.Size.x, 
                                                                     y = CursSize } }
                                        ; Check container limits with the cursor
                                        CursBottom = CursorBlock.Position.y + CursorBlock.Size.y
                                        ContBottom = Obj.oData.Container.Position.y + Obj.oData.Container.Size.y - Obj.CursorOffset
                                        If CursBottom > ContBottom
                                            ; Limits passed! Correcting...
                                            Delta = CursBottom - ContBottom
                                            CursorBlock.Position.y = CursorBlock.Position.y - Delta 
                                        EndIf                                                  
                                                                     
                                        ; Create the cursor and its variants
                                        Obj.oData.Cursor = scui.NewBevel(Obj.oData.Cursor, CursorBlock)
                                        Obj.oData.HCursor = scui.NewBevel(Obj.oData.HCursor, CursorBlock)
                                        Obj.oData.PCursor = scui.NewBevel(Obj.oData.PCursor, CursorBlock) 
                                        Obj.Cursor = { xStart = CursorBlock.Position.x, yStart = CursorBlock.Position.y,
                                                                    xEnd = CursorBlock.Position.x + CursorBlock.Size.x, 
                                                                    yEnd = CursorBlock.Position.y + CursorBlock.Size.y}                      
                                        ; Handle the text inside the cursor
                                        Local mul = 1
                                        If Obj.oData.Cursor.Type = #BEVELTYPE_SUNKEN Then mul = 2
                                        ttx = { Content = { Values = Obj.oData.Text.Content.Values,
                                                            Lines  = Obj.oData.Text.Content.Lines },
                                                Margins = { x = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder, 
                                                            y = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder },
                                                Area    = { xStart = CursorBlock.Position.x, 
                                                            yStart = CursorBlock.Position.y,
                                                            xEnd   = CursorBlock.Position.x + CursorBlock.Size.x,
                                                            yEnd   = CursorBlock.Position.y + CursorBlock.Size.y } }
                                        Obj.oData.Text = scui.NewText(Obj.oData.Text, ttx)
                                        Obj.oData.HText = scui.NewText(Obj.oData.HText, ttx)
                                        Obj.oData.PText = scui.NewText(Obj.oData.PText, ttx)    
                                        
                                        ; Draw the updated object
                                        ; Check if this is a child object
                                        If helpers.FieldIsNil(Obj, "oparent")=0
                                            Local Parent = Obj.oParent
                                            Local ParentMsg = { id       = Parent,
                                                                action   = "OnScrollerChange",
                                                                callfrom = msg.id,
                                                                event    = "Click",
                                                                current  = Obj.Values.Current,
                                                                display  = msg.Display }
                                            If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
                                            scui.HandleObject(ParentMsg)
                                        EndIf
                                        
                                        scui.RenderObject(msg.id)                                
                                Else
                                    ; The user has clicked below the cursor, increase the scroller value
                                    Obj.Values.Current = Obj.Values.Current + Obj.Values.MinStep
                                    If Obj.Values.Current > Obj.Values.MMax Then Obj.Values.Current = Obj.Values.MMax
                                        ; Define the cursor
                                        CursSize = IIF( Obj.PixelUnit >= scui.theme.SScroller_MinCursorSize, Obj.PixelUnit, scui.theme.SScroller_MinCursorSize )
                                        CursorBlock = { Position = { x = Obj.oData.Cursor.Position.x,
                                                                     y = Obj.oData.Container.Position.y + Obj.CursorOffset + (Obj.Values.Current - Obj.Values.MMin) * Obj.PixelUnit },
                                                        Size     = { x = Obj.oData.Cursor.Size.x, 
                                                                     y = CursSize } }
                                        ; Check container limits against the cursor
                                        CursBottom = CursorBlock.Position.y + CursorBlock.Size.y
                                        ContBottom = Obj.oData.Container.Position.y + Obj.oData.Container.Size.y - Obj.CursorOffset
                                        If CursBottom > ContBottom
                                            ; Limits broken! Correcting...
                                            Delta = CursBottom - ContBottom
                                            CursorBlock.Position.y = CursorBlock.Position.y - Delta 
                                        EndIf                                                  
                                                                     
                                        ; Rebuild the cursor and its variants
                                        Obj.oData.Cursor = scui.NewBevel(Obj.oData.Cursor, CursorBlock)
                                        Obj.oData.HCursor = scui.NewBevel(Obj.oData.HCursor, CursorBlock)
                                        Obj.oData.PCursor = scui.NewBevel(Obj.oData.PCursor, CursorBlock) 
                                        Obj.Cursor = { xStart = CursorBlock.Position.x, yStart = CursorBlock.Position.y,
                                                                    xEnd = CursorBlock.Position.x + CursorBlock.Size.x, 
                                                                    yEnd = CursorBlock.Position.y + CursorBlock.Size.y}                      
                                        ; Handle the text inside the cursor
                                        Local mul = 1
                                        If Obj.oData.Cursor.Type = #BEVELTYPE_SUNKEN Then mul = 2
                                        ttx = { Content = { Values = Obj.oData.Text.Content.Values,
                                                            Lines  = Obj.oData.Text.Content.Lines },
                                                Margins = { x = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder, 
                                                            y = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder },
                                                Area    = { xStart = CursorBlock.Position.x, 
                                                            yStart = CursorBlock.Position.y,
                                                            xEnd   = CursorBlock.Position.x + CursorBlock.Size.x,
                                                            yEnd   = CursorBlock.Position.y + CursorBlock.Size.y } }
                                        Obj.oData.Text = scui.NewText(Obj.oData.Text, ttx)
                                        Obj.oData.HText = scui.NewText(Obj.oData.HText, ttx)
                                        Obj.oData.PText = scui.NewText(Obj.oData.PText, ttx)    
                                        
                                        ; Draw the updated object
                                        ; Check if this is a child object
                                        If helpers.FieldIsNil(Obj, "oparent")=0
                                            Local Parent = Obj.oParent
                                            Local ParentMsg = { id       = Parent,
                                                                action   = "OnScrollerChange",
                                                                callfrom = msg.id,
                                                                event    = "Click",
                                                                current  = Obj.Values.Current,
                                                                display  = msg.Display }
                                            If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
                                            scui.HandleObject(ParentMsg)
                                        EndIf
                                        
                                        scui.RenderObject(msg.id)                                
                                EndIf
                            Else
                                ; HORIZONTAL
                                
                                If Obj.Cursor.xStart > MousePos
                                    ; Click a sinistra del cursore, decremento il valore dello scroller
                                    Obj.Values.Current = Obj.Values.Current - Obj.Values.MinStep
                                    If Obj.Values.Current < Obj.Values.MMin Then Obj.Values.Current = Obj.Values.MMin
                                        ; Definisco il nuovo cursore
                                        CursSize = IIF( Obj.PixelUnit >= scui.theme.SScroller_MinCursorSize, Obj.PixelUnit, scui.theme.SScroller_MinCursorSize )
                                        CursorBlock = { Position = { x = Obj.oData.Container.Position.x + Obj.CursorOffset + (Obj.Values.Current - Obj.Values.MMin) * Obj.PixelUnit,
                                                                     y = Obj.oData.Cursor.Position.y },
                                                        Size     = { x = CursSize, 
                                                                     y = Obj.oData.Cursor.Size.y } }
                                        ; Verifico che non superi il bordo del contenitore
                                        CursBottom = CursorBlock.Position.x + CursorBlock.Size.x
                                        ContBottom = Obj.oData.Container.Position.x + Obj.oData.Container.Size.x - Obj.CursorOffset
                                        If CursBottom > ContBottom
                                            ; Bordo Superato! Rettifico
                                            Delta = CursBottom - ContBottom
                                            CursorBlock.Position.x = CursorBlock.Position.x - Delta 
                                        EndIf                                                  
                                                                     
                                        ; Ricreo il cursore e le sue varianti
                                        Obj.oData.Cursor = scui.NewBevel(Obj.oData.Cursor, CursorBlock)
                                        Obj.oData.HCursor = scui.NewBevel(Obj.oData.HCursor, CursorBlock)
                                        Obj.oData.PCursor = scui.NewBevel(Obj.oData.PCursor, CursorBlock) 
                                        Obj.Cursor = { xStart = CursorBlock.Position.x, yStart = CursorBlock.Position.y,
                                                                    xEnd = CursorBlock.Position.x + CursorBlock.Size.x, 
                                                                    yEnd = CursorBlock.Position.y + CursorBlock.Size.y}                      
                                        ; **** TEXT INSIDE CURSOR ****
                                        Local mul = 1
                                        If Obj.oData.Cursor.Type = #BEVELTYPE_SUNKEN Then mul = 2
                                        ttx = { Content = { Values = Obj.oData.Text.Content.Values,
                                                            Lines  = Obj.oData.Text.Content.Lines },
                                                Margins = { x = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder, 
                                                            y = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder },
                                                Area    = { xStart = CursorBlock.Position.x, 
                                                            yStart = CursorBlock.Position.y,
                                                            xEnd   = CursorBlock.Position.x + CursorBlock.Size.x,
                                                            yEnd   = CursorBlock.Position.y + CursorBlock.Size.y } }
                                        Obj.oData.Text = scui.NewText(Obj.oData.Text, ttx)
                                        Obj.oData.HText = scui.NewText(Obj.oData.HText, ttx)
                                        Obj.oData.PText = scui.NewText(Obj.oData.PText, ttx)    
                                        
                                        ; Traccio l'oggetto aggiornato
                                        ; GESTIONE SCROLLER FIGLIO
                                        If helpers.FieldIsNil(Obj, "oparent")=0
                                            Local Parent = Obj.oParent
                                            Local ParentMsg = { id       = Parent,
                                                                action   = "OnScrollerChange",
                                                                callfrom = msg.id,
                                                                event    = "Click",
                                                                current  = Obj.Values.Current,
                                                                display  = msg.Display }
                                            If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
                                            scui.HandleObject(ParentMsg)
                                        EndIf
                                        
                                        scui.RenderObject(msg.id)                                
                                Else
                                    ; Click a destra del cursore, incremento il valore dello scroller
                                    Obj.Values.Current = Obj.Values.Current + Obj.Values.MinStep
                                    If Obj.Values.Current > Obj.Values.MMax Then Obj.Values.Current = Obj.Values.MMax
                                        ; Definisco il nuovo cursore
                                        CursSize = IIF( Obj.PixelUnit >= scui.theme.SScroller_MinCursorSize, Obj.PixelUnit, scui.theme.SScroller_MinCursorSize )
                                        CursorBlock = { Position = { x = Obj.oData.Container.Position.x + Obj.CursorOffset + (Obj.Values.Current - Obj.Values.MMin) * Obj.PixelUnit,
                                                                     y = Obj.oData.Cursor.Position.y },
                                                        Size     = { x = CursSize, 
                                                                     y = Obj.oData.Cursor.Size.y } }
                                        ; Verifico che non superi il bordo del contenitore
                                        CursBottom = CursorBlock.Position.x + CursorBlock.Size.x
                                        ContBottom = Obj.oData.Container.Position.x + Obj.oData.Container.Size.x - Obj.CursorOffset
                                        If CursBottom > ContBottom
                                            ; Bordo Superato! Rettifico
                                            Delta = CursBottom - ContBottom
                                            CursorBlock.Position.x = CursorBlock.Position.x - Delta 
                                        EndIf                                                  
                                                                     
                                        ; Ricreo il cursore e le sue varianti
                                        Obj.oData.Cursor = scui.NewBevel(Obj.oData.Cursor, CursorBlock)
                                        Obj.oData.HCursor = scui.NewBevel(Obj.oData.HCursor, CursorBlock)
                                        Obj.oData.PCursor = scui.NewBevel(Obj.oData.PCursor, CursorBlock) 
                                        Obj.Cursor = { xStart = CursorBlock.Position.x, yStart = CursorBlock.Position.y,
                                                                    xEnd = CursorBlock.Position.x + CursorBlock.Size.x, 
                                                                    yEnd = CursorBlock.Position.y + CursorBlock.Size.y}                      
                                        ; **** TEXT INSIDE CURSOR ****
                                        Local mul = 1
                                        If Obj.oData.Cursor.Type = #BEVELTYPE_SUNKEN Then mul = 2
                                        ttx = { Content = { Values = Obj.oData.Text.Content.Values,
                                                            Lines  = Obj.oData.Text.Content.Lines },
                                                Margins = { x = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder, 
                                                            y = Obj.oData.Cursor.Height * mul + scui.theme.TextBorder },
                                                Area    = { xStart = CursorBlock.Position.x, 
                                                            yStart = CursorBlock.Position.y,
                                                            xEnd   = CursorBlock.Position.x + CursorBlock.Size.x,
                                                            yEnd   = CursorBlock.Position.y + CursorBlock.Size.y } }
                                        Obj.oData.Text = scui.NewText(Obj.oData.Text, ttx)
                                        Obj.oData.HText = scui.NewText(Obj.oData.HText, ttx)
                                        Obj.oData.PText = scui.NewText(Obj.oData.PText, ttx)    
                                        
                                        ; Traccio l'oggetto aggiornato
                                        ; GESTIONE SCROLLER FIGLIO
                                        If helpers.FieldIsNil(Obj, "oparent")=0
                                            Local Parent = Obj.oParent
                                            Local ParentMsg = { id       = Parent,
                                                                action   = "OnScrollerChange",
                                                                callfrom = msg.id,
                                                                event    = "Click",
                                                                current  = Obj.Values.Current,
                                                                display  = msg.Display }
                                            If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
                                            scui.HandleObject(ParentMsg)
                                        EndIf
                                        
                                        scui.RenderObject(msg.id)                         
                                EndIf
                                
                            EndIf
                            scui.RenderObject(msg.id)
                        EndIf
                    Case "OnMouseUp"
                        If Obj.Status = #IFOSTATUS_PUSHED Or Obj.Status = #IFOSTATUS_HILIGHTED
                            Obj.Status = #IFOSTATUS_HILIGHTED
                            scui.RenderObject(msg.id)
                            ; Event Handler
                            If helpers.FieldIsNil(Obj.Actions, "onchange")=0 Then Obj.Actions.OnChange({id=msg.id, event="OnChange"}) 
                        EndIf
                EndSwitch
            EndIf   
        ; -----------------------------------------------------| SCROLLER |---
        Case #IFOCLASS_SCROLLER
            ; ACTIONS
            ; OnDrag   : Every time the Cursor is dragged
            ; OnChange : Every time the Scroller is moved
            ; ________________________________________________________________
            
            /* Verifica se e' stata premuta una freccia */
            If helpers.FieldIsNil(msg, "callfrom") = 0
               If msg.Callfrom = Obj.Childs[1]
                  /* MINUS ARROW PREMUTA */
                  If Obj.FirstItem = 0 Then Return
                  Obj.FirstItem = Obj.FirstItem - Obj.ArrowStep
                  If Obj.FirstItem < 0 Then Obj.FirstItem = 0
                  
               Else
                  /* PLUS ARROW PREMUTA */
                  If Obj.FirstItem = Obj.TotalItems - Obj.VisibleItems Then Return
                  Obj.FirstItem = Obj.FirstItem + Obj.ArrowStep
                  If Obj.FirstItem > Obj.TotalItems - Obj.VisibleItems Then Obj.FirstItem = Obj.TotalItems - Obj.VisibleItems

               EndIf
               
               Local currPos = Obj.CursPos
               Local newPos  = Int(Obj.FirstItem * Obj.PixPerItem)
					Local diff    = newPos - currPos

					; Effettuo il cambiamento solo se il cursore viene realmente spostato
					If diff <> 0
	               ; Spostamento relativo del cursore
	               If Obj.Type = #SCROLLERTYPE_VERTICAL
	                  scui.MoveBevel(Obj.oData.Cursor, 0, diff, 1)
	                  scui.MoveBevel(Obj.oData.hCursor, 0, diff, 1)
	                  scui.MoveBevel(Obj.oData.pCursor, 0, diff, 1)
	                  scui.MoveBevel(Obj.oData.dCursor, 0, diff, 1)
	                  scui.MoveText(Obj.oData.Text, 0, diff, 1)
	                  scui.MoveText(Obj.oData.hText, 0, diff, 1)
	                  scui.MoveText(Obj.oData.pText, 0, diff, 1)
	                  scui.MoveText(Obj.oData.dText, 0, diff, 1)
	               Else
	                  scui.MoveBevel(Obj.oData.Cursor, diff, 0, 1)
	                  scui.MoveBevel(Obj.oData.hCursor, diff, 0, 1)
	                  scui.MoveBevel(Obj.oData.pCursor, diff, 0, 1)
	                  scui.MoveBevel(Obj.oData.dCursor, diff, 0, 1)
	                  scui.MoveText(Obj.oData.Text, diff, 0, 1)
	                  scui.MoveText(Obj.oData.hText, diff, 0, 1)
	                  scui.MoveText(Obj.oData.pText, diff, 0, 1)
	                  scui.MoveText(Obj.oData.dText, diff, 0, 1)
	               EndIf
	               
	               ; Aggiorna nuova posizione cursore e ridisegna l'oggetto
	               Obj.CursPos = newPos
						
						; Verifica se lo Scroller e' un child di qualche altro oggetto
						If helpers.FieldIsNil(Obj, "oparent") = 0
						  Local Parent = Obj.oParent
						  Local ParentMsg = { id       = Parent,
													 action   = "OnScrollerChange",
													 callfrom = msg.id,
													 event    = "Click",
													 current  = Int(Obj.FirstItem),
                                        display  = msg.Display }
						  If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
						  scui.HandleObject(ParentMsg)
						EndIf

	               scui.RenderObject(msg.id)
						
						; Esegue l'eventuale evento <OnChange> associato
	               If helpers.FieldIsNil(Obj.Actions, "onchange") = 0 Then Obj.Actions.OnChange({id=msg.id, event="OnChange", value=Obj.FirstItem}) 
					EndIf
               Return
            EndIf
            
            If Obj.Enabled = #IFO_ENABLED And Obj.Visible = #IFO_VISIBLE
                Switch msg.action
                    Case "OnMouseOver"
                        Obj.Status = #IFOSTATUS_HILIGHTED
                        scui.RenderObject(msg.id)

                    Case "OnMouseOut"
                        Obj.Status = #IFOSTATUS_NORMAL
                        scui.RenderObject(msg.id)
                    
                    Case "OnMouseDown"
                        If Obj.Status = #IFOSTATUS_HILIGHTED
                            /* L'UTENTE HA CLICCATO NELL'AREA DEL CURSORE */
                            ; Stabilisco se e' stato premuto il mouse sopra
                            ; il cursore oppure no.
                            Local MousePos = { x = MouseX(), y = MouseY() }
                            Local StartMouse = { x = MouseX(), y = MouseY() }
                            Local Cursor = { xs = Obj.oData.Cursor.Position.x,
                                             ys = Obj.oData.Cursor.Position.y,
                                             xe = Obj.oData.Cursor.Position.x + Obj.oData.Cursor.Size.x,
                                             ye = Obj.oData.Cursor.Position.y + Obj.oData.Cursor.Size.y }
                            If (Cursor.xs <= MousePos.x) And (MousePos.x <= Cursor.xe)
                               If (Cursor.ys <= MousePos.y) And (MousePos.y <= Cursor.ye)
                                  ; === INSIDE CURSOR'S CLICK ===
                                  ; Starts the dragging loop
                                  Local FirstItem = Obj.FirstItem
                                  scui.IFO[msg.id].Status = #IFOSTATUS_PUSHED
                                  scui.RenderObject(msg.id)
                                  While IsLeftMouse()
                                     Local NewPos = { x = MouseX(), y = MouseY() }
                                     Local Delta  = { x = NewPos.x - MousePos.x, y = NewPos.y - MousePos.y }
                                     Local Moved  = False
                                     If Obj.Type = #SCROLLERTYPE_VERTICAL
                                        If Delta.y <> 0
                                           Local MovedItems = (Delta.y / Obj.PixPerItem)
                                           Obj.FirstItem = Obj.FirstItem + MovedItems
                                           If Obj.FirstItem < 0 Then Obj.FirstItem = 0
                                           If Obj.FirstItem > (Obj.TotalItems - Obj.VisibleItems) Then Obj.FirstItem = Obj.TotalItems - Obj.VisibleItems
                                           Moved = True
                                        EndIf
                                     Else
                                        If Delta.x <> 0
                                           Local MovedItems = (Delta.x / Obj.PixPerItem)
                                           Obj.FirstItem = Obj.FirstItem + MovedItems
                                           If Obj.FirstItem < 0 Then Obj.FirstItem = 0
                                           If Obj.FirstItem > (Obj.TotalItems - Obj.VisibleItems) Then Obj.FirstItem = Obj.TotalItems - Obj.VisibleItems
                                           Moved = True
                                        EndIf
                                     EndIf
                                     If Moved
                                        ; Recalc cursor position
                                       Local currPos = Obj.CursPos
                                       Local newPos  = Obj.FirstItem * Obj.PixPerItem
													Local diff = newPos - currPos

													If diff <> 0
	                                       ; Spostamento relativo del cursore
	                                       If Obj.Type = #SCROLLERTYPE_VERTICAL
	                                          StartMouse.y = StartMouse.y + newPos - currPos
	                                          MovePointer(MouseX(), StartMouse.y )
	                                          MousePos.y = MouseY()
	                                          
	                                          scui.MoveBevel(Obj.oData.Cursor, 0, diff, 1)
	                                          scui.MoveBevel(Obj.oData.hCursor, 0, diff, 1)
	                                          scui.MoveBevel(Obj.oData.pCursor, 0, diff, 1)
	                                          scui.MoveBevel(Obj.oData.dCursor, 0, diff, 1)
	                                          scui.MoveText(Obj.oData.Text, 0, diff, 1)
	                                          scui.MoveText(Obj.oData.hText, 0, diff, 1)
	                                          scui.MoveText(Obj.oData.pText, 0, diff, 1)
	                                          scui.MoveText(Obj.oData.dText, 0, diff, 1)
	                                       Else
	                                          StartMouse.x = StartMouse.x + newPos - currPos
	                                          MovePointer(StartMouse.x, MouseY())
	                                          MousePos.x = MouseX()

	                                          scui.MoveBevel(Obj.oData.Cursor, diff, 0, 1)
	                                          scui.MoveBevel(Obj.oData.hCursor, diff, 0, 1)
	                                          scui.MoveBevel(Obj.oData.pCursor, diff, 0, 1)
	                                          scui.MoveBevel(Obj.oData.dCursor, diff, 0, 1)
	                                          scui.MoveText(Obj.oData.Text, diff, 0, 1)
	                                          scui.MoveText(Obj.oData.hText, diff, 0, 1)
	                                          scui.MoveText(Obj.oData.pText, diff, 0, 1)
	                                          scui.MoveText(Obj.oData.dText, diff, 0, 1)
	                                       EndIf
	                                       Obj.CursPos = newPos
	                                       scui.RenderObject(msg.id)
														
														; Check if this object is a child
														If helpers.FieldIsNil(Obj, "oparent")=0
														   Local Parent = Obj.oParent
														   Local ParentMsg = { id       = Parent,
														 							 action   = "OnScrollerChange",
																					 callfrom = msg.id,
																					 event    = "Drag",
																					 current  = Int(Obj.FirstItem),
                                                                display  = msg.Display }
														   If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
															  scui.HandleObject(ParentMsg)
														EndIf
														 
														If helpers.FieldIsNil(Obj.Actions, "ondrag")=0 Then Obj.Actions.OnDrag({id=msg.id, event="OnDrag", value=Obj.FirstItem}) 
													EndIf
                                     EndIf
                                  Wend
                                  If FirstItem <> Obj.FirstItem
												 ; Esegue l'eventuale evento <OnChange> associato
												 If helpers.FieldIsNil(Obj.Actions, "onchange") = 0 Then Obj.Actions.OnChange({id=msg.id, event="OnChange", value=Obj.FirstItem}) 

                                  EndIf
                                  Return
                               EndIf
                            EndIf
                              ; === OUTSIDE CURSOR'S CLICK ===
                              If Obj.Type = #SCROLLERTYPE_VERTICAL
                                 If MousePos.y < Cursor.ys
                                    ; --- MINUS ---
                                    If Obj.FirstItem = 0 Then Return
                                    Obj.FirstItem = Obj.FirstItem - Obj.ClickStep
                                    If Obj.FirstItem < 0 Then Obj.FirstItem = 0

                                 Else
                                    ; --- PLUS ---
                                    If Obj.FirstItem = Obj.TotalItems - Obj.VisibleItems Then Return
                                    Obj.FirstItem = Obj.FirstItem + Obj.ClickStep
                                    If Obj.FirstItem > Obj.TotalItems - Obj.VisibleItems Then Obj.FirstItem = Obj.TotalItems - Obj.VisibleItems

                                 EndIf
                              Else
                                 If MousePos.x < Cursor.xs
                                    ; --- MINUS ---
                                    If Obj.FirstItem = 0 Then Return
                                    Obj.FirstItem = Obj.FirstItem - Obj.ClickStep
                                    If Obj.FirstItem < 0 Then Obj.FirstItem = 0

                                 Else
                                    ; --- PLUS ---
                                    If Obj.FirstItem = Obj.TotalItems - Obj.VisibleItems Then Return
                                    Obj.FirstItem = Obj.FirstItem + Obj.ClickStep
                                    If Obj.FirstItem > Obj.TotalItems - Obj.VisibleItems Then Obj.FirstItem = Obj.TotalItems - Obj.VisibleItems

                                 EndIf                              
                              EndIf
                              
                              Local currPos = Obj.CursPos
                              Local newPos  = Int(Obj.FirstItem * Obj.PixPerItem)
                              
                              ; Spostamento relativo del cursore
                              If Obj.Type = #SCROLLERTYPE_VERTICAL
                                 scui.MoveBevel(Obj.oData.Cursor, 0, (newPos - currPos), 1)
                                 scui.MoveBevel(Obj.oData.hCursor, 0, (newPos - currPos), 1)
                                 scui.MoveBevel(Obj.oData.pCursor, 0, (newPos - currPos), 1)
                                 scui.MoveBevel(Obj.oData.dCursor, 0, (newPos - currPos), 1)
                                 scui.MoveText(Obj.oData.Text, 0, (newPos - currPos), 1)
                                 scui.MoveText(Obj.oData.hText, 0, (newPos - currPos), 1)
                                 scui.MoveText(Obj.oData.pText, 0, (newPos - currPos), 1)
                                 scui.MoveText(Obj.oData.dText, 0, (newPos - currPos), 1)
                              Else
                                 scui.MoveBevel(Obj.oData.Cursor, (newPos - currPos), 0, 1)
                                 scui.MoveBevel(Obj.oData.hCursor, (newPos - currPos), 0, 1)
                                 scui.MoveBevel(Obj.oData.pCursor, (newPos - currPos), 0, 1)
                                 scui.MoveBevel(Obj.oData.dCursor, (newPos - currPos), 0, 1)
                                 scui.MoveText(Obj.oData.Text, (newPos - currPos), 0, 1)
                                 scui.MoveText(Obj.oData.hText, (newPos - currPos), 0, 1)
                                 scui.MoveText(Obj.oData.pText, (newPos - currPos), 0, 1)
                                 scui.MoveText(Obj.oData.dText, (newPos - currPos), 0, 1)
                              EndIf
                              
                              ; Aggiorna nuova posizione cursore e ridisegna l'oggetto
                              Obj.CursPos = newPos
										
										; Verifica se lo Scroller e' un child di qualche altro oggetto
										If helpers.FieldIsNil(Obj, "oparent") = 0
										  Local Parent = Obj.oParent
										  Local ParentMsg = { id       = Parent,
																	 action   = "OnScrollerChange",
																	 callfrom = msg.id,
																	 event    = "Click",
																	 current  = Int(Obj.FirstItem),
                                                    display  = msg.Display }
										  If helpers.FieldIsNil(msg, "keyboard") = 0 Then ParentMsg.Keyboard = 1
										  scui.HandleObject(ParentMsg)
										EndIf

					               scui.RenderObject(msg.id)
										
										; Esegue l'eventuale evento <OnChange> associato
					               If helpers.FieldIsNil(Obj.Actions, "onchange") = 0 Then Obj.Actions.OnChange({id=msg.id, event="OnChange", value=Obj.FirstItem}) 

                            Return
                            
                        EndIf
                        
                    Case "OnMouseUp"
                        If Obj.Status = #IFOSTATUS_PUSHED Or Obj.Status = #IFOSTATUS_HILIGHTED
                            Obj.Status = #IFOSTATUS_HILIGHTED
                            scui.RenderObject(msg.id)
                            ; Event Handler
                            ; If helpers.FieldIsNil(Obj.Actions, "onchange")=0 Then Obj.Actions.OnChange({id=msg.id, event="OnChange"}) 
                        EndIf
                EndSwitch
            EndIf   
        ; ------------------------------------------------------| OPTIONS |---
        Case #IFOCLASS_OPTIONS
            ; Qua ci arrivo ogni volta che viene premuto uno switch appartenente
            ; ad un gruppo di opzioni
            ; Dov'è il controllo per verificare se è un figlio o meno??
            If Obj.Enabled = #IFO_ENABLED And Obj.Visible = #IFO_VISIBLE
;            ParentMsg = { id       = Parent,
;                          action   = "OnChanged",
;                          callfrom = msg.id,
;                          event    = "UP->DOWN" }
                If msg.event = "UP->DOWN"
                    If Obj.Mode = #OPTMODE_ONLYONE
                        ; MUTUAL EXCLUDE: Alzo tutti gli altri Childs
                        Local ChildList  = Obj.Childs
                        Local ChildCount = Obj.ChildCount
                        Local o
                        For o = 1 To ChildCount
                            Local objj = Obj.Childs[o]
                            ; Processa solo gli Switch e salta le label
                            If (objj <> msg.callfrom) And (scui.IFO[objj].oClass = #IFOCLASS_SWITCH)
                                scui.IFO[objj].Value  = 0
                                scui.IFO[objj].Status = #IFOSTATUS_NORMAL
                                scui.RenderObject(objj)
                            EndIf
                        Next                                    
                    EndIf
                    
                    If helpers.FieldIsNil(scui.IFO[msg.callfrom].Actions, "onchanged")=0 Then scui.IFO[msg.callfrom].Actions.OnChanged({id=msg.id, event="OnChanged", child=msg.callfrom})
                Else
                    If Obj.Mode = #OPTMODE_ONLYONE
                        ; MUTUAL EXCLUDE: Non posso disattivare l'opzione
                        scui.IFO[msg.callfrom].Value  = 1
                        scui.IFO[msg.callfrom].Status = #IFOSTATUS_HILIGHTED
                        scui.RenderObject(msg.callfrom)
                    Else
                        ; Change Switch Value
                        scui.IFO[msg.callfrom].Value  = 0
                        scui.IFO[msg.callfrom].Status = #IFOSTATUS_HILIGHTED
                        scui.RenderObject(msg.callfrom)
                        ; Event Handler
                        If helpers.FieldIsNil(scui.IFO[msg.callfrom].Actions, "onchanged")=0 Then scui.IFO[msg.callfrom].Actions.OnChanged({id=msg.id, event="OnChanged", child=msg.callfrom})
                    EndIf
                
                EndIf
                
            EndIf
         
        ; --------------------------------------------------------| CYCLE |---
        Case #IFOCLASS_CYCLE
            If msg.event = "UP->DOWN" And msg.action = "OnDown"
					/* Il pulsante del Cycle e' stato premuto                    */
					; Apro un Pop-Up con le opzioni disponibili, il pop-up sara'
               ; composto solamente da un gadget Options con OPTMODE_ONLYONE
               ; e con l'opzione attualmente attiva evidenziata.
               ; Il pop-up sara' aperto in maniera dedicata in modo che:
               ; - Se viene selezionato un altro elemento generi un evento <OnChanged>
               ; In entrambi i casi questi eventi saranno gestiti dalla funzione
               ; assegnata all'options-box <scui.HandleCycle>.
               
               ; Step 1 - Apertura Pop-Up
               ;    Step 1a - Creazione ItemList basata sulle opzioni disponibili

               Local OptionsList = {}
               For Local i = 0 To Obj.OptionsCount - 1
                  OptionsList[i] = Obj.Options[i]
               Next
               
               Local count = helpers.CountEntries(OptionsList)
               Local ItemList = { MenuName = "Cycle Menu'" }
               For Local i = 0 To count - 1
                  ItemList[i] = { Type = #IFOCLASS_BUTTON ,
                                  Status = #IFO_ENABLED ,
                                  Data = { Caption = OptionsList[i],
                                           Action  = scui.HandleCycle } }
               Next
                                                 
               /*
               Local ItemList = { MenuName = "Cycle Menu'", 
                                  { Type = #IFOCLASS_OPTIONS ,
                                    Status = #IFO_ENABLED ,
                                    Data = { OptionsList = OptionsList,
                                             DefaultOptions = { Obj.CurrentOption },
                                             OptionsMode = #OPTMODE_ONLYONE ,
                                             Action = scui.HandleCycle } } }
               */
               
               Local w = scui.Win.FindByName(Obj.Owner)
               Local g = scui.Get(Obj.oName)

               Local position = { g.position.x + GetAttribute(#DISPLAY, w.HWId, #ATTRXPOS) + GetAttribute(#DISPLAY, w.HWId, #ATTRBORDERLEFT), 
                                  g.position.y + GetAttribute(#DISPLAY, w.HWId, #ATTRYPOS) + GetAttribute(#DISPLAY, w.HWId, #ATTRBORDERTOP)}
               scui.Win.PopUp(position, ItemList, { PopUpWidth = g.Size.x, MenuTitle = False , Draggable = False } , Obj.oName )

            EndIf
         ; ----------------------------------------------------| LISTVIEW |---
         Case #IFOCLASS_LISTVIEW
            If Obj.Enabled = #IFO_ENABLED And Obj.Visible = #IFO_VISIBLE
                If msg.action = "OnChanged" And msg.event = "UP->DOWN"
                    Local r      = 0
                    Local c      = 0
                    Local Reset  = 0
                    Local MessageRow = 0
                    Local Offset = Obj.StartOption - 1
						  
                    If Obj.Mode = #OPTMODE_ONLYONE Then Reset = 1
                    For r = 1 To Obj.VisibleRows
                        Local c = 1
                        ;For c = 1 To Obj.FieldCount
                            If Obj.Choices[r][c].SwitchID = msg.callfrom Then MessageRow = r
                        ;Next
                    Next
                    
                    If Obj.Mode = #OPTMODE_ONLYONE
                        For r = 0 To Obj.EntriesCount - 1
                            If r <> (MessageRow + Offset - 1) Then Obj.Selected[r] = 0
                        Next
                        For r = 1 To Obj.VisibleRows
                            c = 1
                            ;For c = 1 To Obj.FieldCount
                            If r <> MessageRow
                              If scui.IFO[Obj.Choices[r][c].SwitchID].Value <> 0
                                scui.IFO[Obj.Choices[r][c].SwitchID].Status = #IFOSTATUS_NORMAL
                                scui.IFO[Obj.Choices[r][c].SwitchID].Value = 0
                                ; Ottimizzare disegnando solo quelli che cambiano valore
                                scui.RenderObject(Obj.Choices[r][c].SwitchID)
                              EndIf
                            EndIf
                            ;Next
                        Next 
                    EndIf

                    Obj.Selected[MessageRow + Offset - 1] = 1
                    c = 1
                    ;For c = 1 To Obj.FieldCount
                        scui.IFO[Obj.Choices[MessageRow][c].SwitchID].Status = #IFOSTATUS_PUSHED
                        scui.IFO[Obj.Choices[MessageRow][c].SwitchID].Value = 1
                        
                        ; ------------------------------------------------------
                        ; RIGA COMMENTATA IN DATA 30 APRILE 2010 PER EVITARE
                        ; UN DOPPIO REFRESH
                        ;scui.RenderObject(Obj.Choices[MessageRow][c].SwitchID)
                        ; ------------------------------------------------------
                    ;Next

                    If helpers.FieldIsNil(Obj.Actions, "onchanged") = 0
                       Obj.Actions.OnChanged({ id = msg.id, 
                                               event = msg.event, 
                                               item = MessageRow + Offset, 
                                               itemvalue = Obj.Selected[MessageRow + Offset - 1],
                                               data = Obj.Entries[MessageRow + Offset-1] })
                    EndIf
                    
                ElseIf msg.action = "OnChanged" And msg.event = "DOWN->UP"
                    Local r = 0
                    Local c = 0
                    Local Reset = 1
                    Local Offset = Obj.StartOption - 1                
                    Local MessageRow = 0
                    
                    If Obj.Mode = #OPTMODE_ONLYONE Then Reset = 0
                    For r = 1 To Obj.VisibleRows
                        Local c = 1
                        ;For c = 1 To Obj.FieldCount
                            If Obj.Choices[r][c].SwitchID = msg.callfrom Then MessageRow = r                    
                        ;Next
                    Next
                    
                    ;If Reset = 1
                        Local c = 1
                        ;For c = 1 To Obj.FieldCount
                            scui.IFO[Obj.Choices[MessageRow][c].SwitchID].Value = 0
                            scui.IFO[Obj.Choices[MessageRow][c].SwitchID].Status = #IFOSTATUS_NORMAL
                            Obj.Selected[MessageRow+Offset-1] = 0
                            scui.RenderObject(Obj.Choices[MessageRow][c].SwitchID)
                        ;Next
                        If helpers.FieldIsNil(Obj.Actions, "onchanged") = 0
                       ;DebugPrint("ITEM:", MessageRow + Offset, Obj.Selected[MessageRow + Offset - 1] )

                           Obj.Actions.OnChanged({ id = msg.id, 
                                                   event = msg.event, 
                                                   item = MessageRow + Offset,
                                                   itemvalue = Obj.Selected[MessageRow + Offset - 1],
                                                   data = Obj.Entries[MessageRow + Offset - 1]})
                        EndIf
                   ;EndIf


                    
                ElseIf (msg.event = "Click" Or msg.event = "Drag") And msg.action = "OnScrollerChange"
						If Obj.StartOption = Msg.Current + 1 Then Return
             Local StartPosition = msg.current
             Obj.StartOption = msg.current + 1
             For r = 1 To Obj.VisibleRows
                c = 1
                ;For c = 1 To Obj.FieldCount
                Local tEntry = {}
                Local te
                For te = 1 To Obj.FieldCount
                    tEntry[te-1] = Obj.Entries[r-1+StartPosition][te-1]
                Next
                ;helpers.DumpTable(tEntry)
                    Local NewLabel = { AllTexts = { Values = tEntry, Lines = helpers.CountEntries(tEntry)}}
                    scui.Switch_SetText(Obj.Choices[r][c].SwitchID, tEntry)
                    ;scui.Set(Obj.Choices[r][c].SwitchID, NewLabel, 1)
                     ; Check if must start selected            
                     If Obj.Selected[r-1+StartPosition]=1
                        ; Selected Gadget
                        scui.IFO[Obj.Choices[r][c].SwitchID].Status = #IFOSTATUS_PUSHED
                        scui.IFO[Obj.Choices[r][c].SwitchID].Value  = 1
                        scui.RenderObject(Obj.Choices[r][c].SwitchID)
                     Else
                        scui.IFO[Obj.Choices[r][c].SwitchID].Status = #IFOSTATUS_NORMAL
                        scui.IFO[Obj.Choices[r][c].SwitchID].Value  = 0
                        scui.RenderObject(Obj.Choices[r][c].SwitchID)
                     EndIf
                     
                     Obj.Choices[r][c].OptionID = r + StartPosition - 1
                ;Next
            Next
                   
                ElseIf msg.event = "UP->DOWN" And msg.action = "OnDown"

                    ; Identifica la colonna premuta
                    Local c = 0
                    Local h = 0
                    For c = 1 To Obj.FieldCount
                       If Obj.Childs[c] = msg.callfrom
                          h = c
                          Break
                       EndIf
                    Next

                    ; Sorting di Entries e di Selected in base alla colonna specificata
                    Local c1
                    Local c2
                    Local Item1
                    Local Item2
                    Local SubItem1
                    Local SubItem2
                    Local SortMode = 0
                    ; Controlla sorting precedente
                    If helpers.FieldIsNil(Obj, "sortmode")=1 Then Obj.SortMode = 1
                    If helpers.FieldIsNil(Obj, "lastsortedcol")=1 Then Obj.LastSortedCol = h
                    If Obj.LastSortedCol = h
                        ; Stessa colonna inverto ordinamento
                        If Obj.SortMode = 1
                            SortMode = 0
                        Else
                            SortMode = 1
                        EndIf
                    EndIf
                    
                    Obj.SortMode = SortMode
                    Obj.LastSortedCol = h
                    
                    For c1 = 0 To Obj.EntriesCount - 1 - 1
                        Item1 = Obj.Entries[c1]
                        SubItem1 = Item1[h-1]

                        For c2 = c1 + 1 To Obj.EntriesCount - 1                  
                            Item2 = Obj.Entries[c2]                        
                            SubItem2 = Item2[h-1]
                            If SortMode = 0
                                If SubItem1 > SubItem2
                                    Local dummy = Obj.Entries[c2]
                                    Obj.Entries[c2] = Obj.Entries[c1]
                                    Obj.Entries[c1] = dummy
                                    Local dummy = SubItem1
                                    SubItem1 = SubItem2
                                    SubItem2 = dummy
                                    Local dummy = Obj.Selected[c2]
                                    Obj.Selected[c2] = Obj.Selected[c1]
                                    Obj.Selected[c1] = dummy
                                EndIf
                            Else
                                If SubItem1 < SubItem2
                                    Local dummy = Obj.Entries[c2]
                                    Obj.Entries[c2] = Obj.Entries[c1]
                                    Obj.Entries[c1] = dummy
                                    Local dummy = SubItem1
                                    SubItem1 = SubItem2
                                    SubItem2 = dummy
                                    Local dummy = Obj.Selected[c2]
                                    Obj.Selected[c2] = Obj.Selected[c1]
                                    Obj.Selected[c1] = dummy
                                EndIf
                            EndIf
                       Next
                    Next

                     Local StartPosition = Obj.StartOption - 1

                     For r = 1 To Obj.VisibleRows
                        Local c = 1
                Local tEntry = {}
                Local te
                For te = 1 To Obj.FieldCount
                    tEntry[te-1] = Obj.Entries[r-1+StartPosition][te-1]
                Next
                        ;For c = 1 To Obj.FieldCount
                            ;Local NewLabel = { Values = { Obj.Entries[r-1+StartPosition][c-1] }, Lines = 1}
                            ;scui.IFO.SetText(Obj.Choices[r][c].SwitchID, NewLabel)
                            scui.Switch_SetText(Obj.Choices[r][c].SwitchID, tEntry)
                             ; Check if must start selected            
                             If Obj.Selected[r-1+StartPosition]=1
                                ; Selected Gadget
                                scui.IFO[Obj.Choices[r][c].SwitchID].Status = #IFOSTATUS_PUSHED
                                scui.IFO[Obj.Choices[r][c].SwitchID].Value  = 1
                                scui.RenderObject(Obj.Choices[r][c].SwitchID)
                             Else
                                scui.IFO[Obj.Choices[r][c].SwitchID].Status = #IFOSTATUS_NORMAL
                                scui.IFO[Obj.Choices[r][c].SwitchID].Value  = 0
                                scui.RenderObject(Obj.Choices[r][c].SwitchID)

                             EndIf
                             
                             Obj.Choices[r][c].OptionID = r + StartPosition - 1
                        ;Next
                    Next
                    
                    
                EndIf
            EndIf
            
        Case #IFOCLASS_TABS
            If Obj.Enabled = #IFO_ENABLED And Obj.Visible = #IFO_VISIBLE or 1=1
                ; Attiva i gadget della pagina selezionata
                Local ActivePage = msg.current - 1
                ; Convert coordinates & store gadgets & hide offpage gadgets
                If helpers.FieldIsNil(oString, "gadgetlist") = 0 Then tabs_GadgetList = oString.GadgetList
                Local page_count
                Local gad_count
                Local count
                Local tabs_PageCount = Obj.PageCount
                Local tabs_TabChilds = Obj.TabChilds

                For page_count = 0 To tabs_PageCount - 1
                ; QUA NON CI SIAMO PROPRIO...
                ; DEVO INVENTARE UN MECCANISMO PER FAR SI CHE IL
                ; REDRAW AD OGNI NASCONDIMENTO DI GADGET NON AVVENGA
                gad_count = helpers.CountEntries(tabs_TabChilds[page_count])
                    If page_count = ActivePage
                        ; Pagina attiva, mostro i gadget
                        For count = 0 To gad_count - 1
                            Local childID = tabs_TabChilds[page_count][count].id
                            Local childVis= tabs_TabChilds[page_count][count].Visible
                            scui.Set(childID, { Visible = childVis })
                            ;scui.IFO[childID].Visible = childVis
                        Next
                    Else
                        ; Pagina non attiva, nascondo i gadget
                        For count = 0 To gad_count - 1
                            Local childID = tabs_TabChilds[page_count][count].id
                            scui.Set(childID, { Visible = #IFO_HIDDEN })
                            ;scui.IFO[childID].Visible = #IFO_HIDDEN
                        Next
                    EndIf
                Next
                Obj.ActivePage = ActivePage
                scui.RenderObject(msg.id)
            EndIf
            
    EndSwitch
    
EndFunction
Function scui.FastSetBevel(Source, Changes) ;---------------------| PRIVATE |---
   If Not(helpers.FieldIsNil(Changes, "vector"))  And helpers.FieldIsNil(Source, "vector")  Then Source.Vector  = helpers.CloneTable(Changes.Vector)
   If Not(helpers.FieldIsNil(Changes, "picture")) And helpers.FieldIsNil(Source, "picture") Then Source.Picture = helpers.CloneTable(Changes.Picture)
   Changes.Position = Nil
   Changes.Size     = Nil
   helpers.SetTable(Source, Changes, False)
EndFunction
Function scui.FastSetText(Source, Changes) ;----------------------| PRIVATE |---
   If Not(helpers.FieldIsNil(Changes, "icon")) And helpers.FieldIsNil(Source, "icon") Then Source.Icon = helpers.CloneTable(Changes.Icon)
   Changes.Area = Nil
   helpers.SetTable(Source, Changes, False)
EndFunction
Function scui.NewObject( oClass, oName, oPosition, oSize, oData, oString , oActions, IFOParent, ForceID, NoDraw, Owner, RootChild)
;=======================================================================================================================
   ; docs updated 27.12.2008
   
   ; DA ORA IN AVANTI (13.01.2010) il nome del gadget è obbligatorio e non deve essere duplicato!
   ; Inoltre non è più case-sensitive

   ; ROOTCHILD NON SERVE PIU' A UNA CEPPA --> ELIMINARE
   
   scui.Debug({ "scui.NewObject(oClass, oName, oPosition, oSize, oData, oString , oActions, IFOParent, ForceID, NoDraw, Owner, RootChild)" })

   If helpers.IsNil(ForceID)
      If helpers.IsNil(oName)
         DebugPrint("*****************************************************************")
         DebugPrint("* ERROR CREATING GAGDET: THE NAME MUST NOT BE <NIL>             *")
         DebugPrint("*****************************************************************")
         DebugPrint("Class:", oClass, "Pos:", oPosition, "Size:", oSize)
         DebugPrint("*****************************************************************")
         Return(-1)
      Else
         If Not(helpers.FieldIsNil(scui.QuickFind, oName))
            DebugPrint("*****************************************************************")
            DebugPrint("* ERROR CREATING GAGDET: THE NAME IS DUPLICATED!!               *")
            DebugPrint("*****************************************************************")
            DebugPrint("Name:", oName, "Class:", oClass)
            Return(-1)
         EndIf
      EndIf
   Else
      ;DebugPrint("REBUILDING GADGET:", scui.IFO[ForceID].oName)
   EndIf
   
   ; Crea un nuovo IFO nell'interfaccia

   If helpers.IsNil(Owner)
      If helpers.IsNil(scui.Win.SelectedDisplay)
         Owner = #SCREENID
      Else
         Owner = scui.Win.SelectedDisplay
      EndIf
   EndIf
   scui.Win.Select(Owner)
   
   ; CONTROLLA L'OWNER E SE NON E' SETTATO PRENDE QUELLO DEL DISPLAY CORRENTEMENTE
   ; ATTIVO PER IL RENDERING
   ;If helpers.IsNil(Owner) Then Owner = scui.Win.SelectedDisplay
   
   ; Genera un <id> per il nuovo pulsante
   Local id = 0
   If Not(helpers.IsNil(ForceID))
     id     = ForceID
     oClass = scui.IFO[ForceID].oClass
     oName = scui.IFO[ForceID].oName
   Else
     scui.IFO.IDCounter = scui.IFO.IDCounter + 1
     id = scui.IFO.IDCounter
   EndIf
   
   ; Crea subito l'ingresso nella QuickFind
   scui.QuickFind[oName] = id

   If scui.AutoRendering = False Then NoDraw = 1
   
   ; Controlla la posizione e la dimensione e le crea se mancanti
   If helpers.IsNil(oPosition) Then oPosition = { x =   1, y =   1 }
   If helpers.IsNil(oSize)     Then oSize     = { x = 100, y = 100 }

   ; Esegue il codice in base alla classe dell'oggetto da creare
   Switch oClass
      ;=========================================================================
      Case #IFOCLASS_BEVELBOX
      ;=========================================================================
/******************************************************************************
* BEVEL BOX CLASS                                                             *
* Supported fields in Customize table (oData)                                 *
*  - bevel         BevelStruct Structure to override theme defaults           *
*  - visible       #IFO_VISIBLE | #IFO_HIDDEN                                 *
*******************************************************************************/
         If helpers.IsNil(oData) = 1 Then oData = {}

         ;---| Imposta i parametri di default |---------------------------------
         Local ifo_Bevel = helpers.CloneTable(scui.theme.BevelBox_Bevel)
         helpers.SetTable( ifo_Bevel, 
                           { Position = { x = oPosition.x, y = oPosition.y },
                             Size     = { x = oSize.x, y = oSize.y } }, 
                           False )

         Local ifo_Visible     = #IFO_VISIBLE
         Local ifo_Enabled     = #IFO_ENABLED
         Local ifo_Type        = #IFOTYPE_BASIC
         Local ifo_Class       = #IFOCLASS_BEVELBOX
         Local ifo_Parent      = nil
         Local ifo_Interactive = 0

         ;---| Imposta le preferenze utente |-----------------------------------
         If Not(helpers.FieldIsNil(oData, "bevel"  ))
            oData.Bevel.Position = Nil
            oData.Bevel.Size     = Nil
            helpers.SetTable(ifo_Bevel, oData.Bevel, False)
         EndIf
         If Not(helpers.FieldIsNil(oData, "visible")) Then ifo_Visible = oData.Visible
         
         ;---| Verifica se si tratta di un Child |------------------------------
         If Not(helpers.IsNil(IFOParent))
             ifo_Type   = #IFOTYPE_CHILD
             ifo_Parent = IFOParent
         EndIf
        
         ;---| Memorizzazione nuovo oggetto |-----------------------------------
         scui.IFO[id] = { Visible      = ifo_Visible,
                          Enabled      = ifo_Enabled,
                          oType        = ifo_Type,
                          oClass       = ifo_Class,
                          oParent      = ifo_Parent,
                          oInteractive = ifo_Interactive,
                          oName        = oName,
                          Owner        = Owner,
                          oData        = { Bevel = ifo_Bevel } }

         ;---| Rendering e restituzione risultati |-----------------------------
         If helpers.IsNil(NoDraw) Then scui.RenderObject(id)
			Return(id, scui.IFO[id])

      ;=========================================================================
      Case #IFOCLASS_LABEL
      ;=========================================================================
/******************************************************************************
* BEVEL BOX CLASS                                                             *
* Supported fields in Customize table (oData)                                 *
*  - Bevel          BevelStruct Structure                                     *
*  - Text           TextStruct Structure                                      *
*  - Visible        #IFO_VISIBLE | #IFO_HIDDEN                                *
* Supported Fields in Params table (oString)                                  *
*  - Values         A table with all rows of text to draw inside the          *
*                   button.                                                   *
*  - Lines          Set the first <n> lines to draw inside the button         *
*                   if you omit this field all rows will be included          *
*                   in the label.                                             *
*  - GroupFrame     True|False Sets if you want a Group Frame or not          *
*******************************************************************************/

; *** POTREI POTENZIARE ULTERIORMENTE CREANDO UN LAYOUT PER IL TESTO IN CASO ***
; *** DI GROUP FRAME, BASTA GESTIRLO QUA IN FASE DI CREAZIONE                ***

         If helpers.IsNil(oData   ) Then oData   = {}
         If helpers.IsNil(oString ) Then oString = {}
 
         ;---| Verifica se e' stato passato il testo della label altrimenti |---
         ;   | lo crea uno di default ( *** SERVE VERAMENTE? *** )          |---
         If helpers.FieldIsNil(oString, "values") = 1
             oString.Values = { "Empty" }
             oString.Lines  = 1
         ElseIf helpers.FieldIsNil(oString, "lines") = 1
             oString.Lines  = helpers.CountEntries(oString.Values)
         EndIf
         
         ;---| Crea il bevel di default |---------------------------------------
         Local ifo_Bevel = helpers.CloneTable(scui.theme.Label_Bevel)
         helpers.SetTable( ifo_Bevel, { Position = { x = oPosition.x, y = oPosition.y },
                                        Size     = { x = oSize.x, y = oSize.y } }, 
                                      False )

         ;---| Calcola il moltiplicatore per il margine del testo |-------------
			Local mul = IIF(ifo_Bevel.Type = #BEVELTYPE_SUNKEN , 2, IIF(ifo_Bevel.Type <> #BEVELTYPE_NONE , 1, 0))

         ;---| Crea la struttura per il testo |---------------------------------
         Local ifo_Marg = ifo_Bevel.Height * mul + scui.theme.TextBorder
         Local ifo_Text = helpers.CloneTable(scui.theme.Label_Text)
         helpers.SetTable(ifo_Text, { Content = { Values = oString.Values, Lines  = oString.Lines },
                                      Margins = { x = ifo_Marg, y = ifo_Marg },
                                      Area    = { xStart = ifo_Bevel.Position.x,                    yStart = ifo_Bevel.Position.y,
                                      xEnd   = ifo_Bevel.Position.x + ifo_Bevel.Size.x, yEnd   = ifo_Bevel.Position.y + ifo_Bevel.Size.y } },
                                    False)

         ;---| Imposta i valori di Default |------------------------------------
         Local ifo_Visible     = #IFO_VISIBLE
         Local ifo_Enabled     = #IFO_ENABLED
         Local ifo_Type        = #IFOTYPE_BASIC
         Local ifo_Class       = #IFOCLASS_LABEL
         Local ifo_Parent      = Nil
         Local ifo_Interactive = 0
         
         ;---| Verifica se si tratta di un GroupFrame |-------------------------
         Local GroupFrame = False
         If Not(helpers.FieldIsNil(oString, "groupframe")) Then GroupFrame = oString.GroupFrame
         
         ;---| Modifica ifo_Text & ifo_Bevel in caso di GroupFrame |------------
         /* QUESTO BLOCCO NON SERVE PERCHE' IL RENDERING DEL GROUPFRAME VIENE   
            GESTITO DIRETTAMENTE DALLA ROUTINE DI RENDERING                     
            --------------------------------------------------------------------
         If GroupFrame
            Local lines = helpers.CountEntries(ifo_Text.Content.Values)
            If ifo_Text.Content.Lines < lines Then lines = ifo_Text.Content.Lines
            SetFont(ifo_Text.FontName, ifo_Text.FontSize, { Engine = #FONTENGINE_INBUILT, Chache = True })
            Local largest = 0
            For Local l = 0 To lines - 1
               Local w = TextWidth(ifo_Text.Content.Values[l])
               If w > largest Then largest = w
            Next
Local w_margins = 2               
Local h_margins = 4
Local w_Offset  = 10
            Local Text_H = h_margins * 2 + ifo_Text.FontSize * lines + ifo_Text.Content.VerticalOffset * (lines-1)
            Local Text_W = largest
            
            ifo_Bevel.Position.y = ifo_Bevel.Position.y + Text_H/2
            ifo_Text.Area.yStart = ifo_Bevel.Position.y - Text_H/2
            ifo_Text.Area.yEnd   = ifo_Bevel.Position.y + Text_H/2
            ifo_Text.Area.xStart = ifo_Bevel.Position.x + w_Offset
            ifo_Text.Area.xEnd   = ifo_Text.Area.xStart + Text_W
         EndIf
         */
         
         ;---| Imposta le preferenze utente |-----------------------------------
         If Not(helpers.FieldIsNil(oData, "bevel"  )) Then scui.FastSetBevel(ifo_Bevel, oData.Bevel)
         If Not(helpers.FieldIsNil(oData, "text"   )) Then scui.FastSetText(ifo_Text, oData.Text)
         If Not(helpers.FieldIsNil(oData, "visible")) Then ifo_Visible = oData.Visible
        
         ;---| Verifico se si tratta di un child |------------------------------
         If Not(helpers.IsNil(IFOParent))
            ifo_Type   = #IFOTYPE_CHILD
            ifo_Parent = IFOParent
         EndIf
       
         ;---| memorizzo il nuovo oggetto |-------------------------------------
         scui.IFO[id] = { Visible      = ifo_Visible,
                          Enabled      = ifo_Enabled,
                          oType        = ifo_Type,
                          oClass       = ifo_Class,
                          oParent      = ifo_Parent,
                          oInteractive = ifo_Interactive,
                          Owner        = Owner,
                          oName        = oName,
                          GroupFrame   = GroupFrame,
                          oData        = { Bevel = ifo_Bevel,
                                           Text  = ifo_Text }}
                                                  
         ;---| Rendering e restituzione risultati |-----------------------------
         If helpers.IsNil(NoDraw) Then scui.RenderObject(id)      
			Return(id, scui.IFO[id])

      ;=========================================================================
      Case #IFOCLASS_BUTTON
      ;=========================================================================
         ;+--------------------------------------------------------[ BUTTON ]--+
         ;| Interactive: YES                                                   |
         ;| Supported Fields in Aspect table (oData)                           |
         ;|  - Bevel          BevelStruct Structure for normal layout          |
         ;|  - HBevel         BevelStruct Structure for hilighted layout       |
         ;|  - PBevel         BevelStruct Structure for pushed layout          |
         ;|  - DBevel         BevelStruct Structure for disabled layout        |
         ;|  - Text           TextStruct Structure for normal layout           |
         ;|  - HText          TextStruct Structure for hilighted layout        |
         ;|  - PText          TextStruct Structure for pushed layout           |
         ;|  - DText          TextStruct Structure for disabled layout         |
         ;|  - Visible        #IFO_VISIBLE | #IFO_HIDDEN                       |
         ;|  - Enabled        #IFO_ENABLED | #IFO_DISABLED                     |
         ;| Supported Fields in Params table (oString)                         |
         ;|  - Values         A table with all rows of text to draw inside the |
         ;|                   button                                           |
         ;|  - Lines          Set the first <n> lines to draw inside the button|
         ;|                   if you omit this field all rows will be included |
         ;|                   in the button.                                   |
         ;|  - Shortcut       Character assigned to this button                |
         ;| Supported Fields in Actions table (oActions)                       |
         ;|  - OnPushed       The function to call when the user release the   |
         ;|                   LMB inside a button                              |
         ;|  - OnDown         The function to call when the user press the LMB |
         ;|                   inside a button                                  |
         ;|  - custom         *** RESERVED ACTION : DON'T USE THIS ***         |
         ;+--------------------------------------------------------------------+
         If helpers.IsNil(oData   ) Then oData    = {}
         If helpers.IsNil(oString ) Then oString  = {}
         If helpers.IsNil(oActions) Then oActions = {}
        		
         /* Verifica se e' stato passato il testo della label altrimenti lo   */
         /* crea uno di default                                               */
         If helpers.FieldIsNil(oString, "values")
            oString.Values = { "Empty" }
            oString.Lines  = 1
         ElseIf helpers.FieldIsNil(oString, "lines")
            oString.Lines  = helpers.CountEntries(oString.Values)
         EndIf
            
         /* Crea le strutture di default */
         Local ifo_TempBev = { Position = { x = oPosition.x, y = oPosition.y },
                               Size     = { x = oSize.x,     y = oSize.y } }

         Local ifo_Bevel  = helpers.CloneTable(scui.theme.Button_NBox)
         helpers.SetTable(ifo_Bevel, ifo_TempBev, False)
         
         Local ifo_HBevel = helpers.CloneTable(scui.theme.Button_HBox)
         helpers.SetTable(ifo_HBevel, ifo_TempBev, False)
         
         Local ifo_PBevel = helpers.CloneTable(scui.theme.Button_PBox)
         helpers.SetTable(ifo_PBevel, ifo_TempBev, False)
         
         Local ifo_DBevel = helpers.CloneTable(scui.theme.Button_DBox)
         helpers.SetTable(ifo_DBevel, ifo_TempBev, False)
        
         /* Imposto le preferenze utente */
         If Not(helpers.FieldIsNil(oData, "bevel"  )) Then scui.FastSetBevel(ifo_Bevel,  oData.Bevel)
         If Not(helpers.FieldIsNil(oData, "hbevel" )) Then scui.FastSetBevel(ifo_HBevel, oData.HBevel)
         If Not(helpers.FieldIsNil(oData, "pbevel" )) Then scui.FastSetBevel(ifo_PBevel, oData.PBevel)
         If Not(helpers.FieldIsNil(oData, "dbevel" )) Then scui.FastSetBevel(ifo_DBevel, oData.DBevel)
        
         /* Verifico se devo assegnare uno shortcut a questo pulsante */
         If Not(helpers.FieldIsNil(oString, "shortcut")) Then scui.Keyboard[Owner].Shortcuts[oString.Shortcut] = id

         /* Calcola il moltiplicatore per i margini testo */
			Local mul = IIF(ifo_Bevel.Type = #BEVELTYPE_SUNKEN , 2, IIF(ifo_Bevel.Type <> #BEVELTYPE_NONE , 1, 0))
        
         /* Struttura temporanea per la creazione dell'etichetta */
         Local ifo_Marg = ifo_Bevel.Height * mul + scui.theme.TextBorder
         Local ifo_TempText = { Content = { Values = oString.Values, Lines  = oString.Lines },
                                Margins = { x = ifo_Marg, y = ifo_Marg },
                                Area    = { xStart = ifo_Bevel.Position.x,                    yStart = ifo_Bevel.Position.y,
                                            xEnd   = ifo_Bevel.Position.x + ifo_Bevel.Size.x, yEnd   = ifo_Bevel.Position.y + ifo_Bevel.Size.y } }

         /* Crea le strutture di default */
         Local ifo_Text  = helpers.CloneTable(scui.theme.Button_NText)
         helpers.SetTable(ifo_Text, ifo_TempText, False)
         
         Local ifo_HText = helpers.CloneTable(scui.theme.Button_HText)
         helpers.SetTable(ifo_HText, ifo_TempText, False)
         
         Local ifo_PText = helpers.CloneTable(scui.theme.Button_PText)
         helpers.SetTable(ifo_PText, ifo_TempText, False)
         
         Local ifo_DText = helpers.CloneTable(scui.theme.Button_DText)
         helpers.SetTable(ifo_DText, ifo_TempText, False)
         
         /* Imposto le preferenze utente */
         If Not(helpers.FieldIsNil(oData, "text" )) Then scui.FastSetText(ifo_Text, oData.Text)
         If Not(helpers.FieldIsNil(oData, "htext")) Then scui.FastSetText(ifo_HText, oData.HText)
         If Not(helpers.FieldIsNil(oData, "ptext")) Then scui.FastSetText(ifo_PText, oData.PText)
         If Not(helpers.FieldIsNil(oData, "dtext")) Then scui.FastSetText(ifo_DText, oData.DText)
         
         Local ifo_Visible     = #IFO_VISIBLE
         Local ifo_Enabled     = #IFO_ENABLED
         If Not(helpers.FieldIsNil(oData, "visible")) Then ifo_Visible = oData.Visible
         If Not(helpers.FieldIsNil(oData, "enabled")) Then ifo_Enabled = oData.Enabled
        
         Local ifo_Type        = #IFOTYPE_BASIC
         Local ifo_Class       = #IFOCLASS_BUTTON
         Local ifo_Parent      = Nil
         Local ifo_Interactive = 1
         Local ifo_Status      = #IFOSTATUS_NORMAL

         /* Verifica se si tratta di un child */
         If Not(helpers.IsNil(IFOParent))
            ifo_Type   = #IFOTYPE_CHILD
            ifo_Parent = IFOParent
            ; DebugPrint("FOR BUTTON ", oName, " SETTING PARENT ", IFOParent)
         EndIf

         /* Memorizza il nuovo oggetto */
         scui.IFO[id] = { Visible      = ifo_Visible,
                          Enabled      = ifo_Enabled,
                          Status       = ifo_Status,
                          oType        = ifo_Type,
                          oClass       = ifo_Class,
                          oParent      = ifo_Parent,
                          oInteractive = ifo_Interactive,
                          Owner        = Owner,
                          oName        = oName,
                          Actions      = { },
                          oData        = { Bevel  = ifo_Bevel,
                                           HBevel = ifo_HBevel,
                                           PBevel = ifo_PBevel,
                                           DBevel = ifo_DBevel,
                                           Text   = ifo_Text,
                                           HText  = ifo_HText,
                                           PText  = ifo_PText,
                                           DText  = ifo_DText }}

         /* Assegna le azioni specificate */
         If Not(helpers.FieldIsNil(oActions, "onpushed")) Then scui.IFO[id].Actions.OnPushed = oActions.OnPushed
         If Not(helpers.FieldIsNil(oActions, "ondown"  )) Then scui.IFO[id].Actions.OnDown   = oActions.OnDown
         If Not(helpers.FieldIsNil(oActions, "custom"  )) Then scui.IFO[id].Actions.Custom   = oActions.Custom

         /* Disegna il gadget e restituisci l'id */    
         If helpers.IsNil(NoDraw) Then scui.RenderObject(id)

         /* Crea l'area per la rilevazione degli eventi */
         scui.Win.Select(Owner)
         MakeButton(id, #SIMPLEBUTTON , scui.IFO[id].oData.Bevel.Position.x, scui.IFO[id].oData.Bevel.Position.y,
                                        scui.IFO[id].oData.Bevel.Size.x,     scui.IFO[id].oData.Bevel.Size.y, 
                                        { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject ,
                                          OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject }) 

         /* Disattiva la zona se non visibile o disabilitato */
			If(ifo_Enabled = #IFO_DISABLED Or ifo_Visible = #IFO_HIDDEN) Then DisableButton(id)
			
			; Marca il root child
			If RootChild Then scui.IFO[id].RootChild = True
			Return(id, scui.IFO[id])
 
      ;=========================================================================
      Case #IFOCLASS_SWITCH
      ;=========================================================================
         ;+--------------------------------------------------------[ SWITCH ]--+
         ;| Interactive: YES                                                   |
         ;| Supported Fields in Aspect table (oData)                           |
         ;|  - Bevel          BevelStruct Structure for normal layout          |
         ;|  - HBevel         BevelStruct Structure for hilighted layout       |
         ;|  - PBevel         BevelStruct Structure for pushed layout          |
         ;|  - DNBevel        BevelStruct Struct. for disabled & normal layout |
         ;|  - DPBevel        BevelStruct Struct. for disabled & pushed layout |
         ;|  - Text           TextStruct Structure for normal layout           |
         ;|  - HText          TextStruct Structure for hilighted layout        |
         ;|  - PText          TextStruct Structure for pushed layout           |
         ;|  - DNText         TextStruct Structure for disabled & normal layout|
         ;|  - DPText         TextStruct Structure for disabled & pushed layout|
         ;|  - Visible        #IFO_VISIBLE | #IFO_HIDDEN                       |
         ;|  - Enabled        #IFO_ENABLED | #IFO_DISABLED                     |
         ;| Supported Fields in Params table (oString)                         |
         ;|  - Value      [NEW0.6] Valore iniziale dello switch:               |
         ;|                      - 0 = UP           - 1 = DOWN                 |
         ;|  - Values         A table with all rows of text to draw inside the |
         ;|                   button                                           |
         ;|  - Lines          Set the first <n> lines to draw inside the button|
         ;|                   if you omit this field all rows will be included |
         ;|                   in the button.                                   |
         ;|  - MultiCol   [NEW0.6] True|False - Se viene impostato su True     |
         ;|                   le righe di testo saranno sviluppate in orizzon- |
         ;|                   tale anziche' in verticale.                      |
         ;|  - ColSizes   [NEW0.6] Table - Questa tabella deve contenere le    |
         ;|                   dimensioni in % delle righe specificate. Questo  |
         ;|                   parametro viene preso in considerazione sono se  |
         ;|                   MultiCol = True                                  |
         ;|  - ColBreak   [NEW0.6] Table - Indica con quali colori devono es-  |
         ;|                   sere tracciate le righe verticali che separano le|
         ;|                   linee di testo. Il formato e':                   |
         ;|                      .DrawLines = True | False                     |
         ;|                      .Color = { r = n, g = n, b = n, contrast = n }|
         ;| Supported Fields in Actions table (oActions)                       |
         ;|  - OnChanged      The function to call when this gadget changes    |
         ;|                   value                                            |
         ;+--------------------------------------------------------------------+
         If helpers.IsNil(oData   )=1 Then oData    = {}
         If helpers.IsNil(oString )=1 Then oString  = {}
         If helpers.IsNil(oActions)=1 Then oActions = {}

         /* Verifica se e' stato passato il testo della label altrimenti lo   */
         /* crea uno di default                                               */
         If helpers.FieldIsNil(oString, "values") = 1
            oString.Values = { "Empty" }
            oString.Lines  = 1
         ElseIf helpers.FieldIsNil(oString, "lines") = 1
            oString.Lines  = helpers.CountEntries(oString.Values)
         EndIf
        
         /* Imposta il valore iniziale dello Switch */
         Local ifo_Value = 0
         If helpers.FieldIsNil(oString, "value") = 0 Then ifo_Value = oString.Value
        
         /* Creazione strutture di default */
         Local ifo_TempBev = { Position = { x = oPosition.x, y = oPosition.y },
                               Size     = { x = oSize.x,     y = oSize.y } }
         Local ifo_Bevel   = helpers.CloneTable(scui.theme.Switch_NBox)
         helpers.SetTable(ifo_Bevel, ifo_TempBev, False)
         
         Local ifo_HBevel  = helpers.CloneTable(scui.theme.Switch_HBox)
         helpers.SetTable(ifo_HBevel, ifo_TempBev, False)
         
         Local ifo_PBevel  = helpers.CloneTable(scui.theme.Switch_PBox)
         helpers.SetTable(ifo_PBevel, ifo_TempBev, False)
         
         Local ifo_DNBevel = helpers.CloneTable(scui.theme.Switch_DNBox)
         helpers.SetTable(ifo_DNBevel, ifo_TempBev, False)
         
         Local ifo_DPBevel = helpers.CloneTable(scui.theme.Switch_DPBox)
         helpers.SetTable(ifo_DPBevel, ifo_TempBev, False)
        
         /* Imposto le preferenze utente */
         If helpers.FieldIsNil(oData, "bevel"   )=0 Then scui.FastSetBevel(ifo_Bevel,   oData.Bevel  )
         If helpers.FieldIsNil(oData, "hbevel"  )=0 Then scui.FastSetBevel(ifo_HBevel,  oData.HBevel )
         If helpers.FieldIsNil(oData, "pbevel"  )=0 Then scui.FastSetBevel(ifo_PBevel,  oData.PBevel )
         If helpers.FieldIsNil(oData, "dnbevel" )=0 Then scui.FastSetBevel(ifo_DNBevel, oData.DNBevel)
         If helpers.FieldIsNil(oData, "dpbevel" )=0 Then scui.FastSetBevel(ifo_DPBevel, oData.DPBevel)
         /* Calcola il moltiplicatore per i margini testo */
 		   Local mul = IIF(ifo_Bevel.Type = #BEVELTYPE_SUNKEN , 2, IIF(ifo_Bevel.Type <> #BEVELTYPE_NONE , 1, 0))
         ;If ifo_Bevel.Type = #BEVELTYPE_SUNKEN Then mul = 2 Else mul = 1
        
         /* Struttura temporanea per la creazione dell'etichetta */
         Local ifo_Marg = ifo_Bevel.Height * mul + scui.theme.TextBorder
         Local ifo_TempText = { Content = { Values = oString.Values, Lines  = oString.Lines },
                                Margins = { x = ifo_Marg, y = ifo_Marg },
                                Area    = { xStart = ifo_Bevel.Position.x,                    yStart = ifo_Bevel.Position.y,
                                            xEnd   = ifo_Bevel.Position.x + ifo_Bevel.Size.x, yEnd   = ifo_Bevel.Position.y + ifo_Bevel.Size.y } }

         /* Creazione strutture di default */
         Local ifo_Text   = helpers.CloneTable(scui.theme.Switch_NText)
         helpers.SetTable(ifo_Text, ifo_TempText, False)
         
         Local ifo_HText  = helpers.CloneTable(scui.theme.Switch_HText)
         helpers.SetTable(ifo_HText, ifo_TempText, False)
         
         Local ifo_PText  = helpers.CloneTable(scui.theme.Switch_PText)
         helpers.SetTable(ifo_PText, ifo_TempText, False)
         
         Local ifo_DNText = helpers.CloneTable(scui.theme.Switch_DNText)
         helpers.SetTable(ifo_DNText, ifo_TempText, False)
         
         Local ifo_DPText = helpers.CloneTable(scui.theme.Switch_DPText)
         helpers.SetTable(ifo_DPText, ifo_TempText, False)

         /* Imposto le preferenze utente */
         If helpers.FieldIsNil(oData, "text"   )=0 Then scui.FastSetText(ifo_Text,   oData.Text  )
         If helpers.FieldIsNil(oData, "htext"  )=0 Then scui.FastSetText(ifo_HText,  oData.HText )
         If helpers.FieldIsNil(oData, "ptext"  )=0 Then scui.FastSetText(ifo_PText,  oData.PText )
         If helpers.FieldIsNil(oData, "dntext" )=0 Then scui.FastSetText(ifo_DNText, oData.DNText)
         If helpers.FieldIsNil(oData, "dptext" )=0 Then scui.FastSetText(ifo_DPText, oData.DPText)

         /* Verifico se devo assegnare uno shortcut a questo pulsante */
         If helpers.FieldIsNil(oString, "shortcut")=0 Then scui.Keyboard[Owner].Shortcuts[oString.Shortcut] = id

         Local ifo_Visible = #IFO_VISIBLE
         Local ifo_Enabled = #IFO_ENABLED
         If helpers.FieldIsNil(oData, "visible")=0 Then ifo_Visible = oData.Visible
         If helpers.FieldIsNil(oData, "enabled")=0 Then ifo_Enabled = oData.Enabled

         /* Verifico se si tratta di uno Switch MultiCol */
         If helpers.FieldIsNil(oString, "multicol") = 0
            If oString.MultiCol = True
               /* Applica il MultiCol a tutte le varianti dei Bevel */
               ifo_Text.MultiCol   = True
               ifo_HText.MultiCol  = True
               ifo_PText.MultiCol  = True
               ifo_DNText.MultiCol = True
               ifo_DPText.MultiCol = True
               /* Setta le dimensioni delle colonne a tutte le varianti Bevel */
               ifo_Text.ColSizes   = helpers.CloneTable(oString.ColSizes)
               ifo_HText.ColSizes  = helpers.CloneTable(oString.ColSizes)
               ifo_PText.ColSizes  = helpers.CloneTable(oString.ColSizes)
               ifo_DNText.ColSizes = helpers.CloneTable(oString.ColSizes)
               ifo_DPText.ColSizes = helpers.CloneTable(oString.ColSizes)
               /* Se non specificata, setta la linea verticale con lo stesso tema del Bevel normale */
               /* ATTENZIONE: Potrei modificare ulteriormente specificando, sempre se non indicato  */
               /* il colore delle linee con lo stesso tema del relativo bevel associato allo stato  */
               If helpers.FieldIsNil(oString, "colbreak") = 1 Then oString.ColBreak = { DrawLines = True, Color = ifo_Bevel.Colors.Edges }
               ifo_Text.ColBreak   = helpers.CloneTable(oString.ColBreak)
               ifo_HText.ColBreak  = helpers.CloneTable(oString.ColBreak)
               ifo_PText.ColBreak  = helpers.CloneTable(oString.ColBreak)
               ifo_DNText.ColBreak = helpers.CloneTable(oString.ColBreak)
               ifo_DPText.ColBreak = helpers.CloneTable(oString.ColBreak)
            EndIf
         EndIf

         Local ifo_Type        = #IFOTYPE_BASIC
         Local ifo_Class       = #IFOCLASS_SWITCH
         Local ifo_Parent      = Nil
         Local ifo_Interactive = 1
         Local ifo_Status      = #IFOSTATUS_NORMAL

         /* Verifica se si tratta di un child */
         If helpers.IsNil(IFOParent)=0
            ifo_Type   = #IFOTYPE_CHILD
            ifo_Parent = IFOParent
         EndIf

         /* Memorizza il nuovo oggetto */
         scui.IFO[id] = { Visible      = ifo_Visible,
                          Enabled      = ifo_Enabled,
                          Status       = ifo_Status,
                          oType        = ifo_Type,
                          oClass       = ifo_Class,
                          oParent      = ifo_Parent,
                          oInteractive = ifo_Interactive,
                          Owner        = Owner,
                          oName        = oName,
                          Actions      = { },
                          Value        = ifo_Value,
                          oData        = { Bevel   = ifo_Bevel,
                                           HBevel  = ifo_HBevel,
                                           PBevel  = ifo_PBevel,
                                           DNBevel = ifo_DNBevel,
                                           DPBevel = ifo_DPBevel,
                                           Text    = ifo_Text,
                                           HText   = ifo_HText,
                                           PText   = ifo_PText,
                                           DNText  = ifo_DNText,
                                           DPText  = ifo_DPText }
                         }
         /* Assegna le azioni specificate */
         If helpers.FieldIsNil(oActions, "onchanged")=0 Then scui.IFO[id].Actions.OnChanged = oActions.OnChanged

         /* Disegna il gadget e restituisci l'id */                 
         If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(id)

         /* Crea l'area per la rilevazione degli eventi */
         MakeButton(id, #SIMPLEBUTTON , scui.IFO[id].oData.Bevel.Position.x, scui.IFO[id].oData.Bevel.Position.y,
                                        scui.IFO[id].oData.Bevel.Size.x, scui.IFO[id].oData.Bevel.Size.y, 
                                        { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject ,
                                          OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )                   
		/* Disattiva la zona se non visibile o disabilitato */
		If(ifo_Enabled = #IFO_DISABLED Or ifo_Visible = #IFO_HIDDEN) Then DisableButton(id)
		Return(id)


      Case #IFOCLASS_GAUGE
			;+---------------------------------------------------------[ GAUGE ]--+
			;| Interactive: NO                                                    |
			;| Supported Fields in Aspect table (oData)                           |
			;|  - Container      BevelStruct Structure for the container layout   |
			;|  - Cursor         BevelStruct Structure for the progress bar inside|
			;|                   the container                                    |
			;|  - Format         Format string: this is a message that will be    |
			;|                   rendered inside the progress bar, you can insert |
			;|                   key words that will be replaced by progress      |
			;|                   values as following:                             |
			;|                      $PERCENT     Insert the % progress            |
			;|                      $CURRENT     Insert the current value         |
			;|                      $MAX         Insert the max value             |
			;|                      $MIN         Insert the min value             |
			;|  - Text           TextStruct Structure for the format string inside|
			;|                   the progress bar                                 |
			;|  - Visible        #IFO_VISIBLE | #IFO_HIDDEN                       |
			;|  - Enabled        #IFO_ENABLED | #IFO_DISABLED                     |
			;| Supported Fields in Params table (oString)                         |
			;|  - MMin           Minimum value                                    |
			;|  - MMax           Maximum value                                    |
			;|  - Current        Current value                                    |
			;+--------------------------------------------------------------------+
         If helpers.IsNil(oData   )=1 Then oData    = {}
         If helpers.IsNil(oString )=1 Then oString  = {}
         If helpers.IsNil(oActions)=1 Then oActions = {}
        
         /* Crea il Bevel esterno */
         Local ifo_TempBev = { Position = { x = oPosition.x, y = oPosition.y },
                               Size     = { x = oSize.x,     y = oSize.y     }}
         Local ifo_Container = scui.NewBevel(scui.theme.Gauge_External, ifo_TempBev)
         If helpers.FieldIsNil(oData, "container" )=0 Then ifo_Container = scui.NewBevel(ifo_Container, oData.Container, 1)

         /* Crea il Cursore */
			Local mul = IIF(ifo_Container.Type = #BEVELTYPE_SUNKEN , 2, IIF(ifo_Container.Type <> #BEVELTYPE_NONE , 1, 0))
         Local ifo_ExtBord  = ifo_Container.Height * mul
         Local ifo_TempBev2 = { Position = { x = oPosition.x + ifo_ExtBord, 
                                             y = oPosition.y + ifo_ExtBord },
                                Size     = { x = ifo_Container.Size.x - ifo_ExtBord * 2,
                                             y = ifo_Container.Size.y - ifo_ExtBord * 2 }}
         Local ifo_Cursor = scui.NewBevel(scui.theme.Gauge_Internal, ifo_TempBev2)
         If helpers.FieldIsNil(oData, "cursor"    )=0 Then ifo_Cursor    = scui.NewBevel(ifo_Cursor,    oData.Cursor,    1)

         /* Crea il Testo all'interno del cursore */
			Local mul = IIF(ifo_Cursor.Type = #BEVELTYPE_SUNKEN , 2, IIF(ifo_Cursor.Type <> #BEVELTYPE_NONE , 1, 0))
         Local ifo_ExtBord2 = ifo_Cursor.Height * mul + scui.theme.TextBorder
         Local ifo_TempText = { Margins = { x = ifo_ExtBord2, y = ifo_ExtBord2 }, 
                                Area    = { xStart = ifo_Cursor.Position.x,                     yStart = ifo_Cursor.Position.y,
                                            xEnd   = ifo_Cursor.Position.x + ifo_Cursor.Size.x, yEnd   = ifo_Cursor.Position.y + ifo_Cursor.Size.y }}    
         Local ifo_Text = scui.NewText(scui.theme.Gauge_Text, ifo_TempText)
        
         Local ifo_Format      = ""
         Local ifo_Visible     = #IFO_VISIBLE
         Local ifo_Enabled     = #IFO_ENABLED
         Local ifo_Type        = #IFOTYPE_BASIC
         Local ifo_Class       = #IFOCLASS_GAUGE
         Local ifo_Parent      = nil
         Local ifo_Interactive = 0
         Local ifo_Status      = #IFOSTATUS_NORMAL
         Local ifo_Min         = 0
         Local ifo_Max         = 100
         Local ifo_Current     = 0
        
         /* Imposta le preferenze dell'utente */
         If helpers.FieldIsNil(oData, "text"      )=0 Then ifo_Text      = scui.NewText(ifo_Text, oData.Text, 1)
         If helpers.FieldIsNil(oData, "format"    )=0 Then ifo_Format    = oData.Format
         If helpers.FieldIsNil(oData, "visible"   )=0 Then ifo_Visible   = oData.Visible
         If helpers.FieldIsNil(oData, "enabled"   )=0 Then ifo_Enabled   = oData.Enabled

         If helpers.FieldIsNil(oString, "mmin"    )=0 Then ifo_Min     = oString.MMin
         If helpers.FieldIsNil(oString, "mmax"    )=0 Then ifo_Max     = oString.MMax
         If helpers.FieldIsNil(oString, "current" )=0 Then ifo_Current = oString.Current

         /* Verifica se si tratta di un child */
         If helpers.IsNil(IFOParent)=0
            ifo_Type   = #IFOTYPE_CHILD
            ifo_Parent = IFOParent
         EndIf
        
         /* Memorizza il nuovo oggetto */
         scui.IFO[id] = { Visible      = ifo_Visible,
                          Enabled      = ifo_Enabled,
                          Status       = ifo_Status,
                          oType        = ifo_Type,
                          oClass       = ifo_Class,
                          oParent      = ifo_Parent,
                          oInteractive = ifo_Interactive,
                          Owner        = Owner,
                          oName        = oName,
                          Actions      = { },
                          Values       = { MMin    = ifo_Min,
                                           MMax    = ifo_Max,
                                           Current = ifo_Current },
                          BarSize      = ifo_Cursor.Size.x,
                          oData        = { Container = ifo_Container,
                                           Cursor    = ifo_Cursor,
                                           Text      = ifo_Text,
                                           Format    = ifo_Format }}

         /* Disegna il gadget e restituisci l'id */                 
         If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(id)
			Return(id)

      Case #IFOCLASS_STRINGBOX
			;+----------------------------------------------------[ STRING BOX ]--+
         ;| Interactive: YES                                                   |
         ;| Supported Fields in Aspect table (oData)                           |
         ;|  - Bevel          BevelStruct Structure for nromal layout          |
         ;|  - HBevel         BevelStruct Structure for hilighted layout       |
         ;|  - PBevel         BevelStruct Structure for pushed layout          |
         ;|  - DBevel         BevelStruct Structure for disabled layout        |
         ;|  - Text           TextStruct Structure for nromal layout           |
         ;|  - HText          TextStruct Structure for hilighted layout        |
         ;|  - PText          TextStruct Structure for pushed layout           |
         ;|  - DText          TextStruct Structure for disabled layout         |
         ;|  - Visible        #IFO_VISIBLE or #IFO_HIDDEN                      |
         ;|  - Enabled        #IFO_ENABLED or #IFO_DISABLED                    |
         ;| Supported Fields in Params table (oString)                         |
         ;|  - InputType      Define which characters may be accepted, actually|
			;|                   can be:                                          |
         ;|                    #GETKEY_ALL        Accepts almost all characters|
         ;|                    #GETKEY_NUMERIC    Accepts numeric related char.|
         ;|                    #GETKEY_ALPHABETIC Accepts alphabetic characters|
         ;|                    #GETKEY_CUSTOM     Custom character set         |
         ;|  - Custom                                                          |
         ;|  - MaxLen         Maximun number of characters accepted            |
         ;|  - Clear1st       At frist activation clear itrs content           |
         ;|  - More options will come for edit & cursor aspect                 |
         ;| Supported Fields in Actions table (oActions)                       |
         ;|  - OnClick        Function called at gadget activation             |
         ;|  - OnExit         The function to call when we are exiting from the|
			;|                   string box                                       |
         ;|  - OnChange       The function to call when we are axiting from the|
			;|                   string box                                       |
         ;|                   and the string box's content is changed          |
         ;|  - OnKeyPress     Function called everytime the user hit a key     |
         ;| Note that when this gadget goes in edit mode the layout of the     |
			;| Container and the Text is defined by the                           |
			;| <scui.theme.StringBox_EditBox> and                                 |
			;| <scui.theme.StringBox_EditText tables>.                            |
         ;+--------------------------------------------------------------------+
         If helpers.IsNil(oData   )=1 Then oData    = {}
         If helpers.IsNil(oActions)=1 Then oActions = {}
         If helpers.IsNil(oString )=1 Then oString  = {}
        
         /* Verifica se e' stato passato il testo dello StringBox altrimenti lo crea uno di default */
         If helpers.FieldIsNil(oString, "values") = 1
            oString.Values = { "Empty" }
            oString.Lines  = 1
         ElseIf helpers.FieldIsNil(oString, "lines") = 1
            oString.Lines  = 1 ; Solo la prima linea viene gestita 
         EndIf
         ifo_String = oString.Values
         ifo_Lines  = 1
         
         /* Crea i Bevel di default */
         Local ifo_TempBev = { Position = { x = oPosition.x, y = oPosition.y },
                               Size     = { x = oSize.x,     y = oSize.y } }
         Local ifo_Bevel  = scui.NewBevel(scui.theme.StringBox_NBox, ifo_TempBev)
         Local ifo_HBevel = scui.NewBevel(scui.theme.StringBox_HBox, ifo_TempBev)
         Local ifo_PBevel = scui.NewBevel(scui.theme.StringBox_PBox, ifo_TempBev)
         Local ifo_DBevel = scui.NewBevel(scui.theme.StringBox_DBox, ifo_TempBev)
		  
         /* Preferenze utente */
         If helpers.FieldIsNil(oData, "bevel"  )=0 Then ifo_Bevel  = scui.NewBevel(ifo_Bevel,  oData.Bevel, 1)
         If helpers.FieldIsNil(oData, "hbevel" )=0 Then ifo_HBevel = scui.NewBevel(ifo_HBevel, oData.HBevel, 1)
         If helpers.FieldIsNil(oData, "pbevel" )=0 Then ifo_PBevel = scui.NewBevel(ifo_PBevel, oData.PBevel, 1)
         If helpers.FieldIsNil(oData, "dbevel" )=0 Then ifo_DBevel = scui.NewBevel(ifo_DBevel, oData.DBevel, 1)
        
         /* Margini del testo */
		 	Local mul = IIF(ifo_Bevel.Type = #BEVELTYPE_SUNKEN , 2, IIF(ifo_Bevel.Type <> #BEVELTYPE_NONE , 1, 0))

         /* Struttura temporanea per la creazione del testo */
 	      Local tmpmarg = ifo_Bevel.Height * mul + scui.theme.TextBorder
         Local ifo_TempText = { Content = { Values = ifo_String, Lines  = ifo_Lines },
                                Margins = { x = tmpmarg, y = tmpmarg },
                                Area    = { xStart = ifo_Bevel.Position.x, yStart = ifo_Bevel.Position.y,
                                            xEnd   = ifo_Bevel.Position.x + ifo_Bevel.Size.x,
                                            yEnd   = ifo_Bevel.Position.y + ifo_Bevel.Size.y } }
         /* Crea i Text di Default */
         Local ifo_Text  = scui.NewText(scui.theme.StringBox_NText, ifo_TempText)
         Local ifo_HText = scui.NewText(scui.theme.StringBox_HText, ifo_TempText)
         Local ifo_PText = scui.NewText(scui.theme.StringBox_PText, ifo_TempText)
         Local ifo_DText = scui.NewText(scui.theme.StringBox_DText, ifo_TempText)
		  
         /* Preferenze utente */
         If helpers.FieldIsNil(oData, "text"  )=0 Then ifo_Text  = scui.NewText(ifo_Text,  oData.Text, 1)
         If helpers.FieldIsNil(oData, "htext" )=0 Then ifo_HText = scui.NewText(ifo_HText, oData.Text, 1)
         If helpers.FieldIsNil(oData, "ptext" )=0 Then ifo_PText = scui.NewText(ifo_PText, oData.Text, 1)
         If helpers.FieldIsNil(oData, "dtext" )=0 Then ifo_DText = scui.NewText(ifo_DText, oData.Text, 1)
        
         /* Altre impostazioni di Default */
         Local ifo_Visible     = #IFO_VISIBLE
         Local ifo_Enabled     = #IFO_ENABLED
         Local ifo_InputType   = #GETKEY_ALL
         Local ifo_MaxLen      = 255
         Local ifo_Type        = #IFOTYPE_BASIC
         Local ifo_Class       = #IFOCLASS_STRINGBOX
         Local ifo_Parent      = nil
         Local ifo_Interactive = 1
         Local ifo_Status      = #IFOSTATUS_NORMAL
         Local ifo_Clear1st    = 0
         Local  ifo_Custom = ""
        
         /* Eventuali tag specificate dall'utente */
         If helpers.FieldIsNil(oData,   "visible"  )=0 Then ifo_Visible   = oData.Visible
         If helpers.FieldIsNil(oData,   "enabled"  )=0 Then ifo_Enabled   = oData.Enabled
         If helpers.FieldIsNil(oString, "inputtype")=0 Then ifo_InputType = oString.InputType
         If helpers.FieldIsNil(oString, "maxlen"   )=0 Then ifo_MaxLen    = oString.MaxLen
         If helpers.FieldIsNil(oString, "clear1st" )=0 Then ifo_Clear1st  = oString.Clear1st
         If ifo_InputType = #GETKEY_CUSTOM
            If helpers.FieldIsNil(oString, "custom") = 0 Then ifo_Custom = oString.Custom
         EndIf

         /* Verifica se si tratta di un child */
         If helpers.IsNil(IFOParent)=0
            ifo_Type   = #IFOTYPE_CHILD
            ifo_Parent = IFOParent
         EndIf

         /* Memorizza il nuovo oggetto */
         scui.IFO[id] = { Visible      = ifo_Visible,
                          Enabled      = ifo_Enabled,
                          Status       = ifo_Status,
                          oType        = ifo_Type,
                          oClass       = ifo_Class,
                          oParent      = ifo_Parent,
                          oInteractive = ifo_Interactive,
                          Owner        = Owner,
                          oName        = oName,
                          Clear1st     = ifo_Clear1st,
                          MaxLen       = ifo_MaxLen,
                          InputType    = ifo_InputType,
                          CustomCharacters = ifo_Custom,
                          Actions      = { },
                          oData        = { Bevel  = ifo_Bevel,
                                           HBevel = ifo_HBevel,
                                           PBevel = ifo_PBevel,
                                           DBevel = ifo_DBevel,
                                           Text   = ifo_Text,
                                           HText  = ifo_HText,
                                           PText  = ifo_PText,
                                           DText  = ifo_DText }
                         }
         /* Assegna gli eventi */
         If helpers.FieldIsNil(oActions, "onclick"   )=0 Then scui.IFO[id].Actions.OnClick    = oActions.OnClick
         If helpers.FieldIsNil(oActions, "onexit"    )=0 Then scui.IFO[id].Actions.OnExit     = oActions.OnExit
         If helpers.FieldIsNil(oActions, "onchange"  )=0 Then scui.IFO[id].Actions.OnChange   = oActions.OnChange
         If helpers.FieldIsNil(oActions, "onkeypress")=0 Then scui.IFO[id].Actions.OnKeyPress = oActions.OnKeyPress
         If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(id)

         /* Crea la zona attiva */
         MakeButton(id, #SIMPLEBUTTON, scui.IFO[id].oData.Bevel.Position.x, scui.IFO[id].oData.Bevel.Position.y,
                                       scui.IFO[id].oData.Bevel.Size.x, scui.IFO[id].oData.Bevel.Size.y, 
                    { OnMouseOver = scui.HandleObject , OnMouseOut = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )                      
			/* Disattiva la zona se non visibile o disabilitato */
			If(ifo_Enabled = #IFO_DISABLED Or ifo_Visible = #IFO_HIDDEN) Then DisableButton(id)
			Return(id)
 

      Case #IFOCLASS_SIMPLESCROLLER
			;+----------------------------------------------[ SIMPLE SCROLLER ]--+
         ;| Interactive: YES                                                  |
         ;| Supported Fields in Aspect table (oData)                          |
         ;|  - Container      BevelStruct: normal container layout            |
         ;|  - HContainer     BevelStruct: hilighted container layout         |
         ;|  - DContainer     BevelStruct: disabled container layout          |
         ;|  - Cursor         BevelStruct: normal scroller cursor layout      |
         ;|  - HCursor        BevelStruct: normal scroller cursor layout      |
         ;|  - PCursor        BevelStruct: normal scroller cursor layout      |
         ;|  - DCursor        BevelStruct: normal scroller cursor layout      |
         ;|  - Text           TextStruct: normal text inside the cursor       |
         ;|  - HText          TextStruct: hilighted text inside the cursor    |
         ;|  - PText          TextStruct: pushed text inside the cursor       |
         ;|  - DText          TextStruct: disabled text inside the cursor     |
         ;|  - Visible        #IFO_VISIBLE or #IFO_HIDDEN                     |
         ;|  - Enabled        #IFO_ENABLED or #IFO_DISABLED                   |
         ;| Supported Fields in Params table (oString)                        |
         ;|  - CursorText     This string will be rendered inside the scroller|
         ;|                   cursor                                          |
         ;|  - MMin           Minimum scroller value                          |
         ;|  - MMax           Maximum scroller value                          |
         ;|  - Current        Current scroller value                          |
         ;|  - MinStep        This is the scroller step when you click outside|
         ;|                   the scroller cursor (but inside the container)  |
         ;|  - Type           Define the scroller type and can be:            |
         ;|                     #SCROLLERTYPE_VERTICAL   for vert. scroller   |
         ;|                     #SCROLLERTYPE_HORIZONTAL for horiz. scroller  |
         ;|  - More options will come for text inside cursor                  |
         ;| Supported Fields in Actions table (oActions)                      |
         ;|  - OnDrag         The function to call when the cursor scroller is|
         ;|                   dragged around                                  |
         ;|  - OnChange       The function to call when the scroller value    |
         ;|                   changes                                         |
         ;+-------------------------------------------------------------------+
         If helpers.IsNil(ForceID) = 0
            /* GADGET REGENERATION: Reload current data */
            Local Obj = scui.IFO[ForceID]
            Local ObjData = scui.IFO[ForceID].oData
            Owner     = Obj.Owner
            oName     = Obj.oName
            oPosition = { x = ObjData.Container.Position.x, y = ObjData.Container.Position.y }
            oSize     = { x = ObjData.Container.Size.x,     y = ObjData.Container.Size.y }
            oData     = { Container  = scui.NewBevel(ObjData.Container, nil, 1),
                          HContainer = scui.NewBevel(ObjData.HContainer, nil, 1),
                          DContainer = scui.NewBevel(ObjData.DContainer, nil, 1),
                          Cursor     = scui.NewBevel(ObjData.Cursor, nil, 1),
                          HCursor    = scui.NewBevel(ObjData.HCursor, nil, 1),
                          PCursor    = scui.NewBevel(ObjData.PCursor, nil, 1),
                          DCursor    = scui.NewBevel(ObjData.DCursor, nil, 1),
                          Text       = scui.NewText(ObjData.Text, nil, 1),
                          HText      = scui.NewText(ObjData.HText, nil, 1),
                          PText      = scui.NewText(ObjData.PText, nil, 1),
                          DText      = scui.NewText(ObjData.DText, nil, 1),
                          Visible    = Obj.Visible,
                          Enabled    = Obj.Enabled }
            oString   = { MMin       = Obj.Values.MMin,
                          MMax       = Obj.Values.MMax,
                          Current    = Obj.Values.Current,
                          MinStep    = Obj.Values.MinStep,
                          Type       = Obj.Type }
            oActions  = { }

            If helpers.FieldIsNil(Obj.Actions, "onchange" ) = 0 Then oActions.OnChange = Obj.Actions.OnChange
            If helpers.FieldIsNil(Obj.Actions, "ondrag"   ) = 0 Then oActions.OnDrag   = Obj.Actions.OnDrag
         EndIf

         If helpers.IsNil(oData   )=1 Then oData    = {}
         If helpers.IsNil(oActions)=1 Then oActions = {}
         If helpers.IsNil(oString )=1 Then oString  = {}

         /* Verifica e imposta il testo nel cursore */
         Local ifo_CursorText = { Values = { "" }, Lines = 1 }
         If helpers.FieldIsNil(oString, "cursortext") = 0 Then ifo_CursorText = { Values = { oString.CursorText }, Lines = 1 }

         /* Verifica e imposta: MMin, MMax, Current, Type & MinStep */
         Local ifo_MMin    = 0
         Local ifo_MMax    = 100
         Local ifo_Current = 0
         Local ifo_MinStep = 5
         Local ifo_ScrType = #SCROLLERTYPE_VERTICAL
         If helpers.FieldIsNil(oString, "mmin"   ) = 0 Then ifo_MMin    = oString.MMin
         If helpers.FieldIsNil(oString, "mmax"   ) = 0 Then ifo_MMax    = oString.MMax
         If helpers.FieldIsNil(oString, "current") = 0 Then ifo_Current = oString.Current
         If helpers.FieldIsNil(oString, "minstep") = 0 Then ifo_MinStep = oString.MinStep
         If helpers.FieldIsNil(oString, "type"   ) = 0 Then ifo_ScrType = oString.Type
         If ifo_Current < ifo_MMin Then ifo_Current = ifo_MMin
         If ifo_Current > ifo_MMax Then ifo_Current = ifo_MMax
         Local ifo_Values = { MMin = ifo_MMin, MMax = ifo_MMax, Current = ifo_Current, MinStep = ifo_MinStep }

         Local ifo_AContainer = { xStart = oPosition.x, yStart = oPosition.y,
                                  xEnd   = oPosition.x + oSize.x, yEnd = oPosition.y + oSize.y }
         Local ifo_oContainer = { Position = { x = oPosition.x, y = oPosition.y },
                                  Size     = { x = oSize.x,     y = oSize.y } }
         /* Container */
         Local ifo_tContainer = scui.NewBevel(scui.theme.SScroller_NContainer, ifo_oContainer)
         If helpers.FieldIsNil(oData, "container")=0 Then ifo_tContainer = scui.NewBevel(ifo_tContainer, oData.Container, 1)

			Local mul = IIF(ifo_tContainer.Type = #BEVELTYPE_SUNKEN , 2, IIF(ifo_tContainer.Type <> #BEVELTYPE_NONE , 1, 0))
         Local CursorOffset = ifo_tContainer.Height * mul
        
         /* Orintation-based calculations */
         Local WorkingHeight = 0
         Local CursorRange = ifo_Values.MMax - ifo_Values.MMin + 1
         If ifo_ScrType = #SCROLLERTYPE_VERTICAL 
            WorkingHeight = ifo_AContainer.yEnd - ifo_AContainer.yStart - CursorOffset * 2
         ElseIf ifo_ScrType = #SCROLLERTYPE_HORIZONTAL 
            WorkingHeight = ifo_AContainer.xEnd - ifo_AContainer.xStart - CursorOffset * 2
         Else
            scui.Error("SCUI ERROR",
                       "Unknown Scroller Type.\n"..
                       "You have tried to create a Scroller of type '" .. ifo_ScrType .. "'\n\n" ..
                       "What do you want to do?")
                       /* Restore the IDCounter */
                       scui.IFO.IDCounter = scui.IFO.IDCounter - 1
                       Return
         EndIf
         Local PixelUnit = WorkingHeight / CursorRange
         Local CursSize  = IIF( Pixelunit >= scui.theme.SScroller_MinCursorSize, PixelUnit, scui.theme.SScroller_MinCursorSize )
         Local CursorBlock = {}
        
         /* CursorBlock Position & Dimensions */
         If ifo_ScrType = #SCROLLERTYPE_VERTICAL
            CursorBlock = { Position = { x = oPosition.x + CursorOffset,
                                         y = oPosition.y + CursorOffset + (ifo_Values.Current - ifo_Values.MMin) * PixelUnit },
                            Size     = { x = oSize.x - CursorOffset * 2, 
                                         y = CursSize } }
         Else
            CursorBlock = { Position = { x = oPosition.x + CursorOffset + (ifo_Values.Current - ifo_Values.MMin) * PixelUnit,
                                         y = oPosition.y + CursorOffset },
                            Size     = { x = CursSize, 
                                         y = oSize.y - CursorOffset * 2 } }
         EndIf
                
         /* Bevel Temporaneo per creare la textstruct */
         Local ifo_TempText = { Position = { x = oPosition.x, y = oPosition.y },
                               Size     = { x = oSize.x,     y = oSize.y } }
         Local dummybevel = scui.NewBevel(scui.theme.SScroller_NCursor, ifo_TempText)
       
         /* Text's margins */
			Local mul = IIF(dummybevel.Type = #BEVELTYPE_SUNKEN , 2, IIF(dummybevel.Type <> #BEVELTYPE_NONE , 1, 0))
         If dummybevel.Type = #BEVELTYPE_SUNKEN Then mul = 2

         /* Struttura per creare l'etichetta di testo */
         Local ttx = { Content = { Values = ifo_CursorText.Values, Lines  = ifo_CursorText.Lines },
                       Margins = { x = dummybevel.Height * mul + scui.theme.TextBorder, 
                                   y = dummybevel.Height * mul + scui.theme.TextBorder },
                       Area    = { xStart = CursorBlock.Position.x, yStart = CursorBlock.Position.y,
                                   xEnd   = CursorBlock.Position.x + CursorBlock.Size.x,
                                   yEnd   = CursorBlock.Position.y + CursorBlock.Size.y } }

         /* Container */
         Local ifo_Container  = ifo_tContainer
         Local ifo_HContainer = scui.NewBevel(scui.theme.SScroller_HContainer, ifo_oContainer)
         Local ifo_DContainer = scui.NewBevel(scui.theme.SScroller_DContainer, ifo_oContainer)
        
         If helpers.FieldIsNil(oData, "hcontainer")=0 Then ifo_HContainer = scui.NewBevel(ifo_HContainer, oData.HContainer, 1)
         If helpers.FieldIsNil(oData, "dcontainer")=0 Then ifo_DContainer = scui.NewBevel(ifo_DContainer, oData.DContainer, 1)
        
         /* Cursor */
         Local ifo_Cursor  = scui.NewBevel(scui.theme.SScroller_NCursor, CursorBlock)
         Local ifo_HCursor = scui.NewBevel(scui.theme.SScroller_HCursor, CursorBlock)
         Local ifo_PCursor = scui.NewBevel(scui.theme.SScroller_PCursor, CursorBlock)
         Local ifo_DCursor = scui.NewBevel(scui.theme.SScroller_DCursor, CursorBlock)
 
         If helpers.FieldIsNil(oData, "cursor" )=0 Then ifo_Cursor  = scui.NewBevel(ifo_Cursor,  oData.Cursor, 1)
         If helpers.FieldIsNil(oData, "hcursor")=0 Then ifo_HCursor = scui.NewBevel(ifo_HCursor, oData.HCursor, 1)
         If helpers.FieldIsNil(oData, "pcursor")=0 Then ifo_PCursor = scui.NewBevel(ifo_PCursor, oData.PCursor, 1)
         If helpers.FieldIsNil(oData, "dcursor")=0 Then ifo_DCursor = scui.NewBevel(ifo_DCursor, oData.DCursor, 1)
       
         /* Cursor's Text */
         Local ifo_Text  = scui.NewText(scui.theme.SScroller_NText, ttx)   
         Local ifo_HText = scui.NewText(scui.theme.SScroller_HText, ttx)
         Local ifo_PText = scui.NewText(scui.theme.SScroller_PText, ttx)
         Local ifo_DText = scui.NewText(scui.theme.SScroller_DText, ttx)

         If helpers.FieldIsNil(oData, "text" )=0 Then ifo_Text  = scui.NewText(ifo_Text,  oData.Text, 1)
         If helpers.FieldIsNil(oData, "htext")=0 Then ifo_HText = scui.NewText(ifo_HText, oData.HText, 1)
         If helpers.FieldIsNil(oData, "ptext")=0 Then ifo_PText = scui.NewText(ifo_PText, oData.PText, 1)
         If helpers.FieldIsNil(oData, "dtext")=0 Then ifo_DText = scui.NewText(ifo_DText, oData.DText, 1)
        
         Local ifo_Visible     = #IFO_VISIBLE
         Local ifo_Enabled     = #IFO_ENABLED
         Local ifo_Status      = #IFOSTATUS_NORMAL
         Local ifo_Interactive = 1
         Local ifo_Class       = #IFOCLASS_SIMPLESCROLLER
         Local ifo_Parent      = nil
         Local ifo_Type        = #IFOTYPE_BASIC
         
         If helpers.FieldIsNil(oData, "visible")=0 Then ifo_Visible = oData.Visible
         If helpers.FieldIsNil(oData, "enabled")=0 Then ifo_Enabled = oData.Enabled

         /* Verifica se si tratta di un child */
         If helpers.IsNil(IFOParent)=0
            ifo_Type   = #IFOTYPE_CHILD
            ifo_Parent = IFOParent
         EndIf

         scui.IFO[id] = { Visible      = ifo_Visible,
                          Enabled      = ifo_Enabled,
                          Status       = ifo_Status,
                          oType        = ifo_Type,
                          oClass       = ifo_Class,
                          oParent      = ifo_Parent,
                          oInteractive = ifo_Interactive,
                          Owner        = Owner,
                          oName        = oName,
                          Values       = { MMax = ifo_Values.MMax, 
                                           MMin = ifo_Values.MMin, 
                                           Current = ifo_Values.Current, 
                                           MinStep = ifo_Values.MinStep },
                          Cursor       = { xStart = CursorBlock.Position.x, 
                                           yStart = CursorBlock.Position.y,
                                           xEnd   = CursorBlock.Position.x + CursorBlock.Size.x,
                                           yEnd   = CursorBlock.Position.y + CursorBlock.Size.y },
                          CursorOffset = CursorOffset,
                          PixelUnit    = PixelUnit,
                          Type         = ifo_ScrType,
                          Actions      = { },
                          oData        = { Cursor     = ifo_Cursor,
                                           HCursor    = ifo_HCursor,
                                           PCursor    = ifo_PCursor,
                                           DCursor    = ifo_DCursor,
                                           Container  = ifo_Container,
                                           HContainer = ifo_HContainer,
                                           DContainer = ifo_DContainer,
                                           Text       = ifo_Text,
                                           HText      = ifo_HText,
                                           PText      = ifo_PText,
                                           DText      = ifo_DText }
                         }

         /* Handle the gradient orientation */
         If (ifo_ScrType = #SCROLLERTYPE_VERTICAL) And (helpers.IsNil(ForceID) = 1)
            scui.IFO[id].oData.Cursor.GradientAngle  = scui.IFO[id].oData.Cursor.GradientAngle  + 90
            scui.IFO[id].oData.HCursor.GradientAngle = scui.IFO[id].oData.HCursor.GradientAngle + 90
            scui.IFO[id].oData.PCursor.GradientAngle = scui.IFO[id].oData.PCursor.GradientAngle + 90
            scui.IFO[id].oData.DCursor.GradientAngle = scui.IFO[id].oData.DCursor.GradientAngle + 90
            scui.IFO[id].oData.Container.GradientAngle  = scui.IFO[id].oData.Container.GradientAngle  + 90
            scui.IFO[id].oData.HContainer.GradientAngle = scui.IFO[id].oData.HContainer.GradientAngle + 90
            scui.IFO[id].oData.DContainer.GradientAngle = scui.IFO[id].oData.DContainer.GradientAngle + 90

         EndIf

         /* Setta le azioni */    
         If helpers.FieldIsNil(oActions, "onchange") = 0 Then scui.IFO[id].Actions.OnChange = oActions.OnChange
         If helpers.FieldIsNil(oActions, "ondrag"  ) = 0 Then scui.IFO[id].Actions.OnDrag   = oActions.OnDrag
         If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(id)

         /* Setta la gestione degli eventi */
         MakeButton(id, #SIMPLEBUTTON, ifo_AContainer.xStart, ifo_AContainer.yStart, ifo_AContainer.xEnd - ifo_AContainer.xStart, ifo_AContainer.yEnd - ifo_AContainer.yStart, 
                    { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )
			/* Disattiva la zona se non visibile o disabilitato */
			If(ifo_Enabled = #IFO_DISABLED Or ifo_Visible = #IFO_HIDDEN) Then DisableButton(id)
			Return(id)

      Case #IFOCLASS_SCROLLER
			;+----------------------------------------------[ SIMPLE SCROLLER ]--+
         ;| Interactive: YES                                                  |
         ;| Supported Fields in Aspect table (oData)                          |
         ;|  - Container      BevelStruct: normal container layout            |
         ;|  - HContainer     BevelStruct: hilighted container layout         |
         ;|  - DContainer     BevelStruct: disabled container layout          |
         ;|  - Cursor         BevelStruct: normal scroller cursor layout      |
         ;|  - HCursor        BevelStruct: normal scroller cursor layout      |
         ;|  - PCursor        BevelStruct: normal scroller cursor layout      |
         ;|  - DCursor        BevelStruct: normal scroller cursor layout      |
         ;|  - Text           TextStruct: normal text inside the cursor       |
         ;|  - HText          TextStruct: hilighted text inside the cursor    |
         ;|  - PText          TextStruct: pushed text inside the cursor       |
         ;|  - DText          TextStruct: disabled text inside the cursor     |
         ;|  - Visible        #IFO_VISIBLE or #IFO_HIDDEN                     |
         ;|  - Enabled        #IFO_ENABLED or #IFO_DISABLED                   |
         ;| Supported Fields in Params table (oString)                        |
         ;|  - VisibleItems   Numero elementi visibili                        |
         ;|  - TotalItems     Numero massimo di elementi da rappresentare     |
         ;|  - FirstItem      Primo elemento visualizzato                     |
         ;|  - ArrowMode      0-None, 1-Top, 2-Bottom, 3-Sides                |
         ;|  - CursorText     0-None, 1-Fixed, 2-Value                        |
         ;|  - CursorContent  Contentuto del cursore
         ;|  - HandleType     0-None, 1-Box, 3-Lines - mostrato solo se non c'è testo
         ;|  - ArrowStep                                                      |
         ;|  - ClickStep                                                      |
         ;|  - Type           Define the scroller type and can be:            |
         ;|                     #SCROLLERTYPE_VERTICAL   for vert. scroller   |
         ;|                     #SCROLLERTYPE_HORIZONTAL for horiz. scroller  |
         ;| Supported Fields in Actions table (oActions)                      |
         ;|  - OnDrag         The function to call when the cursor scroller is|
         ;|                   dragged around                                  |
         ;|  - OnChange       The function to call when the scroller value    |
         ;|                   changes                                         |
         ;+-------------------------------------------------------------------+
         If helpers.IsNil(ForceID) = 0
            /* GADGET REGENERATION: Reload current data */
            Local Obj = scui.IFO[ForceID]
            Local ObjData = scui.IFO[ForceID].oData
            Owner     = Obj.Owner
            oName     = Obj.oName
            oPosition = { x = ObjData.Container.Position.x, y = ObjData.Container.Position.y }
            oSize     = { x = ObjData.Container.Size.x,     y = ObjData.Container.Size.y }
            oData     = { Container  = scui.NewBevel(ObjData.Container, nil, 1),
                          HContainer = scui.NewBevel(ObjData.HContainer, nil, 1),
                          DContainer = scui.NewBevel(ObjData.DContainer, nil, 1),
                          Cursor     = scui.NewBevel(ObjData.Cursor, nil, 1),
                          HCursor    = scui.NewBevel(ObjData.HCursor, nil, 1),
                          PCursor    = scui.NewBevel(ObjData.PCursor, nil, 1),
                          DCursor    = scui.NewBevel(ObjData.DCursor, nil, 1),
                          Text       = scui.NewText(ObjData.Text, nil, 1),
                          HText      = scui.NewText(ObjData.HText, nil, 1),
                          PText      = scui.NewText(ObjData.PText, nil, 1),
                          DText      = scui.NewText(ObjData.DText, nil, 1),
                          Visible    = Obj.Visible,
                          Enabled    = Obj.Enabled }
            oString   = { TotalItems   = Obj.TotalItems,
                          VisibleItems = Obj.VisibleItems,
                          FirstItem    = Obj.FirstItem,
                          ArrowMode    = Obj.ArrowMode,
								  CursorText   = Obj.CursorText,
                          CursorContent= Obj.CursorContent,
								  HandleType   = Obj.HandleType,
								  ArrowStep		= Obj.ArrowStep,
								  MinCursorSize= Obj.MinCursorSize,
								  ;ClickStep		= Obj.ClickStep,
								  ArrowSize    = Obj.ArrowSize,
                          ValueOffset  = Obj.ValueOffset,
                          Type         = Obj.Type }
				If Obj.FlagSquareArrows Then oString.ArrowSize = #SCROLLER_SQUAREARROWS
				
            oActions  = { }

            If helpers.FieldIsNil(Obj.Actions, "onchange" ) = 0 Then oActions.OnChange = Obj.Actions.OnChange
            If helpers.FieldIsNil(Obj.Actions, "ondrag"   ) = 0 Then oActions.OnDrag   = Obj.Actions.OnDrag

				; Se prima c'erano i pulsanti adesso devo eliminarli
				If helpers.FieldIsNil(Obj, "childs") = 0
					scui.RemoveObject(Obj.Childs[1])
					scui.RemoveObject(Obj.Childs[2])
				EndIf
         EndIf
         /* CARICAMENTO DELLE PREFERENZE */
         Local ArrowSize     = scui.theme.Scroller_ArrowSize
         Local ArrowMode     = scui.theme.Scroller_ArrowMode
         Local MinCursorSize = scui.theme.Scroller_MinCursorSize
         Local CursorText    = scui.theme.Scroller_CursorText
			Local KnobType      = scui.theme.Scroller_KnobType
         Local ArrowStep     = scui.theme.Scroller_ArrowStep
                  
         Local ObjID = id
         If helpers.IsNil(oData   )=1 Then oData    = {}
         If helpers.IsNil(oActions)=1 Then oActions = {}
         If helpers.IsNil(oString )=1 Then oString  = {}

         /* Controllo Tag: ArrowMode, ArrowSize, ArrowStep, MinCursorSize, HandleType */
         If helpers.FieldIsNil(oString, "arrowmode")     = 0 Then ArrowMode = oString.ArrowMode
         If helpers.FieldIsNil(oString, "arrowsize")     = 0 Then ArrowSize = oString.ArrowSize
         If helpers.FieldIsNil(oString, "arrowstep")     = 0 Then ArrowStep = oString.ArrowStep
         If helpers.FieldIsNil(oString, "mincursorsize") = 0 Then MinCursorSize = oString.MinCursorSize
			If helpers.FieldIsNil(oString, "handletype")    = 0 Then KnobType = oString.HandleType

         /* Definizione ScrollerArea: Rettangolo dello Scroller da creare */
         Local ScrollerArea = { Position = { x = oPosition.x, y = oPosition.y }, Size = { x = oSize.x, y = oSize.y } }
         
         /* Creazione ifo_tContainer e delle sue varianti: Contenitore dello Scroller */
         Local ifo_tContainer = scui.NewBevel(scui.theme.SScroller_NContainer, ScrollerArea)
         Local ifo_hContainer = scui.NewBevel(scui.theme.SScroller_HContainer, ScrollerArea)
         Local ifo_dContainer = scui.NewBevel(scui.theme.SScroller_DContainer, ScrollerArea)
         If helpers.FieldIsNil(oData, "container" )=0 Then ifo_tContainer = scui.NewBevel(ifo_tContainer, oData.Container, 1)
         If helpers.FieldIsNil(oData, "hcontainer")=0 Then ifo_hContainer = scui.NewBevel(ifo_hContainer, oData.HContainer, 1)
         If helpers.FieldIsNil(oData, "dcontainer")=0 Then ifo_dContainer = scui.NewBevel(ifo_dContainer, oData.DContainer, 1)

         /* Pulsanti Freccie e Cursore */
         ;--| Calcola il bordo del container
         Local SABorder = IIF(ifo_tContainer.Type = #BEVELTYPE_SUNKEN , 2, IIF(ifo_tContainer.Type <> #BEVELTYPE_NONE , 1, 0))
     
         ;--| In base al tipo e al modo delle freccie calcola le aree dei
			;  | pulsanti e l'area attiva del cursore
         Local ArrowMinusArea = {}
         Local ArrowPlusArea  = {}
         Local CursorArea     = {}
         
			;--| Definzione delle aree dello scroller e di eventuali pulsanti
			Local FlagSquareArrows = False
			If ArrowSize = #SCROLLER_SQUAREARROWS Then FlagSquareArrows = True

         If oString.Type = #SCROLLERTYPE_VERTICAL
            /* VERTICAL SCROLLER */
            Local AreaWidth = oSize.x - SABorder * 2 - 1
            If ArrowSize = #SCROLLER_SQUAREARROWS
					ArrowSize = AreaWidth
				EndIf

            Switch oString.ArrowMode
               Case #SCROLLER_ARROWS_NONE
                  ; === NONE: Nessuna freccia ===
                  ArrowMinusArea = nil
                  ArrowPlusArea  = nil
                  CursorArea = { Position = { x = oPosition.x + SABorder, y = oPosition.y + SABorder + 1},
                                 Size     = { x = AreaWidth, y = oSize.y - SABorder * 2 } }

               Case #SCROLLER_ARROWS_BOTTOM
                  ; === BOTH TOP: Freccie in alto ===
                  ArrowMinusArea = { Position = { x = oPosition.x + SABorder, y = oPosition.y + SABorder },
                                     Size     = { x = AreaWidth, y = ArrowSize } }
                  ArrowPlusArea  = { Position = { x = ArrowMinusArea.Position.x, y = ArrowMinusArea.Position.y + ArrowMinusArea.Size.y },
                                     Size     = { x = AreaWidth, y = ArrowSize } }
                  CursorArea = { Position = { x = oPosition.x + SABorder, y = ArrowPlusArea.Position.y + ArrowPlusArea.Size.y + 1 },
                                 Size     = { x = AreaWidth, y = oSize.y - SABorder * 2 - ArrowSize * 2 } }
               Case #SCROLLER_ARROWS_TOP
                  ; === BOTH BOTTOM: Freccie in basso ===
                  CursorArea = { Position = { x = oPosition.x + SABorder, y = oPosition.y + SABorder + 1},
                                 Size     = { x = AreaWidth, y = oSize.y - SABorder * 2 - ArrowSize * 2 } }
                  ArrowMinusArea = { Position = { x = oPosition.x + SABorder, y = CursorArea.Position.y + CursorArea.Size.y },
                                     Size     = { x = AreaWidth, y = ArrowSize - 1 } }
                  ArrowPlusArea  = { Position = { x = ArrowMinusArea.Position.x, y = ArrowMinusArea.Position.y + ArrowMinusArea.Size.y },
                                     Size     = { x = AreaWidth, y = ArrowSize - 1} }

               Case #SCROLLER_ARROWS_SIDES
                  ; === SIDES: Freccie agli estremi ===
                  ArrowMinusArea = { Position = { x = oPosition.x + SABorder, y = oPosition.y + SABorder },
                                     Size     = { x =  AreaWidth, y = ArrowSize } }
                  CursorArea = { Position = { x = ArrowMinusArea.Position.x, y = ArrowMinusArea.Position.y + ArrowSize },
                                 Size     = { x = AreaWidth, y = oSize.y - SABorder * 2 - ArrowSize * 2 } }
                  ArrowPlusArea  = { Position = { x = CursorArea.Position.x, y = CursorArea.Position.y + CursorArea.Size.y },
                                     Size     = { x = AreaWidth, y = ArrowSize } }
            EndSwitch
                  
         Else
            /* HORIZONTAL SCROLLER */
            AreaHeight = oSize.y - SABorder * 2
            If ArrowSize = #SCROLLER_SQUAREARROWS Then ArrowSize = AreaHeight
            Switch ArrowMode
               Case #SCROLLER_ARROWS_NONE
                  ; === NONE: Nessuna freccia ===
                  ArrowMinusArea = nil
                  ArrowPlusArea  = nil
                  CursorArea = { Position = { x = oPosition.x + SABorder + 1, y = oPosition.y + SABorder },
                                 Size     = { x = oSize.x - SABorder * 2, y = AreaHeight} }

               Case #SCROLLER_ARROWS_BOTTOM
                  ; === BOTH TOP: Freccie a sinistra ===
                  ArrowMinusArea = { Position = { x = oPosition.x + SABorder, y = oPosition.y + SABorder },
                                     Size     = { x = ArrowSize, y = AreaHeight } }
                  ArrowPlusArea  = { Position = { x = ArrowMinusArea.Position.x + ArrowMinusArea.Size.x + 1, y = ArrowMinusArea.Position.y },
                                     Size     = { x = ArrowSize, y = AreaHeight } }
                  CursorArea = { Position = { x = ArrowPlusArea.Position.x + ArrowPlusArea.Size.x + 1, y = oPosition.y + SABorder },
                                 Size     = { x = oSize.x - SABorder * 2 - ArrowSize * 2, y = AreaHeight } }

               Case #SCROLLER_ARROWS_TOP
                  ; === BOTH BOTTOM: Freccie a destra ===
                  CursorArea = { Position = { x = oPosition.x + SABorder + 1, y = oPosition.y + SABorder },
                                 Size     = { x = oSize.x - SABorder * 2 - ArrowSize * 2, y = AreaHeight } }
                  ArrowMinusArea = { Position = { x = CursorArea.Position.x + CursorArea.Size.x, y = oPosition.y + SABorder },
                                     Size     = { x = ArrowSize - 1, y = AreaHeight } }
                  ArrowPlusArea  = { Position = { x = ArrowMinusArea.Position.x + ArrowMinusArea.Size.x + 1, y = ArrowMinusArea.Position.y },
                                     Size     = { x = ArrowSize - 1, y = AreaHeight } }

               Case #SCROLLER_ARROWS_SIDES
                  ; === SIDES: Freccie agli estremi ===
                  ArrowMinusArea = { Position = { x = oPosition.x + SABorder, y = oPosition.y + SABorder },
                                     Size     = { x = ArrowSize - 1, y = AreaHeight } }
                  CursorArea = { Position = { x = ArrowMinusArea.Position.x + ArrowSize, y = ArrowMinusArea.Position.y },
                                 Size     = { x = oSize.x - SABorder * 2 - ArrowSize * 2, y = AreaHeight } }
                  ArrowPlusArea  = { Position = { x = CursorArea.Position.x + CursorArea.Size.x, y = CursorArea.Position.y },
                                     Size     = { x = ArrowSize - 1, y = AreaHeight } }
               EndSwitch
         
         EndIf

         /* Calcolo del cursore */
         ; Parametri di default
         Local TotalItems    = 1000
         Local VisibleItems  =   50
         Local ItemsPerPixel =    1
         Local FirstItem     =    0
         Local ValueOffset   =    0
         
         ; Parsing delle tag
         If helpers.FieldIsNil(oString, "totalitems"  ) = 0 Then TotalItems    = oString.TotalItems
         If helpers.FieldIsNil(oString, "visibleitems") = 0 Then VisibleItems  = oString.VisibleItems
         If helpers.FieldIsNil(oString, "firstitem"   ) = 0 Then FirstItem     = oString.FirstItem
         If helpers.FieldIsNil(oString, "valueoffset" ) = 0 Then ValueOffset   = oString.ValueOffset
         Local ClickStep = VisibleItems
         If helpers.FieldIsNil(oString, "clickstep"   ) = 0 Then ClickStep     = oString.ClickStep

         ; Controllo valori
         If VisibleItems > TotalItems Then VisibleItems = TotalItems
         If FirstItem > (TotalItems - VisibleItems) Then FirstItem = (TotalItems - VisibleItems)
         If FirstItem < 0 Then FirstItem = 0
         
         ; Loop di calcolo (cambia scala se il cursore e' troppo piccolo)
         Local CursorSize     = 0
         Local CursorPosition = 0
         Local PixelPerItem   = 0

         AreaSize = IIF(oString.Type = #SCROLLERTYPE_VERTICAL , CursorArea.Size.y - 1, CursorArea.Size.x - 1)
         PixelPerItem = AreaSize / (TotalItems)
         CursorSize = PixelPerItem * VisibleItems
         If CursorSize < MinCursorSize
            ; Rettifico togliendo lo spazio utilizzato dal cursore
            Local Delta = MinCursorSize - CursorSize
            CursorSize = MinCursorSize
            PixelPerItem = (AreaSize-Delta)/TotalItems
         EndIf
         CursorPosition = FirstItem * PixelPerItem

         /* Creazione del blocco del cursore */
         If oString.Type = #SCROLLERTYPE_VERTICAL
            ; Vertical Scroller
            Cursor = { Position = { x = CursorArea.Position.x, y = CursorPosition + CursorArea.Position.y},
                       Size     = { x = CursorArea.Size.x    , y = CursorSize     } }
         Else
            ; Horizontal Scroller
            Cursor = { Position = { x = CursorPosition + CursorArea.Position.x, y = CursorArea.Position.y },
                       Size     = { x = CursorSize,     y = CursorArea.Size.y     } }
         EndIf
         
         ; Creazione del cursore e delle sue varianti
         Local ifo_CursorBlock  = scui.NewBevel(scui.theme.SScroller_NCursor, Cursor)
         Local ifo_hCursorBlock = scui.NewBevel(scui.theme.SScroller_HCursor, Cursor)
         Local ifo_pCursorBlock = scui.NewBevel(scui.theme.SScroller_PCursor, Cursor)
         Local ifo_dCursorBlock = scui.NewBevel(scui.theme.SScroller_DCursor, Cursor)
         ;Parsing delle tag del cursore
         If helpers.FieldIsNil(oData, "cursor"  )=0 Then ifo_CursorBlock  = scui.NewBevel(ifo_CursorBlock,  oData.Cursor,  1)
         If helpers.FieldIsNil(oData, "hcursor" )=0 Then ifo_hCursorBlock = scui.NewBevel(ifo_hCursorBlock, oData.hCursor, 1)
         If helpers.FieldIsNil(oData, "pcursor" )=0 Then ifo_pCursorBlock = scui.NewBevel(ifo_pCursorBlock, oData.pCursor, 1)
         If helpers.FieldIsNil(oData, "dcursor" )=0 Then ifo_dCursorBlock = scui.NewBevel(ifo_dCursorBlock, oData.dCursor, 1)

         /* GESTIONE TESTO ALL'INTERNO DEL CURSORE */
         Local TextMode     = CursorText
         Local TextContent  = { "" }
         Local CursorHeight = IIF(ifo_CursorBlock.Type = #BEVELTYPE_SUNKEN , 2, IIF(ifo_CursorBlock.Type <> #BEVELTYPE_NONE , 1, 0))
 
         If helpers.FieldIsNil(oString, "cursortext"    )=0 Then TextMode    = oString.CursorText
         If helpers.FieldIsNil(oString, "cursorcontent" )=0 Then TextContent = oString.CursorContent
         Local CursorContent = TextContent
         Local CursorText    = TextMode
         Switch CursorText
            Case #SCROLLER_TEXT_NONE
               ; === NONE ===
               TextContent = { "" }
            
            Case #SCROLLER_TEXT_FIXED
               ; === FIXED ===
               TextContent = CursorContent
               
            Case #SCROLLER_TEXT_VALUE
               ; === VALUE ===
               TextContent = { StrStr(FirstItem) }
         
         EndSwitch
         Local TextArea = { Area = { xStart = Cursor.Position.x, 
                                     yStart = Cursor.Position.y,
                                     xEnd   = Cursor.Position.x + Cursor.Size.x, 
                                     yEnd   = Cursor.Position.y + Cursor.Size.y },
                            Margins = { x = CursorHeight, y = CursorHeight },
                            Content = { Values = TextContent } }
         ; Genera la struttura del testo
         Local ifo_Text  = scui.NewText(scui.theme.SScroller_NText, TextArea)   
         Local ifo_HText = scui.NewText(scui.theme.SScroller_HText, TextArea)
         Local ifo_PText = scui.NewText(scui.theme.SScroller_PText, TextArea)
         Local ifo_DText = scui.NewText(scui.theme.SScroller_DText, TextArea)
         If helpers.FieldIsNil(oData, "text" )=0 Then ifo_Text  = scui.NewText(ifo_Text,  oData.Text, 1)
         If helpers.FieldIsNil(oData, "htext")=0 Then ifo_HText = scui.NewText(ifo_HText, oData.HText, 1)
         If helpers.FieldIsNil(oData, "ptext")=0 Then ifo_PText = scui.NewText(ifo_PText, oData.PText, 1)
         If helpers.FieldIsNil(oData, "dtext")=0 Then ifo_DText = scui.NewText(ifo_DText, oData.DText, 1)
       
         Local ifo_Visible     = #IFO_VISIBLE
         Local ifo_Enabled     = #IFO_ENABLED
         Local ifo_Status      = #IFOSTATUS_NORMAL
         Local ifo_Interactive = 1
         Local ifo_Class       = #IFOCLASS_SCROLLER
         Local ifo_Parent      = nil
         Local ifo_Type        = #IFOTYPE_BASIC
         
         If helpers.FieldIsNil(oData, "visible")=0 Then ifo_Visible = oData.Visible
         If helpers.FieldIsNil(oData, "enabled")=0 Then ifo_Enabled = oData.Enabled

         /* Verifica se si tratta di un child */
         If helpers.IsNil(IFOParent)=0
            ifo_Type   = #IFOTYPE_CHILD
            ifo_Parent = IFOParent
         EndIf

         scui.IFO[ObjId] = { Visible      = ifo_Visible,
                             Enabled      = ifo_Enabled,
                             Status       = ifo_Status,
                             oType        = ifo_Type,
                             oClass       = ifo_Class,
                             oParent      = ifo_Parent,
                             oInteractive = ifo_Interactive,
                             Owner        = Owner,
                             oName        = oName,
                             
                             Type         = oString.Type,
                             TotalItems   = TotalItems,
                             VisibleItems = VisibleItems,
                             FirstItem    = FirstItem,
                             PixPerItem   = PixelPerItem,
                             CursPos      = CursorPosition,
                             ArrowStep    = ArrowStep,
                             ClickStep    = ClickStep,
                             TextMode     = TextMode,
                             TextContent  = TextContent,
									  HandleType   = KnobType,
									  CursorArea   = CursorArea,
									  MinCursorSize= MinCursorSize,
									  ArrowMode    = ArrowMode,
									  ArrowSize    = ArrowSize,
									  FlagSquareArrows = FlagSquareArrows,
									  CursorText   = CursorText,
									  CursorContent= TextContent,
                             ValueOffset  = ValueOffset,
                             Actions      = {}
                            }
                            
         ; Creazione dei pulsanti delle frecce
         If ArrowMode > 0 ; ------------------------------------------------------------------------------------------------------------------------------------------+ Qua poi ci va messo 1
            ; Costruisce il vettore per VectorzLib

            Local AspectPlus  = { Bevel  = helpers.CloneTable(scui.theme.Scroller_NArrowBtn),
                                  HBevel = helpers.CloneTable(scui.theme.Scroller_HArrowBtn),
                                  PBevel = helpers.CloneTable(scui.theme.Scroller_PArrowBtn),
                                  DBevel = helpers.CloneTable(scui.theme.Scroller_DArrowBtn) }
            Local AspectMinus = { Bevel  = helpers.CloneTable(scui.theme.Scroller_NArrowBtn),
                                  HBevel = helpers.CloneTable(scui.theme.Scroller_HArrowBtn),
                                  PBevel = helpers.CloneTable(scui.theme.Scroller_PArrowBtn),
                                  DBevel = helpers.CloneTable(scui.theme.Scroller_DArrowBtn) }
            If oString.Type = #SCROLLERTYPE_VERTICAL
               Local VecNDown = { { Cmd = "Fill", "Solid" },
                                  { Cmd = "Col" , scui.theme.Scroller_NArrowColor },
                                  { Cmd = "Poly", scui.theme.Vectors.Arrows.Down } }
               Local VecHDown = { { Cmd = "Fill", "Solid" },
                                  { Cmd = "Col" , scui.theme.Scroller_HArrowColor },
                                  { Cmd = "Poly", scui.theme.Vectors.Arrows.Down } }
               Local VecPDown = { { Cmd = "Fill", "Solid" },
                                  { Cmd = "Col" , scui.theme.Scroller_PArrowColor },
                                  { Cmd = "Poly", scui.theme.Vectors.Arrows.Down } }
               Local VecDDown = { { Cmd = "Fill", "Solid" },
                                  { Cmd = "Col" , scui.theme.Scroller_DArrowColor },
                                  { Cmd = "Poly", scui.theme.Vectors.Arrows.Down } }
               Local VecNUp = { { Cmd = "Fill", "Solid" },
                                { Cmd = "Col" , scui.theme.Scroller_NArrowColor },
                                { Cmd = "Poly", scui.theme.Vectors.Arrows.Up } }
               Local VecHUp = { { Cmd = "Fill", "Solid" },
                                { Cmd = "Col" , scui.theme.Scroller_HArrowColor },
                                { Cmd = "Poly", scui.theme.Vectors.Arrows.Up } }
               Local VecPUp = { { Cmd = "Fill", "Solid" },
                                { Cmd = "Col" , scui.theme.Scroller_PArrowColor },
                                { Cmd = "Poly", scui.theme.Vectors.Arrows.Up } }
               Local VecDUp = { { Cmd = "Fill", "Solid" },
                                { Cmd = "Col" , scui.theme.Scroller_DArrowColor },
                                { Cmd = "Poly", scui.theme.Vectors.Arrows.Up } }

               AspectMinus.Bevel.Vector  = VecNUp
               AspectMinus.HBevel.Vector = VecHUp
               AspectMinus.PBevel.Vector = VecPUp
               AspectMinus.DBevel.Vector = VecDUp
               AspectPlus.Bevel.Vector  = VecNDown
               AspectPlus.HBevel.Vector = VecHDown
               AspectPlus.PBevel.Vector = VecPDown
               AspectPlus.DBevel.Vector = VecDDown
            Else
               Local VecNRight = { { Cmd = "Fill", "Solid" },
                                   { Cmd = "Col" , scui.theme.Scroller_NArrowColor },
                                   { Cmd = "Poly", scui.theme.Vectors.Arrows.Right } }
               Local VecHRight = { { Cmd = "Fill", "Solid" },
                                   { Cmd = "Col" , scui.theme.Scroller_HArrowColor },
                                   { Cmd = "Poly", scui.theme.Vectors.Arrows.Right } }
               Local VecPRight = { { Cmd = "Fill", "Solid" },
                                   { Cmd = "Col" , scui.theme.Scroller_PArrowColor },
                                   { Cmd = "Poly", scui.theme.Vectors.Arrows.Right } }
               Local VecDRight = { { Cmd = "Fill", "Solid" },
                                   { Cmd = "Col" , scui.theme.Scroller_DArrowColor },
                                   { Cmd = "Poly", scui.theme.Vectors.Arrows.Right } }
               Local VecNLeft = { { Cmd = "Fill", "Solid" },
                                  { Cmd = "Col" , scui.theme.Scroller_NArrowColor },
                                  { Cmd = "Poly", scui.theme.Vectors.Arrows.Left } }
               Local VecHLeft = { { Cmd = "Fill", "Solid" },
                                  { Cmd = "Col" , scui.theme.Scroller_HArrowColor },
                                  { Cmd = "Poly", scui.theme.Vectors.Arrows.Left } }
               Local VecPLeft = { { Cmd = "Fill", "Solid" },
                                  { Cmd = "Col" , scui.theme.Scroller_PArrowColor },
                                  { Cmd = "Poly", scui.theme.Vectors.Arrows.Left } }
               Local VecDLeft = { { Cmd = "Fill", "Solid" },
                                  { Cmd = "Col" , scui.theme.Scroller_DArrowColor },
                                  { Cmd = "Poly", scui.theme.Vectors.Arrows.Left } }

               AspectMinus.Bevel.Vector  = VecNLeft
               AspectMinus.HBevel.Vector = VecHLeft
               AspectMinus.PBevel.Vector = VecPLeft
               AspectMinus.DBevel.Vector = VecDLeft
               AspectPlus.Bevel.Vector  = VecNRight
               AspectPlus.HBevel.Vector = VecHRight
               AspectPlus.PBevel.Vector = VecPRight
               AspectPlus.DBevel.Vector = VecDRight
            EndIf
            
            btn_ArrowMinus = scui.NewObject( #IFOCLASS_BUTTON , oName .. ".Minus", ArrowMinusArea.Position, ArrowMinusArea.Size, AspectMinus, { Values = { "" } }, nil, ObjID, nil, 1, Owner )
            btn_ArrowPlus  = scui.NewObject( #IFOCLASS_BUTTON , oName .. ".Plus" , ArrowPlusArea.Position,  ArrowPlusArea.Size,  AspectPlus, { Values = { "" } }, nil, ObjID, nil, 1, Owner )
         EndIf

         scui.IFO[ObjID].oData = { Container  = ifo_tContainer,
                                   hContainer = ifo_hContainer,
                                   dContainer = ifo_dContainer,
                                   Cursor     = ifo_CursorBlock,
                                   hCursor    = ifo_HCursorBlock,
                                   pCursor    = ifo_PCursorBlock,
                                   dCursor    = ifo_DCursorBlock,
                                   Text       = ifo_Text,
                                   hText      = ifo_hText,
                                   pText      = ifo_pText,
                                   dText      = ifo_dText }
         If helpers.IsNil(btn_ArrowMinus) = 0
				scui.IFO[ObjID].ChildCount = 2
				scui.IFO[ObjID].Childs = { nil, btn_ArrowMinus, btn_Arrowplus }
		   Else
				scui.IFO[ObjID].ChildCount = 0
		   EndIf

         /* Sistema un eventuale Gradiente a secondo del tipo di Scroller */
         If (oString.Type = #SCROLLERTYPE_VERTICAL) And (helpers.IsNil(ForceID) = 1)
            scui.IFO[ObjID].oData.Cursor.GradientAngle  = scui.IFO[ObjID].oData.Cursor.GradientAngle  + 90
            scui.IFO[ObjID].oData.HCursor.GradientAngle = scui.IFO[ObjID].oData.HCursor.GradientAngle + 90
            scui.IFO[ObjID].oData.PCursor.GradientAngle = scui.IFO[ObjID].oData.PCursor.GradientAngle + 90
            scui.IFO[ObjID].oData.DCursor.GradientAngle = scui.IFO[ObjID].oData.DCursor.GradientAngle + 90
            scui.IFO[ObjID].oData.Container.GradientAngle  = scui.IFO[ObjID].oData.Container.GradientAngle  + 90
            scui.IFO[ObjID].oData.HContainer.GradientAngle = scui.IFO[ObjID].oData.HContainer.GradientAngle + 90
            scui.IFO[ObjID].oData.DContainer.GradientAngle = scui.IFO[ObjID].oData.DContainer.GradientAngle + 90
         EndIf

         /* Setta le azioni */
         If helpers.FieldIsNil(oActions, "onchange") = 0 Then scui.IFO[ObjID].Actions.OnChange = oActions.OnChange
         If helpers.FieldIsNil(oActions, "ondrag"  ) = 0 Then scui.IFO[ObjID].Actions.OnDrag   = oActions.OnDrag
         
         If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(ObjID)

         /* Setta la gestione degli eventi */
         MakeButton(ObjID, #SIMPLEBUTTON, CursorArea.Position.x, CursorArea.Position.y, CursorArea.Size.x, CursorArea.Size.y, 
                    { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )
			/* Disattiva la zona se non visibile o disabilitato */
			If(ifo_Enabled = #IFO_DISABLED Or ifo_Visible = #IFO_HIDDEN) Then DisableButton(ObjID)
			Return(ObjID)
    
      Case #IFOCLASS_OPTIONS
			;+------------------------------------------------------[ OPTIONS ]--+
         ;| Interactive: YES                                                  |
         ;| Supported Fields in Aspect table (oData)                          |
         ;|  - Container      BevelStruct: option's container layout          |
         ;|  - NSwitch        BevelStruct: option's normal layout             |
         ;|  - HSwitch        BevelStruct: option's hilighted layout          |
         ;|  - PSwitch        BevelStruct: option's pushed layout             |
         ;|  - DSwitch        BevelStruct: option's disabled layout           |
         ;|  - SwiNText       TextStruct: option's normal text                |
         ;|  - SwiHText       TextStruct: option's hilighted text             |
         ;|  - SwiPText       TextStruct: option's pushed text                |
         ;|  - SwiDText       TextStruct: option's disabled text              |
         ;|  - NLabel         BevelStruct: option's label                     |
         ;|  - LabelText      TextStruct: label's text                        |
         ;|  - Visible        #IFO_VISIBLE or #IFO_HIDDEN                     |
         ;|  - Enabled        #IFO_ENABLED or #IFO_DISABLED                   |
         ;| Supported Fields in Params table (oString)                        |
         ;|  - DefaultOptions A table with the activated options (pushed)     |
         ;|  - SwitchWidth    The width of every switch in pixels (used if    |
         ;|                   SwitchMode <> #OPTSWITCH_FULLWIDTH)             |
         ;|  - SwitchPosition Set the switch position relative to its label,  |
         ;|                   can be:                                         |
         ;|                      #OPT_RIGHTSWITCH  Set the switch to the right|
         ;|                      #OPT_LEFTSWITCH   Set the switch to the left |
         ;|                   (used if SwitchMode <> #OPTSWITCH_FULLWIDTH)    |
         ;|  - SwitchMode     The Options box can have three layout as        |
         ;|                   following:                                      |
         ;|                      #OPTSWITCH_EMPTY     nothing will be rendered|
         ;|                                           inside the switch       |
         ;|                      #OPTSWITCH_NUMBER    the option number will  |
         ;|                                           be rendered inside the  |
         ;|                                           switch                  |
         ;|                      #OPTSWITCH_FULLWIDTH the label will not be   |
         ;|                                           rendered, but only the  |
         ;|                                           switch at full width    |
         ;|                                           with the text of the    |
         ;|                                           label within            |
         ;|  - Mode           Set the operating mode as following:            |
         ;|                      #OPTMODE_ONLYONE only one option is allowed, |
         ;|                                            clicking another option|
         ;|                                            the previously selected|
         ;|                                            will be raised up      |
         ;|                      #OPTMODE_FREE         user can select one or |
         ;|                                            more options without   |
         ;|                                            limits, clicking an    |
         ;|                                            already selected option|
         ;|                                            will deselect it       |
         ;|  - Rows           Number of rows of the option's grid             |
         ;|  - Columns        Number of columns of the option's grid          |
         ;|  - Options        This is a table containing all available options|
         ;| Supported Fields in Actions table (oActions)                      |
         ;|  - OnChanged      Function to call everytime one option change its|
         ;|                   state                                           |
         ;+-------------------------------------------------------------------+
         Local CycleName = ""
         
         If helpers.IsNil(ForceID) = 0
            /* GADGET REGENERATION: Reload current data */
            Local Obj = scui.IFO[ForceID]
            If Not(helpers.FieldIsNil(Obj, "cyclename"))
               CycleName = Obj.CycleName
            EndIf
            
            Local ObjData = scui.IFO[ForceID].oData
            Owner     = Obj.Owner
            oName     = Obj.oName
            oPosition = { x = ObjData.Container.Position.x, y = ObjData.Container.Position.y }
            oSize     = { x = ObjData.Container.Size.x,     y = ObjData.Container.Size.y }
            Local Opt = scui.Get(oName)
            Local i
            Local DefOpt = {}
            Local OptC = 0
            Local tCnt = helpers.CountEntries(Opt.Value) -1
            For i = 0 To tCnt
               If Opt.Value[i] = 1
                  DefOpt[OptC] = i + 1
                  OptC = OptC + 1
               EndIf
            Next
            oData   = { Container  = scui.NewBevel(ObjData.Container, nil, 1),
                        NSwitch    = scui.NewBevel(ObjData.NSwitch, nil, 1),
                        HSwitch    = scui.NewBevel(ObjData.HSwitch, nil, 1),
                        PSwitch    = scui.NewBevel(ObjData.PSwitch, nil, 1),
                        DSwitch    = scui.NewBevel(ObjData.DSwitch, nil, 1),
                        SwiNText   = scui.NewText(ObjData.SwiNText, nil, 1),
                        SwiHText   = scui.NewText(ObjData.SwiHText, nil, 1),
                        SwiPText   = scui.NewText(ObjData.SwiPText, nil, 1),
                        SwiDText   = scui.NewText(ObjData.SwiDText, nil, 1),
                        NLabel     = scui.NewBevel(ObjData.NLabel, nil, 1),
                        LabText    = scui.NewText(ObjData.LabelText, nil, 1),
                        Visible    = Obj.Visible,
                        Enabled    = Obj.Enabled }
                          
            oString  = { DefaultOptions   = DefOpt,
                         SwitchWidth      = Obj.InitialWidth,
                         SwitchPosition   = Obj.SwitchPosition,
                         SwitchMode       = Obj.SwitchMode,
                         Rows             = Obj.Rows,
                         Columns          = Obj.Columns,
                         Options          = Obj.Options,
                         Mode             = Obj.Mode }
            oActions = { }
            If helpers.FieldIsNil(Obj.Actions, "onchanged" ) = 0 Then oActions.OnChanged = Obj.Actions.OnChanged
            
            /* Elimino il vecchio gadget e i relativi Childs                 */
            scui.RemoveObject(id)
            scui.QuickFind[oName] = id
         EndIf
        /* Impostazioni di default */
         If helpers.IsNil(oData   )=1 Then oData    = {}
         If helpers.IsNil(oActions)=1 Then oActions = {}
         If helpers.IsNil(oString )=1 Then oString  = {}

         Local opt_DefaultOptions = { 1 }
         Local opt_SwitchWidth    = scui.theme.Options_SwitchWidth
         Local opt_SwitchPosition = #OPT_LEFTSWITCH
         Local opt_SwitchMode     = #OPTSWITCH_EMPTY
         Local opt_Mode           = #OPTMODE_ONLYONE
         Local opt_Rows           = scui.prefs.Options_Rows
         Local opt_Columns        = scui.prefs.Options_Columns
         Local opt_Options        = scui.prefs.Options_DefaultOptions
         Local opt_Visible        = #IFO_VISIBLE
         Local opt_Enabled        = #IFO_ENABLED
         If helpers.FieldIsNil(oString, "defaultoptions")=0 Then opt_Defaultoptions = oString.DefaultOptions
         If helpers.FieldIsNil(oString, "switchwidth"   )=0 Then opt_SwitchWidth    = oString.SwitchWidth
         If helpers.FieldIsNil(oString, "switchposition")=0 Then opt_SwitchPosition = oString.SwitchPosition
         If helpers.FieldIsNil(oString, "switchmode"    )=0 Then opt_SwitchMode     = oString.SwitchMode
         If helpers.FieldIsNil(oString, "mode"          )=0 Then opt_Mode           = oString.Mode
         If helpers.FieldIsNil(oString, "rows"          )=0 Then opt_Rows           = oString.Rows
         If helpers.FieldIsNil(oString, "columns"       )=0 Then opt_Columns        = oString.Columns
         If helpers.FieldIsNil(oString, "options"       )=0 Then opt_Options        = oString.Options        
         If helpers.FieldIsNil(oData, "visible" )=0 Then opt_Visible = oData.Visible
         If helpers.FieldIsNil(oData, "enabled" )=0 Then opt_Enabled = oData.Enabled                
         Local opt_Position = oPosition
         Local opt_Size     = oSize
         Local opt_InitialWidth = opt_SwitchWidth
         Local ObjID = id
         /* Creazione Container */
         Local opt_Container = scui.NewBevel(scui.theme.Options_Container, 
                                             { Position = { x = opt_Position.x, y = opt_Position.y },
                                               Size     = { x = opt_Size.x,     y = opt_Size.y } } )
         If helpers.FieldIsNil(oData, "container")=0 Then opt_Container = scui.NewBevel(opt_Container, oData.Container, 1 )

         /* Calcolo l'area utile per le opzioni */
			Local mul = IIF(opt_Container.Type = #BEVELTYPE_SUNKEN , 2, IIF(opt_Container.Type <> #BEVELTYPE_NONE , 1, 0))
         Local opt_ContainerBorder = opt_Container.Height * mul + scui.theme.Options_BorderGap
         Local opt_StartX = opt_Position.x + opt_ContainerBorder
         Local opt_StartY = opt_Position.Y + opt_ContainerBorder
         Local opt_SizeX  = opt_Size.x - opt_ContainerBorder * 2
         Local opt_SizeY  = opt_Size.y - opt_ContainerBorder * 2
            
         /* Calcolo l'area utile per ogni opzione */
         Local opt_XGapSize = (opt_Columns - 1) * scui.theme.Options_OptionsGapH
         Local opt_OptionSizeX = (opt_SizeX - opt_XGapSize) / opt_Columns
         Local opt_YGapSize = (opt_Rows - 1)* scui.theme.Options_OptionsGapV
         Local opt_OptionSizeY = (opt_SizeY - opt_YGapSize) / opt_Rows
         Local opt_YGap = scui.theme.Options_OptionsGapV
         Local opt_XGap = scui.theme.Options_OptionsGapH
         /* Creo i bevel per gli Switch */
         Local opt_Switch  = scui.NewBevel(scui.theme.Options_NBox, nil)
         Local opt_HSwitch = scui.NewBevel(scui.theme.Options_HBox, nil)
         Local opt_PSwitch = scui.NewBevel(scui.theme.Options_PBox, nil)
         Local opt_DSwitch = scui.NewBevel(scui.theme.Options_DBox, nil)
         If helpers.FieldIsNil(oData, "nswitch")=0 Then opt_Switch  = scui.NewBevel(opt_Switch,  oData.NSwitch, 1)
         If helpers.FieldIsNil(oData, "hswitch")=0 Then opt_HSwitch = scui.NewBevel(opt_HSwitch, oData.HSwitch, 1)
         If helpers.FieldIsNil(oData, "pswitch")=0 Then opt_PSwitch = scui.NewBevel(opt_PSwitch, oData.PSwitch, 1)
         If helpers.FieldIsNil(oData, "dswitch")=0 Then opt_DSwitch = scui.NewBevel(opt_DSwitch, oData.DSwitch, 1)

         /* Creo il bevel per la label */
         Local opt_Label = scui.NewBevel(scui.theme.Options_LabelBox, nil)
         If helpers.FieldIsNil(oData, "nlabel")=0 Then opt_Label = scui.NewBevel(opt_Label, oData.NLabel, 1)
        
         /* Creo il testo per la label */
         Local opt_LabText = scui.NewText(scui.theme.Options_LabelText, {})
         If helpers.FieldIsNil(oData, "labtext")=0 Then opt_LabText = scui.NewText(opt_LabText, oData.LabText, 1)
         /* Elimino i campi per le coordinate */
         opt_LabText.Area    = nil
         opt_LabText.Content = nil
        
         /* Imposta alcune variabili per il ciclo di generazione */
         Local StartX = opt_StartX
         Local StartY = opt_StartY
         Local SizeX  = opt_OptionSizeX - opt_SwitchWidth
         Local SizeY  = opt_OptionSizeY        
         Local opt_SwitchX = 0
         If opt_SwitchPosition = #OPT_LEFTSWITCH
            /* LEFT */
            opt_SwitchX = StartX
            StartX = StartX + opt_SwitchWidth +  scui.theme.Options_SwitchLabelGap
         Else
            /* RIGHT */
            opt_SwitchX = StartX + SizeX + scui.theme.Options_SwitchLabelGap
         EndIf

         Local oStartX = opt_SwitchX
         Local oStartY = opt_StartY
         scui.IFO[ObjID] = {}
         scui.IFO[ObjID].Childs = {}
         Local ChildId = 1

         Local CurrentRow = 1
         Local CurrentColumn = 1

         /* Testo all'interno degli switch */
         opt_SwiText  = scui.NewText(scui.theme.Options_NText, {})
         opt_SwiHText = scui.NewText(scui.theme.Options_HText, {})
         opt_SwiPText = scui.NewText(scui.theme.Options_PText, {})
         opt_SwiDText = scui.NewText(scui.theme.Options_DText, {})
         If helpers.FieldIsNil(oData, "swintext")=0 Then opt_SwiText  = scui.NewText(opt_SwiText,  oData.SwiNText, 1)
         If helpers.FieldIsNil(oData, "swihtext")=0 Then opt_SwiHText = scui.NewText(opt_SwiHText, oData.SwiHText, 1)
         If helpers.FieldIsNil(oData, "swiptext")=0 Then opt_SwiPText = scui.NewText(opt_SwiPText, oData.SwiPText, 1)
         If helpers.FieldIsNil(oData, "swidtext")=0 Then opt_SwiDText = scui.NewText(opt_SwiDText, oData.SwiDText, 1)

         /* Elimino le coordinate e il testo di default */
         opt_SwiText.Area      = nil
         opt_SwiText.Content   = nil
         opt_SwiHText.Area     = nil
         opt_SwiHText.Content  = nil
         opt_SwiPText.Area     = nil
         opt_SwiPText.Content  = nil
         opt_SwiDText.Area     = nil
         opt_SwiDText.Content  = nil
                
         /* Conta le Opzioni */
         Local OptCount = 0
         OptCount = helpers.CountEntries(opt_Options)
         Local o = 0
         scui.IFO[ObjID].Childs = { }
         If opt_SwitchMode = #OPTSWITCH_FULLWIDTH Then oStartX = opt_StartX

         Local optcnt1 = OptCount - 1
         For Local o = 0 to optcnt1
            dummy = o
            Local opt_Pos  = { x = opt_StartX, y = opt_StartY }
            Local opt_Size = { x = opt_SizeX,  y = opt_SizeY  }
          
            /* Crea il Bevel di Default e toglie la posizione e le dimensioni */
            defBev = scui.NewBevel(scui.theme.Options_NBox, nil)
            defBev.Position = nil
            defBev.Size     = nil
            
            /* Calcola la dimensione dello Switch in base all' OPTSWITCH_ */
            Local num = ""
            If opt_SwitchMode = #OPTSWITCH_NUMBER
               num = StrStr(o+1)
            ElseIf opt_SwitchMode = #OPTSWITCH_FULLWIDTH
               num = opt_Options[o]
               opt_SwitchWidth = opt_OptionSizeX
            Else
               num = ""             
            EndIf
          
            /* Crea lo Swicth */
            Local SwitchAction = 0
            If helpers.FieldIsNil(oActions, "onchanged" )=1
               SwitchAction = nil
            Else
               SwitchAction = oActions.OnChanged
            EndIf
            swi = scui.NewObject( #IFOCLASS_SWITCH ,
                                  oName .. ".Swi." .. StrStr(o),
                                  { x = oStartX, y = oStartY }, { x = opt_SwitchWidth, y = SizeY },
                                  { Bevel = opt_Switch, HBevel = opt_HSwitch, PBevel = opt_PSwitch, DBevel = opt_DSwitch,
                                    Text  = opt_SwiText, HText = opt_SwiHText, PText = opt_SwiPText, DText = opt_SwiDText, 
                                    Enabled = opt_Enabled, Visible = opt_Visible },
                                  { Values = { num }, Lines = 1 },
                                  { OnChanged = SwitchAction },
                                  ObjID, nil, 1, Owner )

            ; <X> all'interno del pulsante premuto se non uso il numero o il fullwidth
;======================= PARAMETRIZZARE NELLE PREFERENZE DEL TEMA =============================
            ;If num = "" Then scui.Set(swi, { PText = { Content = { Values = { "X" } } } })
            
            /* Memorizza lo Switch creato fra i Child di questo oggetto */
            scui.IFO[ObjID].Childs[ChildId] = swi
            /* Verifica se lo switch deve essere attivato di default o meno */
            Local a, b = NextItem(opt_DefaultOptions)
            While GetType(a) <> #NIL
               If b = o + 1
                  scui.IFO[swi].Value = 1
                  Break
               EndIf
               a, b = NextItem(opt_DefaultOptions, a)
            Wend
            ChildId = ChildId + 1
          
            /* Creo la Label associata */
            If opt_SwitchMode <> #OPTSWITCH_FULLWIDTH
               Local txt = opt_Options[o]
               Local lab = scui.NewObject( #IFOCLASS_LABEL , oName .. ".Lab." .. o,
                                           { x = StartX, y = StartY }, { x = SizeX - scui.theme.Options_SwitchLabelGap,  y = SizeY }, 
                                           { Bevel = opt_Label, Text = opt_LabText },
                                           { Values = { txt } , Lines = 1 },
                                           nil, ObjID, nil, 1, Owner )

               /* Memorizza questa label fra l'eneco dei Child */
               scui.IFO[ObjID].Childs[ChildId] = lab
               ChildId = ChildId + 1
            EndIf
          
            /* Effettua dei calcoli in base all'orientamento */
            StartY  = StartY  + opt_YGap + opt_OptionSizeY
            oStartY = oStartY + opt_YGap + opt_OptionSizeY
            CurrentRow = CurrentRow + 1
            If CurrentRow > opt_Rows
               /* Reset riga, prossima colonna */
               StartY  = opt_StartY
               oStartY = opt_StartY
               StartX  = StartX  + opt_XGap + opt_OptionSizeX
               oStartX = oStartX + opt_XGap + opt_OptionSizeX
               CurrentRow = 1
               CurrentColumn = CurrentColumn + 1
            EndIf
        Next

        Local opt_Interactive = 0
        Local opt_Class       = #IFOCLASS_OPTIONS
        Local opt_Parent      = nil
        Local opt_Type        = #IFOTYPE_BASIC

        /* Verifica se si tratta di un child */
        If helpers.IsNil(IFOParent)=0
            opt_Type   = #IFOTYPE_CHILD
            opt_Parent = IFOParent
        EndIf
        Local ChildsList = scui.IFO[ObjID].Childs
        scui.IFO[ObjID] = { Visible      = opt_Visible,
                            Enabled      = opt_Enabled,
                            Status       = opt_Status,
                            oType        = opt_Type,
                            oClass       = opt_Class,
                            oParent      = opt_Parent,
                            oInteractive = opt_Interactive,
                            Owner        = Owner,
                            oName        = oName,
                            Actions      = { },
                            Childs       = ChildsList,
                            ChildCount   = ChildID - 1,
                            Mode         = opt_Mode,
                            DefaultOptions = opt_DefaultOptions,
                            SwitchWidth  = opt_SwitchWidth,
                            InitialWidth = opt_InitialWidth,
                            SwitchPosition = opt_SwitchPosition,
                            SwitchMode     = opt_SwitchMode,
                            Rows           = opt_Rows,
                            Columns        = opt_Columns,
                            Options        = opt_Options,
                            oData        = { Container = opt_Container,
                                             NSwitch = opt_Switch,
                                             HSwitch = opt_HSwitch,
                                             PSwitch = opt_PSwitch,
                                             DSwitch = opt_DSwitch,
                                             NLabel  = opt_Label,
                                             LabelText = opt_LabText, 
                                             SwiNText  = opt_SwiText,
                                             SwiHText  = opt_SwiHText,
                                             SwiPText  = opt_SwiPText,
                                             SwiDText  = opt_SwiDText
                                             }
                            }

        If CycleName <> "" Then scui.IFO[ObjID].CycleName = CycleName
        
        If helpers.FieldIsNil(oActions, "onchanged" )=0 Then scui.IFO[ObjID].Actions.OnChanged = oActions.OnChanged
        If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(ObjID)       
		Return(objID)

    Case #IFOCLASS_CYCLE
			;+--------------------------------------------------------[ CYCLE ]--+
         ;| Interactive: YES                                                  |
         ;| Supported Fields in Aspect table (oData)                          |
         ;|  - Cycle          BevelStruct: button's normal layout             |
         ;|  - HCycle         BevelStruct: button's hilighted layout          |
         ;|  - PCycle         BevelStruct: button's pushed layout             |
         ;|  - DCycle         BevelStruct: button's disabled layout           |
         ;|  - Text           TextStruct: button's normal layout              |
         ;|  - HText          TextStruct: button's hilighted layout           |
         ;|  - PText          TextStruct: button's pushed layout              |
         ;|  - DText          TextStruct: button's disabled layout            |
         ;|  - Container      BevelStruct for DropDown container              |
         ;|  - NOptionBox     BevelStruct: DropDown Option's normal layout    |
         ;|  - HOptionBox     BevelStruct: DropDown Option's hilighted layout |
         ;|  - POptionBox     BevelStruct: DropDown Option's pushed layout    |
         ;|  - NOptionText    TextStruct: DropDown Option's normal layout     |
         ;|  - HOptionText    TextStruct: DropDown Option's hilighted layout  |
         ;|  - POptionText    TextStruct: DropDown Option's pushed layout     |
         ;|  - NScrollerBox   BevelStruct: DropDown Scroller nomral Container |
         ;|  - HScrollerBox   BevelStruct: DropDown Scroller hilig. Container |
         ;|  - DScrollerBox   BevelStruct: DropDown Scroller disab. Container |
         ;|  - NScrollerCursor  BevelStruct: DropDown Scroller norm Cursor    |
         ;|  - HScrollerCursor  BevelStruct: DropDown Scroller hil. Cursor    |
         ;|  - PScrollerCursor  BevelStruct: DropDown Scroller pus. Cursor    |
         ;|  - DScrollerCursor  BevelStruct: DropDown Scroller dis. Cursor    |
         ;|  - NScrollerText  TextStruct: DropDown Cursor Text (normal)       |
         ;|  - HScrollerText  TextStruct: DropDown Cursor Text (hilighted)    |
         ;|  - PScrollerText  TextStruct: DropDown Cursor Text (pushed)       |
         ;|  - DScrollerText  TextStruct: DropDown Cursor Text (disabled)     |
         ;|  - Visible        #IFO_VISIBLE or #IFO_HIDDEN                     |
         ;|  - Enabled        #IFO_ENABLED or #IFO_DISABLED                   |
         ;| Supported Fields in Params table (oString)                        |
         ;|  - DropShadow     This flag can be set to 1 or 0, 1 means that the|
			;|                   option's container will drop a shadow           |
         ;|  - ShadowOffsetX  Horizontal shadow offset relative from the      |
			;|                   option's container                              |
         ;|  - ShadowOffsetY  Vertical shadow offset relative from the        |
			;|                   option's container                              |
         ;|  - GrowDirection  Sets in which direction the options should be   |
			;|                   expanded, can be:                               |
         ;|                     #CYCLE_GROWUP                                 |
         ;|                     #CYCLE_GROWDOWN                               |
         ;|  - VisibleOptions Sets how many options will be showed in the drop|
			;|                   down list                                       |
         ;|  - OptionHeight   Sets the height in pixels of every single option|
			;|                   in the drop down list                           |
         ;| Supported Fields in Actions table (oActions)                      |
         ;|  - OnReleased     Function to call when the drop down list is     | << OBSOLETE
			;|                   closed, even if the active option is not changed|
         ;|  - OnChanged      Function to call when the active option changes |
         ;+-------------------------------------------------------------------+
        
         If helpers.IsNil(oData   )=1 Then oData    = {}
         If helpers.IsNil(oActions)=1 Then oActions = {}
         If helpers.IsNil(oString )=1 Then oString  = {}

         /* Check the available options */
         Local cyc_Options = { "empty" }
         If helpers.FieldIsNil(oString, "options") = 0 Then cyc_Options = oString.Options
        
         /* Check default option */
         Local cyc_DefaultOption = 0
         If helpers.FieldIsNil(oString, "defaultoption") = 0 Then cyc_DefaultOption = oString.DefaultOption - 1
         Local cyc_OptionString = cyc_Options[cyc_DefaultOption]       
			
         /* Genera i bevel per il cycle */
         Local cyc_Cycle  = scui.NewBevel(scui.theme.Cycle_NBox, nil )
         Local cyc_HCycle = scui.NewBevel(scui.theme.Cycle_HBox, nil )
         Local cyc_PCycle = scui.NewBevel(scui.theme.Cycle_PBox, nil )
         Local cyc_DCycle = scui.NewBevel(scui.theme.Cycle_DBox, nil )

         If helpers.FieldIsNil(oData, "cycle" )=0 Then cyc_Cycle  = scui.NewBevel(cyc_Cycle,  oData.Cycle, 1)
         If helpers.FieldIsNil(oData, "hcycle")=0 Then cyc_HCycle = scui.NewBevel(cyc_HCycle, oData.HCycle, 1)
         If helpers.FieldIsNil(oData, "pcycle")=0 Then cyc_PCycle = scui.NewBevel(cyc_PCycle, oData.PCycle, 1)
         If helpers.FieldIsNil(oData, "dcycle")=0 Then cyc_DCycle = scui.NewBevel(cyc_DCycle, oData.DCycle, 1)

         cyc_Cycle.Position  = nil
         cyc_HCycle.Position = nil
         cyc_PCycle.Position = nil
         cyc_DCycle.Position = nil
         cyc_Cycle.Size  = nil
         cyc_HCycle.Size = nil
         cyc_PCycle.Size = nil
         cyc_DCycle.Size = nil
        
         /* Genera i Text per il cycle */
         Local cyc_Text  = scui.NewText(scui.theme.Cycle_NText, nil )
         Local cyc_HText = scui.NewText(scui.theme.Cycle_HText, nil )
         Local cyc_PText = scui.NewText(scui.theme.Cycle_PText, nil )
         Local cyc_DText = scui.NewText(scui.theme.Cycle_DText, nil )

         If helpers.FieldIsNil(oData, "text" )=0 Then cyc_Text   = scui.NewText(cyc_Text,  oData.Text, 1)
         If helpers.FieldIsNil(oData, "htext")=0 Then cyc_HText  = scui.NewText(cyc_HText, oData.HText, 1)
         If helpers.FieldIsNil(oData, "ptext")=0 Then cyc_PText  = scui.NewText(cyc_PText, oData.PText, 1)
         If helpers.FieldIsNil(oData, "dtext")=0 Then cyc_DText  = scui.NewText(cyc_DText, oData.DText, 1)

         cyc_Text.Area  = nil
         cyc_HText.Area = nil
         cyc_PText.Area = nil
         cyc_DText.Area = nil
         cyc_Text.Content  = nil
         cyc_HText.Content = nil
         cyc_PText.Content = nil
         cyc_DText.Content = nil
         
         Local cyc_Visible     = #IFO_VISIBLE
         Local cyc_Enabled     = #IFO_ENABLED

         If helpers.FieldIsNil(oData, "visible")=0 Then cyc_Visible = oData.Visible
         If helpers.FieldIsNil(oData, "enabled")=0 Then cyc_Enabled = oData.Enabled

         /* Verifica se dev'essere disegnata l'ombra del menu' */
         Local cyc_DropShadow = scui.theme.Cycle_DropShadow
         Local cyc_DropShadowX = scui.theme.Cycle_ShadowOffsetX
         Local cyc_DropShadowY = scui.theme.Cycle_ShadowOffsetY
         If helpers.FieldIsNil(oString, "dropshadow")=0 Then cyc_DropShadow  = oString.DropShadow
         If helpers.FieldIsNil(oString, "shadowoffsetx")=0 Then cyc_DropShadowX  = oString.ShadowOffsetX
         If helpers.FieldIsNil(oString, "shadowoffsety")=0 Then cyc_DropShadowX  = oString.ShadowOffsetY
         Local ObjID = id
DebugPrint("CREATING CYCLE:", ObjID, oName)
			/* Crea il pulsante per il Cycle */
         ; *** ATTENZIONE: Qua potrei impostare un'azione per gestire un'evento ***
			; ***             da eseguire prima di tracciare il DropDown (cmq da   ***
			; ***             verificare e attivare nell'handler)                  ***
         Local cycle = scui.NewObject( #IFOCLASS_BUTTON, oName .. ".Button",
                                       oPosition,
                                       oSize,
                                       { Text  = cyc_Text,
                                         HText = cyc_HText,
                                         PText = cyc_PText,
                                         DText = cyc_DText,
                                         Bevel  = cyc_Cycle,
                                         HBevel = cyc_HCycle,
                                         PBevel = cyc_PCycle,
                                         DBevel = cyc_DCycle,
                                         Enabled = cyc_Enabled },
                                       { Values = { cyc_OptionString }, Lines = 1 },
                                       nil,
                                       ObjID,
                                       nil,
                                       1,
                                       Owner)
         /* Numero opzioni */
         Local cyc_OptionsCount = 0
         cyc_OptionsCount = helpers.CountEntries(cyc_Options)
        
         Local cyc_Status      = #IFOSTATUS_NORMAL
         Local cyc_Interactive = 0
         Local cyc_Class       = #IFOCLASS_CYCLE
         Local cyc_Parent      = nil
         Local cyc_Type        = #IFOTYPE_BASIC
         Local cyc_ChildCount  = 1
        
         Local cyc_GrowDirection  = scui.theme.Cycle_GrowDirection
         Local cyc_VisibleOptions = scui.theme.Cycle_VisibleOptions
         Local cyc_OptionHeight   = scui.theme.Cycle_OptionHeight
         Local cyc_NOptionBox  = scui.NewBevel(scui.theme.Cycle_NOptionBox, nil)
         Local cyc_HOptionBox  = scui.NewBevel(scui.theme.Cycle_HOptionBox, nil)
         Local cyc_POptionBox  = scui.NewBevel(scui.theme.Cycle_POptionBox, nil)
         Local cyc_NOptionText = scui.NewText(scui.theme.Cycle_NOptionText, nil)
         Local cyc_HOptionText = scui.NewText(scui.theme.Cycle_HOptionText, nil)
         Local cyc_POptionText = scui.NewText(scui.theme.Cycle_POptionText, nil)
         Local cyc_NScrollerBox = scui.NewBevel(scui.theme.Cycle_NScrollerBox, nil)
         Local cyc_HScrollerBox = scui.NewBevel(scui.theme.Cycle_HScrollerBox, nil)
         Local cyc_DScrollerBox = scui.NewBevel(scui.theme.Cycle_DScrollerBox, nil)
         Local cyc_NScrollerCursor = scui.NewBevel(scui.theme.Cycle_NCursorBox, nil)
         Local cyc_HScrollerCursor = scui.NewBevel(scui.theme.Cycle_HCursorBox, nil)
         Local cyc_PScrollerCursor = scui.NewBevel(scui.theme.Cycle_PCursorBox, nil)
         Local cyc_DScrollerCursor = scui.NewBevel(scui.theme.Cycle_DCursorBox, nil)
         Local cyc_NScrollerText = scui.NewText(scui.theme.Cycle_NCursorText, nil)
         Local cyc_HScrollerText = scui.NewText(scui.theme.Cycle_HCursorText, nil)
         Local cyc_PScrollerText = scui.NewText(scui.theme.Cycle_PCursorText, nil)
         Local cyc_DScrollerText = scui.NewText(scui.theme.Cycle_DCursorText, nil)
         Local cyc_Container = scui.NewBevel(scui.theme.Cycle_Container, nil)
         cyc_NOptionBox.Position = nil
         cyc_NOptionBox.Size     = nil
         cyc_HOptionBox.Position = nil
         cyc_HOptionBox.Size     = nil
         cyc_POptionBox.Position = nil
         cyc_POptionBox.Size     = nil
         cyc_NOptionText.Area    = nil
         cyc_HOptionText.Area    = nil
         cyc_POptionText.Area    = nil
         cyc_NOptionText.Content = nil
         cyc_HOptionText.Content = nil
         cyc_POptionText.Content = nil
         cyc_NScrollerBox.Position = nil
         cyc_HScrollerBox.Position = nil
         cyc_DScrollerBox.Position = nil
         cyc_NScrollerBox.Size = nil
         cyc_HScrollerBox.Size = nil
         cyc_DScrollerBox.Size = nil
         cyc_NScrollerCursor.Position = nil
         cyc_HScrollerCursor.Position = nil
         cyc_PScrollerCursor.Position = nil
         cyc_DScrollerCursor.Position = nil
         cyc_NScrollerCursor.Size = nil
         cyc_HScrollerCursor.Size = nil
         cyc_PScrollerCursor.Size = nil
         cyc_DScrollerCursor.Size = nil
         cyc_NScrollerText.Area    = nil
         cyc_HScrollerText.Area    = nil
         cyc_PScrollerText.Area    = nil
         cyc_DScrollerText.Area    = nil
         cyc_NScrollerText.Content = nil
         cyc_HScrollerText.Content = nil
         cyc_PScrollerText.Content = nil
         cyc_DScrollerText.Content = nil
        
         If helpers.FieldIsNil(oString, "growdirection" )=0 Then cyc_GrowDirection  = oString.GrowDirection
         If helpers.FieldIsNil(oString, "visibleoptions")=0 Then cyc_Visibleoptions = oString.VisibleOptions
         If helpers.FieldIsNil(oString, "optionheight"  )=0 Then cyc_OptionHeight   = oString.OptionHeight
         If helpers.FieldIsNil(oData, "noptionbox")=0 Then cyc_NOptionBox = scui.NewBevel(cyc_NOptionBox, oData.NOptionBox, 1)
         If helpers.FieldIsNil(oData, "hoptionbox")=0 Then cyc_HOptionBox = scui.NewBevel(cyc_HOptionBox, oData.HOptionBox, 1)
         If helpers.FieldIsNil(oData, "poptionbox")=0 Then cyc_POptionBox = scui.NewBevel(cyc_POptionBox, oData.POptionBox, 1)
         If helpers.FieldIsNil(oData, "noptiontext")=0 Then cyc_NOptionText = scui.NewText(cyc_NOptionText, oData.NOptionText, 1)
         If helpers.FieldIsNil(oData, "hoptiontext")=0 Then cyc_HOptionText = scui.NewText(cyc_HOptionText, oData.HOptionText, 1)
         If helpers.FieldIsNil(oData, "poptiontext")=0 Then cyc_POptionText = scui.NewText(cyc_POptionText, oData.POptionText, 1)
         If helpers.FieldIsNil(oData, "nscrollerbox")=0 Then cyc_NScrollerBox = scui.NewText(cyc_NScrollerBox, oData.NScrollerBox, 1)
         If helpers.FieldIsNil(oData, "hscrollerbox")=0 Then cyc_HScrollerBox = scui.NewText(cyc_HScrollerBox, oData.HScrollerBox, 1)
         If helpers.FieldIsNil(oData, "dscrollerbox")=0 Then cyc_DScrollerBox = scui.NewText(cyc_DScrollerBox, oData.DScrollerBox, 1)
         If helpers.FieldIsNil(oData, "nscrollercursor")=0 Then cyc_NScrollerCursor = scui.NewBevel(cyc_NScrollerCursor, oData.NScrollerCursor, 1)
         If helpers.FieldIsNil(oData, "hscrollercursor")=0 Then cyc_HScrollerCursor = scui.NewBevel(cyc_HScrollerCursor, oData.HScrollerCursor, 1)
         If helpers.FieldIsNil(oData, "pscrollercursor")=0 Then cyc_PScrollerCursor = scui.NewBevel(cyc_PScrollerCursor, oData.PScrollerCursor, 1)
         If helpers.FieldIsNil(oData, "dscrollercursor")=0 Then cyc_DScrollerCursor = scui.NewBevel(cyc_DScrollerCursor, oData.DScrollerCursor, 1)
         If helpers.FieldIsNil(oData, "nscrollertext")=0 Then cyc_NScrollerText = scui.NewText(cyc_NScrollerText, oData.NScrollerText, 1)
         If helpers.FieldIsNil(oData, "hscrollertext")=0 Then cyc_HScrollerText = scui.NewText(cyc_HScrollerText, oData.HScrollerText, 1)
         If helpers.FieldIsNil(oData, "pscrollertext")=0 Then cyc_PScrollerText = scui.NewText(cyc_PScrollerText, oData.PScrollerText, 1)
         If helpers.FieldIsNil(oData, "dscrollertext")=0 Then cyc_DScrollerText = scui.NewText(cyc_DScrollerText, oData.DScrollerText, 1)
         If helpers.FieldIsNil(oData, "container")=0 Then cyc_Container = scui.NewBevel(cyc_Container, oData.Container, 1)
        
         /* Verifica se si tratta di un Child */
         If helpers.IsNil(IFOParent)=0
             cyc_Type   = #IFOTYPE_CHILD
             cyc_Parent = IFOParent
         EndIf
        
         /* Memorizzazione nuovo oggetto */
         scui.IFO[ObjID] = { Visible        = cyc_Visible,
                             Enabled        = cyc_Enabled,
                             Status         = cyc_Status,
                             oType          = cyc_Type,
                             oClass         = cyc_Class,
                             oParent        = cyc_Parent,
                             oInteractive   = cyc_Interactive,
                             Owner          = Owner,
                             oName          = oName,
                             ButtonPosition = oPosition,
                             ButtonSize     = oSize,
                             GrowDirection  = cyc_GrowDirection,
                             OptionsCount   = cyc_OptionsCount,
                             Options        = cyc_Options,
                             OptionHeight   = cyc_OptionHeight,
                             CurrentOption  = cyc_DefaultOption + 1,
                             PreviousOption = cyc_DefaultOption,
                             VisibleOptions = cyc_VisibleOptions,
                             Childs         = { [1] = cycle },
                             ChildCount     = cyc_ChildCount,
                             DropShadow     = cyc_DropShadow,
                             ShadowOffsetX  = cyc_DropShadowX,
                             ShadowOffsetY  = cyc_DropShadowY,
                             Actions        = { },
                             oData          = { NOptionBox    = cyc_NOptionBox,
                                                HOptionBox    = cyc_HOptionBox,
                                                POptionBox    = cyc_POptionBox,
                                                NOptionText   = cyc_NOptionText,
                                                HOptionText   = cyc_HOptionText,
                                                POptionText   = cyc_POptionText,
                                                NScrollerBox  = cyc_NScrollerBox,
                                                HScrollerBox  = cyc_HScrollerBox,
                                                DScrollerBox  = cyc_DScrollerBox,
                                                NScrollerCurs = cyc_NScrollerCursor,
                                                HScrollerCurs = cyc_HScrollerCursor,
                                                PScrollerCurs = cyc_PScrollerCursor,
                                                DScrollerCurs = cyc_DScrollerCursor,
                                                NScrollerText = cyc_NScrollerText,
                                                HScrollerText = cyc_HScrollerText,
                                                PScrollerText = cyc_PScrollerText,
                                                DScrollerText = cyc_DScrollerText,
                                                Container     = cyc_Container
                                               }
                            }
			/* Memorizza le azioni consentite */
         If helpers.FieldIsNil(oActions, "onreleased" )=0 Then scui.IFO[ObjID].Actions.OnReleased = oActions.OnReleased
         If helpers.FieldIsNil(oActions, "onchanged" )=0 Then scui.IFO[ObjID].Actions.OnChanged = oActions.OnChanged       
         If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(ObjID)
			Return(ObjID)


   Case #IFOCLASS_LISTVIEW
		;+--------------------------------------------------------[ LISTVIEW ]--+
		;| Interactive: YES                                                     |
		;| Supported Fields in Aspect table (oData)                             |
		;|  - Container          BevelStruct: ListView container                |
		;|  - NScrollerBox       BevelStruct: Scroller container (normal)       |
		;|  - HScrollerBox       BevelStruct: Scroller container (hilighted)    |
		;|  - DScrollerBox       BevelStruct: Scroller container (disabled)     |
		;|  - NScrollerCursor    BevelStruct: Scroller cursor (normal)          |
		;|  - HScrollerCursor    BevelStruct: Scroller cursor (hilighted)       |
		;|  - PScrollerCursor    BevelStruct: Scroller cursor (pushed)          |
		;|  - DScrollerCursor    BevelStruct: Scroller cursor (disabled)        |
		;|  - NScrollerText      TextStruct: Scroller cursor's text (normal)    |
		;|  - HScrollerText      TextStruct: Scroller cursor's text (hilighted) |
		;|  - PScrollerText      TextStruct: Scroller cursor's text (pushed)    |
		;|  - DScrollerText      TextStruct: Scroller cursor's text (disabled)  |
		;|  - NHeaderBox         BevelStruct: Column's header box (normal)      |
		;|  - HHeaderBox         BevelStruct: Column's header box (hilighted)   |
		;|  - PHeaderBox         BevelStruct: Column's header box (pushed)      |
		;|  - DHeaderBox         BevelStruct: Column's header box (disabled)    |
		;|  - NHeaderText        TextStruct: Column's header text (normal)      |
		;|  - HHeaderText        TextStruct: Column's header text (hilighted)   |
		;|  - PHeaderText        TextStruct: Column's header text (pushed)      |
		;|  - DHeaderText        TextStruct: Column's header text (disabled)    |
		;|  - NChoiceBox         BevelStruct: ListView Row (normal)             |
		;|  - HChoiceBox         BevelStruct: ListView Row (hilighted)          |
		;|  - PChoiceBox         BevelStruct: ListView Row (pushed)             |
		;|  - NChoiceText        TextStruct: ListView Row's Text (normal)       |
		;|  - HChoiceText        TextStruct: ListView Row's Text (hilighted)    |
		;|  - PChoiceText        TextStruct: ListView Row's Text (pushed)       |
		;|  - Visible            #IFO_VISIBLE or #IFO_HIDDEN                    |
		;|  - Enabled            #IFO_ENABLED or #IFO_DISABLED                  |
		;| Supported Fields in Params table (oString)                           |
		;|  - Mode               Sets if you can select only one row or freely  |
		;|                       any available row, can be:                     |
		;|                         #OPTMODE_ONLYONE or #OPTMODE_FREE            |
		;|  - RowHeight          Sets the height in pixels of the rows          |
		;|  - FieldNames         It's a table containing the column's names,    |
		;|                       for example:                                   |
		;|                          { "Name", "Surname", "Age" }                |
		;|  - Entries            It's a table storing all available rows, the   |
		;|                       format is:                                     |
		;|                          { item1, item2, item3, ... }                |
		;|                       each <item> is a table with a number of        |
		;|                       elements equal to the declared columns name,   |
		;|                       for example:                                   |
		;|                          { { "Fabio", "Falcucci", "36" },            |
		;|                            { "Peter", "Pan", "14" },                 |
		;|                            { "Mickey", "Mouse", "??" } }             |
		;|  - Sizes              It's a table with the sizes (pecentual values) |
		;|                       of each columns, like:                         |
		;|                          { 40, 40, 20 }                              |
		;|                       The sum of the sizes should be 100 but no      |
		;|                       checks will be performed on this value.        |
		;|  - Selected           It's a table storing which rows are initially  |
		;|                       selected by default, for example:              |
		;|                          { 0, 1, 1 }                                 |
		;|                       means that <Peter Pan> and <Mickey Mouse> rows |
		;|                       will be selected by default. For each row you  |
		;|                       have to specify the row's status with 1        |
		;|                       (selected) or 0 (not selected)                 |
		;| Supported Fields in Actions table (oActions)                         |
		;|  - OnChanged          Function to call every time the ListView       |
		;|                       selected item changes its state.               |
		;+----------------------------------------------------------------------+
        If helpers.IsNil(ForceID) = 0
			/* RIGENERAZIONE: Auto-carica i parametri */
			Local Obj = scui.IFO[id]
			Local ObjData = Obj.oData
			Owner     = Obj.Owner
			oName     = Obj.oName
			oPosition = { x = ObjData.Container.Position.x, y = ObjData.Container.Position.y }
			oSize     = { x = ObjData.Container.Size.x,     y = ObjData.Container.Size.y }
         oData     = helpers.CloneTable(ObjData)
         
         /*
			oData     = { Container       = scui.NewBevel(ObjData.Container, nil, 1),
							  NScrollerBox    = scui.NewBevel(scui.theme.LView_NScrollerBox, ObjData.NScrollerBox, 1),
							  HScrollerBox    = scui.NewBevel(scui.theme.LView_HScrollerBox, ObjData.HScrollerBox, 1),
							  DScrollerBox    = scui.NewBevel(scui.theme.LView_DScrollerBox, ObjData.DScrollerBox, 1),
							  NScrollerCursor = scui.NewBevel(scui.theme.LView_NCursorBox, ObjData.NScrollerCursor, 1),
							  HScrollerCursor = scui.NewBevel(scui.theme.LView_HCursorBox, ObjData.HScrollerCursor, 1),
							  PScrollerCursor = scui.NewBevel(scui.theme.LView_PCursorBox, ObjData.PScrollerCursor, 1),
							  DScrollerCursor = scui.NewBevel(scui.theme.LView_DCursorBox, ObjData.DScrollerCursor, 1),
							  NScrollerText   = scui.NewText(scui.theme.LView_NCursorText, ObjData.NScrollerText, 1),
							  HScrollerText   = scui.NewText(scui.theme.LView_HCursorText, ObjData.HScrollerText, 1),
							  PScrollerText   = scui.NewText(scui.theme.LView_PCursorText, ObjData.PScrollerText, 1),
							  DScrollerText   = scui.NewText(scui.theme.LView_DCursorText, ObjData.DScrollerText, 1),
							  NHeaderBox      = scui.NewBevel(ObjData.NHeaderBox, nil, 1),
							  HHeaderBox      = scui.NewBevel(ObjData.HHeaderBox, nil, 1),
							  PHeaderBox      = scui.NewBevel(ObjData.PHeaderBox, nil, 1),
							  DHeaderBox      = scui.NewBevel(ObjData.DHeaderBox, nil, 1),
							  NHeaderText     = scui.NewText(ObjData.NHeaderText, nil, 1),
							  HHeaderText     = scui.NewText(ObjData.HHeaderText, nil, 1),
							  PHeaderText     = scui.NewText(ObjData.PHeaderText, nil, 1),
							  DHeaderText     = scui.NewText(ObjData.DHeaderText, nil, 1),
							  NChoiceBox      = scui.NewBevel(ObjData.NChoiceBox, nil, 1),
							  HChoiceBox      = scui.NewBevel(ObjData.HChoiceBox, nil, 1),
							  PChoiceBox      = scui.NewBevel(ObjData.PChoiceBox, nil, 1),
							  NChoiceText     = scui.NewText(ObjData.NChoiceText, nil, 1),
							  HChoiceText     = scui.NewText(ObjData.HChoiceText, nil, 1),
							  PChoiceText     = scui.NewText(ObjData.PChoiceText, nil, 1),
							  Visible         = Obj.Visible,
							  Enabled         = Obj.Enabled }
                       */
                       
		   /* Verifica se le tabelle <Entries> e <Selected> hanno le stesse dimensioni */
			If helpers.FieldIsNil(Obj.Selected) = 1 Then Obj.Selected = {}
			Local selcnt = helpers.CountEntries(Obj.Selected) - 1
			Local entcnt = helpers.CountEntries(Obj.Entries) - 1
			Local i = 0
			If selcnt < entcnt
				/* Selected sono meno degli elementi */
				For i = (selcnt + 1) To entcnt
					Obj.Selected[i] = 0
				Next
			ElseIf entcnt < selcnt
				For i = (entcnt + 1) To selcnt
					Obj.Selected[i] = nil
				Next
			EndIf

			oString   = { FieldNames   = Obj.FieldNames,
							  Entries      = Obj.Entries,
							  Sizes        = Obj.Sizes,
							  Selected     = Obj.Selected,
							  Mode         = Obj.Mode,
							  RowHeight    = Obj.RowHeight }
			oActions  = { }
			If helpers.FieldIsNil(Obj.Actions, "onchanged" ) = 0 Then oActions.OnChanged = Obj.Actions.OnChanged
			
			/* Elimino il vecchio gadget e i relativi Childs */
			scui.RemoveObject(id)
         scui.QuickFind[oName] = id

	   EndIf

		/* Se non presenti genera delle tabelle vuote */
      Local ObjID = id
      If helpers.IsNil(oData   )=1 Then oData    = {}
      If helpers.IsNil(oActions)=1 Then oActions = {}
      If helpers.IsNil(oString )=1 Then oString  = {}

      Local lv_StartOption = 1 ; Primo elemento da visualizzare nella prima riga della LV 
        
      /* Definizione Container */
      Local lv_TempContainer = { Position = { x = oPosition.x, y = oPosition.y },
                                 Size     = { x = oSize.x,     y = oSize.y } }
      Local lv_Container = scui.NewBevel(scui.theme.LView_Container, lv_TempContainer)
      If helpers.FieldIsNil(oData, "container")=0 Then lv_Container = scui.NewBevel(lv_Container, oData.Container, 1)

      /* Definzione dei parametri delle righe della LV */
      Local mul = 1
      If lv_Container.Type = #BEVELTYPE_SUNKEN Then mul = 2
      Local lv_RowWidth      = lv_Container.Size.x - lv_Container.Height * mul * 2
      Local lv_WorkingHeight = lv_Container.Size.y - lv_Container.Height * mul * 2
      Local lv_RowHeight     = scui.theme.ListView_RowHeight
      If helpers.FieldIsNil(oString, "rowheight") = 0 Then lv_RowHeight = oString.RowHeight
      Local lv_VisibleRows   = Int((lv_WorkingHeight+1) / (lv_RowHeight+1)) - 1
      /* Check degli elenchi dati */
      /* <FieldNames> */
      If helpers.FieldIsNil(oString, "fieldnames") = 1 Then oString.FieldNames = {}
      Local lv_FieldCount = helpers.CountEntries(oString.FieldNames)
      Local lv_FieldNames = oString.FieldNames
      /* <Entries> */
      If helpers.FieldIsNil(oString, "entries") = 1 Then oString.Entries = {}
      Local lv_EntriesCount = helpers.CountEntries(oString.Entries)
      Local lv_Entries      = oString.Entries
      /* Sizes */
      Local lv_SizesPerc = {}
      Local lv_Sizes     = {}
      If helpers.FieldIsNil(oString, "sizes") = 1
         /* Se <Sizes> non esiste crea delle dimensioni standard per tutte le colonne */
         Local c = 0
         Local w = 0
         For c = 1 To lv_FieldCount
            w = w + Int(100/lv_FieldCount)
            lv_SizesPerc[c-1] = Int(100/lv_FieldCount)
         Next
         Local w2 = 100 - w
         lv_SizesPerc[lv_FieldCount-1] = lv_SizesPerc[lv_FieldCount-1] + w2
      Else
         lv_SizesPerc = oString.Sizes
      EndIf
		/* Bevel & Text dell'eventuale Scroller */
      Local lv_NeedVScroller = 0
      Local lv_ScrollerID = nil
      Local cyc_NScrollerBox = scui.NewBevel(scui.theme.LView_NScrollerBox, nil, 1)
      Local cyc_HScrollerBox = scui.NewBevel(scui.theme.LView_HScrollerBox, nil, 1)
      Local cyc_DScrollerBox = scui.NewBevel(scui.theme.LView_DScrollerBox, nil, 1)
      Local cyc_NScrollerCursor = scui.NewBevel(scui.theme.LView_NCursorBox, nil, 1)
      Local cyc_HScrollerCursor = scui.NewBevel(scui.theme.LView_HCursorBox, nil, 1)
      Local cyc_PScrollerCursor = scui.NewBevel(scui.theme.LView_PCursorBox, nil, 1)
      Local cyc_DScrollerCursor = scui.NewBevel(scui.theme.LView_DCursorBox, nil, 1)
      Local cyc_NScrollerText = scui.NewText(scui.theme.LView_NCursorText, nil, 1)
      Local cyc_HScrollerText = scui.NewText(scui.theme.LView_HCursorText, nil, 1)
      Local cyc_PScrollerText = scui.NewText(scui.theme.LView_PCursorText, nil, 1)
      Local cyc_DScrollerText = scui.NewText(scui.theme.LView_DCursorText, nil, 1)

		If helpers.FieldIsNil(oData, "nscrollerbox")=0 Then cyc_NScrollerBox = scui.NewBevel(cyc_NScrollerBox, oData.NScrollerBox, 1)
		If helpers.FieldIsNil(oData, "hscrollerbox")=0 Then cyc_HScrollerBox = scui.NewBevel(cyc_HScrollerBox, oData.HScrollerBox, 1)
		If helpers.FieldIsNil(oData, "dscrollerbox")=0 Then cyc_DScrollerBox = scui.NewBevel(cyc_DScrollerBox, oData.DScrollerBox, 1)
		If helpers.FieldIsNil(oData, "nscrollercursor")=0 Then cyc_NScrollerCursor = scui.NewBevel(cyc_NScrollerCursor, oData.NScrollerCursor, 1)
		If helpers.FieldIsNil(oData, "hscrollercursor")=0 Then cyc_HScrollerCursor = scui.NewBevel(cyc_HScrollerCursor, oData.HScrollerCursor, 1)
		If helpers.FieldIsNil(oData, "pscrollercursor")=0 Then cyc_PScrollerCursor = scui.NewBevel(cyc_PScrollerCursor, oData.PScrollerCursor, 1)
		If helpers.FieldIsNil(oData, "dscrollercursor")=0 Then cyc_DScrollerCursor = scui.NewBevel(cyc_DScrollerCursor, oData.DScrollerCursor, 1)
		If helpers.FieldIsNil(oData, "nscrollertext")=0 Then cyc_NScrollerText = scui.NewText(cyc_NScrollerText, oData.NScrollerText, 1)
		If helpers.FieldIsNil(oData, "hscrollertext")=0 Then cyc_HScrollerText = scui.NewText(cyc_HScrollerText, oData.HScrollerText, 1)
		If helpers.FieldIsNil(oData, "pscrollertext")=0 Then cyc_PScrollerText = scui.NewText(cyc_PScrollerText, oData.PScrollerText, 1)
		If helpers.FieldIsNil(oData, "dscrollertext")=0 Then cyc_DScrollerText = scui.NewText(cyc_DScrollerText, oData.DScrollerText, 1)

		/* Verifica se dobbiamo creare lo scroller oppure no */
      If lv_EntriesCount > lv_VisibleRows
         lv_NeedVScroller = 1
			Local s2 = 0
			Local s1 = 0
            
			/* Ridimensiona le righe per fare posto per lo Scroller */
         Local OutlineSize = 0
			Local BorderMul = 1
         If cyc_NScrollerBox.Outline.Type <> #BEVELTYPE_NONE
            If cyc_NScrollerBox.Outline.Type = #BEVELTYPE_SUNKEN
					s2 = cyc_NScrollerBox.Outline.Size2
					BorderMul = 2
				EndIf
            s1 = cyc_NScrollerBox.Outline.Size1
         EndIf
                    
         Local BorderSize = lv_Container.Height * BorderMul                    
         Local ScrollerWidth = scui.theme.ListView_ScrollerWidth
         lv_RowWidth = lv_RowWidth - ScrollerWidth
			Local TempVal = lv_Container.Position.x + lv_Container.Size.x - BorderSize
         Local ScrollerStartX = TempVal - scui.theme.ListView_ScrollerWidth - s1*2 - s2*2 + 1
         Local ScrollerEndX   = TempVal - s1 - s2
         Local ScrollerStartY = lv_Container.Position.y + BorderSize + s1 + s2
         Local ScrollerEndY   = lv_Container.Position.y + lv_Container.Size.y - BorderSize - s1 - s2
         Local ScrollerRange  = lv_EntriesCount - lv_VisibleRows

         Local ScrollerPosition = { x = ScrollerStartX, y = ScrollerStartY }
         Local ScrollerSize     = { x = ScrollerEndX - ScrollerStartX, y = ScrollerEndY - ScrollerStartY }

			/* Creazione dello Scroller */
			/* OLD CODE
         lv_ScrollerID = scui.NewObject( #IFOCLASS_SIMPLESCROLLER, "", 
													  ScrollerPosition, ScrollerSize,
													  { Cursor  = cyc_NScrollerCursor,
														 HCursor = cyc_HScrollerCursor,
														 PCursor = cyc_PScrollerCursor,
														 DCursor = cyc_DScrollerCursor,
														 Container  = cyc_NScrollerBox,
														 HContainer = cyc_HScrollerBox,
														 DContainer = cyc_DScrollerBox,
														 Text  = cyc_NScrollerText,
														 HText = cyc_HScrollerText,
														 PText = cyc_PScrollerText,
														 DText = cyc_DScrollerText },
													  { MMin = 0, MMax = ScrollerRange, Current = lv_StartOption - 1, MinStep = 1, 
														 Type = #SCROLLERTYPE_VERTICAL },
													  nil,
													  ObjID,
													  nil,
													  1,
													  Owner)
			*/
			lv_ScrollerID = scui.NewObject( #IFOCLASS_SCROLLER, oName .. ".Scroller", ScrollerPosition, ScrollerSize, nil,
								                { ;ArrowSize = 26,
								                  ArrowMode  = scui.theme.Scroller_ArrowMode,
														CursorText = #SCROLLER_TEXT_NONE,
														HandleType = scui.theme.Scroller_KnobType,
														ArrowStep  = 1,
								                  TotalItems = lv_EntriesCount,
								                  FirstItem  = lv_StartOption - 1,
														VisibleItems = lv_VisibleRows,
								                  Type = #SCROLLERTYPE_VERTICAL },
													   nil,
													   ObjID,
													   nil,
													   1,
													   Owner)

      Else
         lv_VisibleRows = lv_EntriesCount
      EndIf

		/* Calcola la larghezza in percentuale in Pixel */
      Local c = 0
      Local w = 0
      Local last_visiblecol = -1
      For c = 1 To lv_FieldCount
         w = w + Int(lv_RowWidth * lv_SizesPerc[c-1] / 100)
         lv_Sizes[c-1] = Int(lv_RowWidth * lv_SizesPerc[c-1] / 100)
         If lv_SizesPerc[c-1] > 0 Then last_visiblecol = c-1
      Next
      Local w2 = lv_RowWidth - w

      lv_Sizes[last_visiblecol] = lv_Sizes[last_visiblecol] + w2
      /* Definizione Header delle colonne */
      lv_Switch_NHeaderBox = scui.NewBevel(scui.theme.LView_NHeaderBox, nil)
      lv_Switch_HHeaderBox = scui.NewBevel(scui.theme.LView_HHeaderBox, nil)
      lv_Switch_PHeaderBox = scui.NewBevel(scui.theme.LView_PHeaderBox, nil)
      lv_Switch_DHeaderBox = scui.NewBevel(scui.theme.LView_DHeaderBox, nil)
      If helpers.FieldIsNil(oData, "nheaderbox")=0 Then lv_Switch_NHeaderBox = scui.NewBevel(lv_Switch_NHeaderBox, oData.NHeaderBox, 1)
      If helpers.FieldIsNil(oData, "hheaderbox")=0 Then lv_Switch_HHeaderBox = scui.NewBevel(lv_Switch_HHeaderBox, oData.HHeaderBox, 1)
      If helpers.FieldIsNil(oData, "pheaderbox")=0 Then lv_Switch_PHeaderBox = scui.NewBevel(lv_Switch_PHeaderBox, oData.PHeaderBox, 1)
      If helpers.FieldIsNil(oData, "dheaderbox")=0 Then lv_Switch_DHeaderBox = scui.NewBevel(lv_Switch_DHeaderBox, oData.DHeaderBox, 1)
      /* lv_Switch_NHeaderBox.Position = nil
      lv_Switch_NHeaderBox.Size     = nil
      lv_Switch_HHeaderBox.Position = nil
      lv_Switch_HHeaderBox.Size     = nil
      lv_Switch_PHeaderBox.Position = nil
      lv_Switch_PHeaderBox.Size     = nil
      lv_Switch_DHeaderBox.Position = nil
      lv_Switch_DHeaderBox.Size     = nil */

      lv_Switch_NHeaderText = scui.NewText(scui.theme.LView_NHeaderText, nil)
      lv_Switch_HHeaderText = scui.NewText(scui.theme.LView_HHeaderText, nil)
      lv_Switch_PHeaderText = scui.NewText(scui.theme.LView_PHeaderText, nil)
      lv_Switch_DHeaderText = scui.NewText(scui.theme.LView_DHeaderText, nil)
      If helpers.FieldIsNil(oData, "nheadertext")=0 Then lv_Switch_NHeaderText = scui.NewText(lv_Switch_NHeaderText, oData.NHeaderText, 1)
      If helpers.FieldIsNil(oData, "hheadertext")=0 Then lv_Switch_HHeaderText = scui.NewText(lv_Switch_HHeaderText, oData.HHeaderText, 1)
      If helpers.FieldIsNil(oData, "pheadertext")=0 Then lv_Switch_PHeaderText = scui.NewText(lv_Switch_PHeaderText, oData.PHeaderText, 1)
      If helpers.FieldIsNil(oData, "dheadertext")=0 Then lv_Switch_DHeaderText = scui.NewText(lv_Switch_DHeaderText, oData.DHeaderText, 1)
      lv_Switch_NHeaderText.Area    = nil
      lv_Switch_NHeaderText.Content = nil
      lv_Switch_HHeaderText.Area    = nil
      lv_Switch_HHeaderText.Content = nil
      lv_Switch_PHeaderText.Area    = nil
      lv_Switch_PHeaderText.Content = nil
      lv_Switch_DHeaderText.Area    = nil
      lv_Switch_DHeaderText.Content = nil

		/* Loop di creazione Pulsanti degli Header */
      Local lv_StartX = oPosition.x + lv_Container.Height * mul
      Local lv_StartY = oPosition.y + lv_Container.Height * mul
      Local c = 0

      Local lv_Childs =  {}
      Local lv_ChildsCount = 0
      Local lv_px1
      Local sw
      
      ; ATTENZIONE: LE ULTIME COLONNE A DIMENSIONE ZERO
      ; DEVONO ESSERE TUTTE ASSIEME, NON POSSONO ESSERE
      ; MISCHIATE , ALMENO PER ORA
      For c = 1 To lv_FieldCount
;Crea il pulsante solo se la dimensione e' maggiore di zero
If lv_Sizes[c-1] > 0
         If c <> lv_FieldCount Then lv_px1 = 1 Else lv_px1 = -1
         Local lv_TempPos  = { x = lv_StartX, y = lv_StartY }
         Local lv_TempSize = { x = lv_Sizes[c-1] - lv_px1 , y = lv_RowHeight }
         Local sw = scui.NewObject(#IFOCLASS_BUTTON, oName .. ".Header." .. lv_FieldNames[c-1],
                                   lv_TempPos, lv_TempSize, 
                                   { Bevel  = lv_Switch_NHeaderBox,
                                     HBevel = lv_Switch_HHeaderBox,
                                     PBevel = lv_Switch_PHeaderBox,
                                     DBevel = lv_Switch_DHeaderBox,
                                     Text  = lv_Switch_NHeaderText,
                                     HText = lv_Switch_HHeaderText,
                                     PText = lv_Switch_PHeaderText,
                                     DText = lv_Switch_DHeaderText},
                                   { Values = { lv_FieldNames[c-1] }, Lines = 1 },
                                   nil,
                                   ObjID,
                                   nil,
                                   1,
                                   Owner)
         lv_StartX = lv_StartX + lv_Sizes[c-1]
         lv_ChildsCount = lv_ChildsCount + 1
         lv_Childs[lv_ChildsCount] = sw
EndIf
      Next
		
		/* Definizione delle righe di selezione */
      Local lv_NChoiceBox = scui.NewBevel(scui.theme.LView_NChoiceBox, nil)
      Local lv_HChoiceBox = scui.NewBevel(scui.theme.LView_HChoiceBox, nil)
      Local lv_PChoiceBox = scui.NewBevel(scui.theme.LView_PChoiceBox, nil)
      Local lv_NChoiceText = scui.NewText(scui.theme.LView_NChoiceText, nil)
      Local lv_HChoiceText = scui.NewText(scui.theme.LView_HChoiceText, nil)
      Local lv_PChoiceText = scui.NewText(scui.theme.LView_PChoiceText, nil)
      If helpers.FieldIsNil(oData, "nchoicebox")=0 Then lv_NChoiceBox = scui.NewBevel(lv_NChoiceBox, oData.NChoiceBox, 1)
      If helpers.FieldIsNil(oData, "hchoicebox")=0 Then lv_HChoiceBox = scui.NewBevel(lv_HChoiceBox, oData.HChoiceBox, 1)
      If helpers.FieldIsNil(oData, "pchoicebox")=0 Then lv_PChoiceBox = scui.NewBevel(lv_PChoiceBox, oData.PChoiceBox, 1)
      If helpers.FieldIsNil(oData, "nchoicetext")=0 Then lv_NChoiceText = scui.NewText(lv_NChoiceText, oData.NChoiceText, 1)
      If helpers.FieldIsNil(oData, "hchoicetext")=0 Then lv_HChoiceText = scui.NewText(lv_HChoiceText, oData.HChoiceText, 1)
      If helpers.FieldIsNil(oData, "pchoicetext")=0 Then lv_PChoiceText = scui.NewText(lv_PChoiceText, oData.PChoiceText, 1)
      /* lv_NChoiceBox.Position = nil
      lv_NChoiceBox.Size     = nil
      lv_HChoiceBox.Position = nil
      lv_HChoiceBox.Size     = nil
      lv_PChoiceBox.Position = nil
      lv_PChoiceBox.Size     = nil */
      lv_NChoiceText.Content = nil
      lv_NChoiceText.Area    = nil
      lv_HChoiceText.Content = nil
      lv_HChoiceText.Area    = nil
      lv_PChoiceText.Content = nil
      lv_PChoiceText.Area    = nil

		Local lv_Selected = {}
      If helpers.FieldIsNil(oString, "selected") = 0
			lv_Selected = oString.Selected
			If helpers.CountEntries(lv_Entries) <> helpers.CountEntries(lv_Selected)
		      Local r = 0
		      For r = 0 To lv_EntriesCount - 1
		         lv_Selected[r] = 0
		      Next
			EndIf
		Else
	      Local r = 0
	      For r = 0 To lv_EntriesCount - 1
	         lv_Selected[r] = 0
	      Next
		EndIf
        
      /* Genera lo Switch delle righe */
      Local r = 0
      Local c = 0
      Local sw
		Local TempVal = lv_Container.Height * mul
      Local lv_StartX = oPosition.x + TempVal
      Local lv_StartY = oPosition.y + TempVal + lv_RowHeight + 1
      Local lv_Choices = {}
      
      Local lv_Visible     = #IFO_VISIBLE
      Local lv_Enabled     = #IFO_ENABLED

      If helpers.FieldIsNil(oData, "visible")=0 Then lv_Visible = oData.Visible
      If helpers.FieldIsNil(oData, "enabled")=0 Then lv_Enabled = oData.Enabled

; Conta le colonne visibili
Local vcol = 0
For i = 1 To lv_FieldCount
   If  lv_Sizes[i-1] < 0 Then Break
   vcol = vcol + 1
Next

		For r = 1 To lv_VisibleRows
         Local xt = lv_StartX
         lv_Choices[r] = {}
         Local c = 1
			If c <> lv_FieldCount Then lv_px1 = 1 Else lv_px1 = 0
			Local lv_TempPos  = { x = xt, y = lv_StartY }
			Local lv_TempSize = { x = lv_RowWidth , y = lv_RowHeight }
			Local tEntry = {}
			Local te
			For te = 1 To lv_FieldCount
				tEntry[te - 1] = lv_Entries[r - 1 + lv_StartOption - 1][te - 1]
			Next
			Local sw = scui.NewObject(#IFOCLASS_SWITCH, oName .. ".Row." .. r,
											  lv_TempPos,
											  lv_TempSize,
											  { Bevel  = lv_NChoiceBox,
												 HBevel = lv_HChoiceBox,
												 PBevel = lv_PChoiceBox,
												 Text  = lv_NChoiceText,
												 HText = lv_HChoiceText,
												 PText = lv_PChoiceText,
                                     Enabled = lv_Enabled },
											  { Values = tEntry, Lines = vcol, ;lv_FieldCount,
												 MultiCol = True,
												 ColSizes = oString.Sizes },
											  nil,
											  ObjID,
											  nil,
											  1,
											  Owner)

			/* Controlla se la riga e' selezionata */
			If lv_Selected[r - 1] = 1
				; OTTIMIZZARE METTENDO IL VALORE DIRETTAMENTE DURANTE LA CREAZIONE
				scui.IFO[sw].Status = #IFOSTATUS_PUSHED
				scui.IFO[sw].Value  = 1
			EndIf
				  
			xt = xt + lv_Sizes[c - 1]
			lv_Choices[r][c] = { SwitchID = sw, OptionID = r + lv_StartOption - 1}
			lv_ChildsCount = lv_ChildsCount + 1
			lv_Childs[lv_ChildsCount] = sw
			lv_StartY = lv_StartY + lv_RowHeight + 1
	   Next

      Local lv_Status      = #IFOSTATUS_NORMAL
      Local lv_Interactive = 0
      Local lv_Class       = #IFOCLASS_LISTVIEW
      Local lv_Parent      = nil
      Local lv_Type        = #IFOTYPE_BASIC     
      Local lv_Mode        = #OPTMODE_ONLYONE

      If helpers.FieldIsNil(oString, "mode" )=0 Then lv_Mode = oString.Mode
                
      /* Verifica se questo controllo e' un Child */
      If helpers.IsNil(IFOParent)=0
         lv_Type   = #IFOTYPE_CHILD
         lv_Parent = IFOParent
      EndIf
        
      /* Memorizza l'oggetto */
      scui.IFO[ObjID] = { Visible        = lv_Visible,
                            Enabled        = lv_Enabled,
                            Status         = lv_Status,
                            oType          = lv_Type,
                            oClass         = lv_Class,
                            oParent        = lv_Parent,
                            oInteractive   = lv_Interactive,
                            Owner        = Owner,
                            oName        = oName,
                            Mode           = lv_Mode,
                            FieldCount     = lv_FieldCount,
                            FieldNames     = lv_FieldNames,
                            VisibleRows    = lv_VisibleRows,
                            EntriesCount   = lv_EntriesCount,
                            Entries        = lv_Entries,
                            Childs         = lv_Childs,
                            ChildCount     = lv_ChildsCount,
                            Choices        = lv_Choices,
                            ScrollerID     = lv_ScrollerID,
                            StartOption    = lv_StartOption,
                            Selected       = lv_Selected,
                            Sizes          = lv_SizesPerc,
                            RowHeight      = lv_RowHeight,
                            Actions        = { },
                            oData          = { Container       = lv_Container,
                                               NScrollerBox    = cyc_NScrollerBox,
                                               HScrollerBox    = cyc_HScrollerBox,
                                               DScrollerBox    = cyc_DScrollerBox,
                                               NScrollerCursor = cyc_NScrollerCursor,
                                               HScrollerCursor = cyc_HScrollerCursor,
                                               PScrollerCursor = cyc_PScrollerCursor,
                                               DScrollerCursor = cyc_DScrollerCursor,
                                               NScrollerText   = cyc_NScrollerText,
                                               HScrollerText   = cyc_HScrollerText,
                                               PScrollerText   = cyc_PScrollerText,
                                               DScrollerText   = cyc_DScrollerText,
                                               NHeaderBox      = lv_Switch_NHeaderBox,
                                               HHeaderBox      = lv_Switch_HHeaderBox,
                                               PHeaderBox      = lv_Switch_PHeaderBox,
                                               DHeaderBox      = lv_Switch_DHeaderBox,
                                               NHeaderText     = lv_Switch_NHeaderText,
                                               HHeaderText     = lv_Switch_HHeaderText,
                                               PHeaderText     = lv_Switch_PHeaderText,
                                               DHeaderText     = lv_Switch_DHeaderText,
                                               NChoiceBox      = lv_NChoiceBox,
                                               HChoiceBox      = lv_HChoiceBox,
                                               PChoiceBox      = lv_PChoiceBox,
                                               NChoiceText     = lv_NChoiceText,
                                               HChoiceText     = lv_HChoiceText,
                                               PChoiceText     = lv_PChoiceText,
                                               }
                            } 
      If helpers.FieldIsNil(oActions, "onchanged" )=0 Then scui.IFO[ObjID].Actions.OnChanged = oActions.OnChanged        
      If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(ObjID)
		Return(ObjID)
        
    Case #IFOCLASS_TABS
		;+------------------------------------------------------------[ TABS ]--+
		;| Interactive: YES                                                     |
		;| Supported Fields in Aspect table (oData)                             |
		;|  - Container      BevelStruct: Container of the tab gadget and the   |
		;|                   container of the page selector                     |
		;|  - NSelBox        BevelStruct: drop down option box (normal)         |
		;|  - HSelBox        BevelStruct: drop down option box (hilighted)      |
		;|  - PSelBox        BevelStruct: drop down option box (pushed)         |
		;|  - DSelBox        BevelStruct: drop down option box (disabled)       |
		;|  - NSelText       TextStruct: drop down option Text (normal)         |
		;|  - HSelText       TextStruct: drop down option Text (hilighted)      |
		;|  - PSelText       TextStruct: drop down option Text (pushed)         |
		;|  - DSelText       TextStruct: drop down option Text (disabled)       |
		;|  - ContentFrame   BevelStruct: area where all the tab gadgets will be|
		;|                   placed                                             |
		;|  - Visible        #IFO_VISIBLE or #IFO_HIDDEN                        |
		;|  - Enabled        #IFO_ENABLED or #IFO_DISABLED                      |
		;| Supported Fields in Params table (oString)                           |
		;|  - SelectorWidth  Is the width in pixels of the page selector        |
		;|  - SelectorHeight Is the height in pixels of the page selector       |
		;|  - SelectorOffset Is the offset in pixels from the reference side    |
		;|  - SelectorAlignment  Sets the reference side for the selector       |
		;|                       position, can be:                              |
		;|                         #OPT_RIGHTSWITCH or #OPT_LEFTSWITCH          |
		;|  - PageNames      It's a table storing all tab page's names, for     |
		;|                   example:                                           |
		;|                      { "Page 1", "Page 2" }                          |
		;|  - GadgetList     Here you have to declare all gadgets for every     |
		;|                   defined page                                       |
		;| Supported Fields in Actions table (oActions)                         |
		;|  - Actually no events are supported                                  |
      ;+----------------------------------------------------------------------+
      Local ObjID = id
      If helpers.IsNil(oData   )=1 Then oData    = {}
      If helpers.IsNil(oActions)=1 Then oActions = {}
      If helpers.IsNil(oString )=1 Then oString  = {}

      /* Big Container */
      Local tabs_TempBig = { Position = { x = oPosition.x, y = oPosition.y },
                             Size     = { x = oSize.x,     y = oSize.y } }
      Local tabs_BigContainer = scui.NewBevel(scui.theme.Tabs_Container, tabs_TempBig)
      If helpers.FieldIsNil(oData, "container") = 0 Then tabs_BigContainer = scui.NewBevel(tabs_BigContainer, oData.Container, 1)
        
      /* Small Container */
      Local tabs_SelectorWidth  = scui.theme.Tabs_SelectorWidth
      Local tabs_SelectorHeight = scui.theme.Tabs_SelectorHeight
      Local tabs_SelectorOffset = scui.theme.Tabs_SelectorOffset
      Local tabs_SmallContainerPosition = #OPT_RIGHTSWITCH

      If helpers.FieldIsNil(oString, "selectorwidth" ) = 0 Then tabs_SelectorWidth  = oString.SelectorWidth
      If helpers.FieldIsNil(oString, "selectorheight") = 0 Then tabs_SelectorHeight = oString.SelectorHeight
      If helpers.FieldIsNil(oString, "selectoroffset") = 0 Then tabs_SelectorOffset = oString.SelectorOffset
      If helpers.FieldIsNil(oString, "selectoralignment") = 0 Then tabs_SmallContainerPosition = oString.SelectorAlignment

		Local tabs_mul = IIF(tabs_BigContainer.Type = #BEVELTYPE_SUNKEN , 2, IIF(tabs_BigContainer.Type <> #BEVELTYPE_NONE , 1, 0))
      Local tabs_ContainerBorder = tabs_BigContainer.Height * tabs_mul
      Local tabs_TempSelector = {}
      Local tabs_SelectorSize = {}
      If tabs_SmallContainerPosition = #OPT_RIGHTSWITCH
         tabs_TempSelector = { Position = { x = tabs_TempBig.Position.x + tabs_SelectorOffset,
                                            y = tabs_TempBig.Position.y - tabs_SelectorHeight + tabs_ContainerBorder/2 },
                               Size = { x = tabs_SelectorWidth, y = tabs_SelectorHeight } }
      Else
         tabs_TempSelector = { Position = { x = tabs_TempBig.Position.x + tabs_TempBig.Size.x - tabs_SelectorOffset - tabs_SelectorWidth,
                                            y = tabs_TempBig.Position.y - tabs_SelectorHeight + tabs_ContainerBorder/2 },
                               Size = { x = tabs_SelectorWidth, y = tabs_SelectorHeight } }
      EndIf
      Local tabs_SmallContainer = scui.NewBevel(scui.theme.Tabs_Container, tabs_TempSelector)
      If helpers.FieldIsNil(oData, "container") = 0 Then tabs_SmallContainer = scui.NewBevel(tabs_SmallContainer, oData.Container, 1)
                
      /* Page Selector (Cycle) */
      Local tabs_NSelBox = scui.theme.Tabs_NSelectorBox 
      Local tabs_HSelBox = scui.theme.Tabs_HSelectorBox
      Local tabs_PSelBox = scui.theme.Tabs_PSelectorBox
      Local tabs_DSelBox = scui.theme.Tabs_DSelectorBox
      Local tabs_NSeltext = scui.theme.Tabs_NSelectorText
      Local tabs_HSeltext = scui.theme.Tabs_HSelectorText
      Local tabs_PSeltext = scui.theme.Tabs_PSelectorText
      Local tabs_DSeltext = scui.theme.Tabs_DSelectorText
      If helpers.FieldIsNil(oData, "nselbox") = 0 Then tabs_NSelBox = scui.NewBevel(tabs_NSelBox, oData.NSelBox, 1)
      If helpers.FieldIsNil(oData, "hselbox") = 0 Then tabs_HSelBox = scui.NewBevel(tabs_HSelBox, oData.HSelBox, 1)
      If helpers.FieldIsNil(oData, "pselbox") = 0 Then tabs_PSelBox = scui.NewBevel(tabs_PSelBox, oData.PSelBox, 1)
      If helpers.FieldIsNil(oData, "dselbox") = 0 Then tabs_DSelBox = scui.NewBevel(tabs_DSelBox, oData.DSelBox, 1)
      If helpers.FieldIsNil(oData, "nseltext") = 0 Then tabs_NSelText = scui.NewText(tabs_NSelText, oData.NSelText, 1)
      If helpers.FieldIsNil(oData, "hseltext") = 0 Then tabs_HSelText = scui.NewText(tabs_HSelText, oData.HSelText, 1)
      If helpers.FieldIsNil(oData, "pseltext") = 0 Then tabs_PSelText = scui.NewText(tabs_PSelText, oData.PSelText, 1)
      If helpers.FieldIsNil(oData, "dseltext") = 0 Then tabs_DSelText = scui.NewText(tabs_DSelText, oData.DSelText, 1)
      Local tabs_PageNames = { "empty" }
      If helpers.FieldIsNil(oString, "pagenames") = 0 Then tabs_PageNames = oString.PageNames
      Local tabs_PSPosition = { x = tabs_SmallContainer.Position.x + tabs_ContainerBorder,
                                y = tabs_SmallContainer.Position.y + tabs_ContainerBorder }
      Local tabs_PSSize = { x = tabs_SmallContainer.Size.x - tabs_ContainerBorder * 2,
                            y = tabs_SmallContainer.Size.y - tabs_ContainerBorder }

      Local tabs_Visible     = #IFO_VISIBLE
      Local tabs_Enabled     = #IFO_ENABLED

      If helpers.FieldIsNil(oData, "visible")=0 Then tabs_Visible = oData.Visible
      If helpers.FieldIsNil(oData, "enabled")=0 Then tabs_Enabled = oData.Enabled

      Local tabs_PageSelector = scui.NewObject( #IFOCLASS_CYCLE, oName .. ".Pages",
                                                tabs_PSPosition,
                                                tabs_PSSize,
                                                { Cycle  = tabs_NSelBox,
                                                  HCycle = tabs_HSelBox,
                                                  PCycle = tabs_PSelBox,
                                                  DCycle = tabs_DSelBox,
                                                  Text   = tabs_NSelText,
                                                  HText  = tabs_HSelText,
                                                  PText  = tabs_PselText,
                                                  DText  = tabs_DSelText,
                                                  Enabled = tabs_Enabled },
                                                { Options = tabs_PageNames,
                                                  DefaultOption = 1 },
                                                nil,
                                                ObjID,
                                                nil,
                                                1,
                                                Owner)

      /* Contents Frame */
      Local tabs_ContentFrame = scui.NewBevel( scui.theme.Tabs_ContentFrame, nil )
		Local tabs_mul = IIF(tabs_ContentFrame.Type = #BEVELTYPE_SUNKEN , 2, IIF(tabs_ContentFrame.Type <> #BEVELTYPE_NONE , 1, 0))
      If helpers.FieldIsNil(oData, "contentframe") = 0 Then tabs_ContentFrame = scui.NewBevel(tabs_ContentFrame, oData.ContentFrame, 1)
      Local tabs_TempContFrame = { Position = { x = tabs_BigContainer.Position.x + scui.theme.Tabs_FrameBorder + tabs_ContainerBorder,
                                                y = tabs_BigContainer.Position.y + scui.theme.Tabs_FrameBorder + tabs_ContainerBorder},
                                   Size = { x = tabs_BigContainer.Size.x - scui.theme.Tabs_FrameBorder * 2 - tabs_ContainerBorder * 2,
                                            y = tabs_BigContainer.Size.y - scui.theme.Tabs_FrameBorder * 2 - tabs_ContainerBorder * 2} }
      tabs_ContentFrame = scui.NewBevel(tabs_ContentFrame, tabs_TempContFrame)
      Local tabs_ContentOffset = tabs_ContentFrame.Height * tabs_mul
        
      /* Gadget List */
      Local tabs_PageCount = helpers.CountEntries(tabs_PageNames)
      Local tabs_ActivePage = 0
      Local tabs_GadgetList = {}
      Local tabs_TabChilds = {}
      Local page_count = 0
      Local gad_count = 0
      Local count = 0
      Local xOffset = tabs_ContentFrame.Position.x + tabs_ContentOffset
      Local yOffset = tabs_ContentFrame.Position.y + tabs_ContentOffset

      /* Coordinate conversione & Gadget storing */
      If helpers.FieldIsNil(oString, "gadgetlist") = 0 Then tabs_GadgetList = oString.GadgetList
      For page_count = 0 To tabs_PageCount - 1
         gad_count = helpers.CountEntries(tabs_GadgetList[page_count])
         tabs_TabChilds[page_count] = {}
         For count = 0 To gad_count - 1
            Local childID = tabs_GadgetList[page_count][count]
            tabs_TabChilds[page_count][count] = { id = childID, Relative = 1, Visible = scui.IFO[childID].Visible }
            Local g = scui.Get(childID)
            Local gg = { Position = { x = g.Position.x, y = g.Position.y } }
            gg.Position.x = gg.Position.x + xOffset
            gg.Position.y = gg.Position.y + yOffset
            If page_count <> tabs_ActivePage
               scui.IFO[childID].PrevVisible = scui.IFO[childID].Visible
               scui.Set(childID, { Visible = #IFO_HIDDEN })
               If scui.IFO[childID].oInteractive = 1 Then DisableButton(childID)
            Else
               If helpers.FieldIsNil(gg, "prevvisible") = 0
                  scui.IFO[childID].Visible = scui.IFO[childID].PrevVisible
               EndIf
               If scui.IFO[childID].oInteractive = 1
                  EnableButton(childID)
               EndIf
            EndIf

            scui.Set(childID, gg)
         Next
      Next
      /* Valori di Default */
      Local tabs_Status      = #IFOSTATUS_NORMAL
      Local tabs_Interactive = 0
      Local tabs_Class       = #IFOCLASS_TABS
      Local tabs_Parent      = nil
      Local tabs_Type        = #IFOTYPE_BASIC     
      Local tabs_Mode        = #OPTMODE_ONLYONE

		/* Verifica se si tratta di un Child */
      If helpers.IsNil(IFOParent)=0
         tabs_Type   = #IFOTYPE_CHILD
         tabs_Parent = IFOParent
      EndIf

		/* Memorizzazione Oggetto */
      scui.IFO[ObjID] = { Visible        = tabs_Visible,
                          Enabled        = tabs_Enabled,
                          Status         = tabs_Status,
                          oType          = tabs_Type,
                          oClass         = tabs_Class,
                          oParent        = tabs_Parent,
                          oInteractive   = tabs_Interactive,
                          Owner        = Owner,
                          oName        = oName,
                          NSelBox        = tabs_NSelBox,
                          HSelBox        = tabs_HSelBox,
                          PSelBox        = tabs_PSelBox,
                          DSelBox        = tabs_DSelBox,
                          NSelText       = tabs_NSelText,
                          HSelText       = tabs_HSelText,
                          PSelText       = tabs_PSelText,
                          DSelText       = tabs_DSelText,
                          PageNames      = tabs_PageNames,
                          PageSelectorID = tabs_PageSelector,
                          PageCount      = tabs_PageCount,
                          ActivePage     = tabs_ActivePage,
                          TabChilds      = tabs_TabChilds,
                          oData          = { BigContainer   = tabs_BigContainer,
                                             SmallContainer = tabs_SmallContainer,
                                             ContentFrame   = tabs_ContentFrame }
                         }
      If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(ObjID)
		Return(ObjID)
    
   Case #IFOCLASS_IMAGE
		;+-----------------------------------------------------------[ IMAGE ]--+
		;| Interactive: YES                                                     |
		;| Supported Fields in Aspect table (oData)                             |
		;|  - Container      BevelStruct: Container of image                    |
      ;|  - HContainer     
		;|  - Visible        #IFO_VISIBLE or #IFO_HIDDEN                        |
		;|  - Enabled        #IFO_ENABLED or #IFO_DISABLED                      |
		;| Supported Fields in Params table (oString)                           |
      ;|  - Resize         Resize mode, can be: #IMAGERESIZE_NONE,            |
      ;|                   #IMAGERESIZE_SCALE, #IMAGERESIZE_ZOOM              |
      ;|  - Offset         A table with x and y offsets                       |
      ;|  - CenterImage    True|False
      ;|  - Image          Image filename                                     |
		;| Supported Fields in Actions table (oActions)                         |
		;|  - OnDown        When the user click the left mouse button           |
      ;|  - OnUp          When the user release the left mouse button         |
		;|  - OnIn
		;|  - OnOut
      ;+----------------------------------------------------------------------+
      If helpers.IsNil(ForceID) = 0
			/* RIGENERAZIONE: Auto-carica i parametri */
			Local Obj = scui.IFO[id]
			Local ObjData = Obj.oData
			Owner     = Obj.Owner
			oName     = Obj.oName
			oPosition = { x = ObjData.Container.Position.x, y = ObjData.Container.Position.y }
			oSize     = { x = ObjData.Container.Size.x,     y = ObjData.Container.Size.y }
			oData     = { Container       = scui.NewBevel(ObjData.Container, nil, 1),
                       HContainer      = scui.NewBevel(ObjData.HContainer, nil, 1),
							  Visible         = Obj.Visible,
							  Enabled         = Obj.Enabled }
			oString   = { Resize       = Obj.ResizeMode,
							  Offset       = { x = Obj.XOffset, y = Obj.YOffset },
                       CenterImage  = Obj.CenterImage,
							  Image        = Obj.ImageFile }
			oActions  = { }
			If helpers.FieldIsNil(Obj.Actions, "ondown" ) = 0 Then oActions.OnDown = Obj.Actions.OnDown
         If helpers.FieldIsNil(Obj.Actions, "onup" ) = 0 Then oActions.OnUp = Obj.Actions.OnUp
			If helpers.FieldIsNil(Obj.Actions, "onin" ) = 0 Then oActions.OnIn = Obj.Actions.OnIn
         If helpers.FieldIsNil(Obj.Actions, "onout" ) = 0 Then oActions.OnOut = Obj.Actions.OnOut
			
			/* Elimino il vecchio gadget e i relativi Childs */
			scui.RemoveObject(id)
         scui.QuickFind[oName] = id

	   EndIf

      Local ObjID = id

      If helpers.IsNil(oData   )=1 Then oData    = {}
      If helpers.IsNil(oActions)=1 Then oActions = {}
      If helpers.IsNil(oString )=1 Then oString  = {}
        
      /* Container */
      Local ima_Temp = { Position = { x = oPosition.x, y = oPosition.y },
                         Size     = { x = oSize.x,     y = oSize.y } }
      Local ima_Container  = scui.NewBevel(scui.theme.Image_NContainer, ima_Temp)
      Local ima_HContainer = scui.NewBevel(scui.theme.Image_HContainer, ima_Temp)
      If helpers.FieldIsNil(oData, "container")  = 0 Then ima_Container  = scui.NewBevel(ima_Container,  oData.Container, 1)
      If helpers.FieldIsNil(oData, "hcontainer") = 0 Then ima_HContainer = scui.NewBevel(ima_HContainer, oData.HContainer, 1)

      Local ima_Resize = #IMAGERESIZE_NONE
      If helpers.FieldIsNil(oString, "resize") = 0 Then ima_Resize = oString.Resize
      
      ; Se il file immagine non esiste creo un brush vuoto
      Local ima_BrushID = -1 ; helpers.GetBrushID()
      If oString.Image = ""
         ; PARAMETRIZZARE IL COLORE DI BG DEL BRUSH ***************************
         ima_BrushID = CreateBrush(Nil, 50, 50, RGB(180, 180, 180))
      Else
         ima_BrushID = LoadBrush(Nil, oString.Image)
      EndIf
      
      Local ima_CenterImage = False
      If helpers.FieldIsNil(oString, "centerimage") = 0 Then ima_CenterImage = oString.CenterImage
      
      Local ima_offset = IIF(ima_Container.Type = #BEVELTYPE_NONE, 0, IIF(ima_Container.Type = #BEVELTYPE_SIMPLE, 1, 2) ) * ima_Container.Height      
      Local rsize = ima_offset * 2 - 1
		
		Local FullSize = { x = GetAttribute(#BRUSH, ima_BrushID, #ATTRWIDTH), 
		                   y = GetAttribute(#BRUSH, ima_BrushID, #ATTRHEIGHT) }
      If ima_Resize = #IMAGERESIZE_SCALE
         ScaleBrush(ima_BrushID, oSize.x - rsize, oSize.y - rsize, True)
      ElseIf ima_Resize = #IMAGERESIZE_ZOOM
         Local BWidth = FullSize.x
         Local BHeight = FullSize.y
         Local ZoomX = BWidth / oSize.x
         Local ZoomY = BHeight / oSize.y
         Local Aspect = IIF(ZoomX > ZoomY, ZoomX, ZoomY)
         Local xSize = (BWidth / Aspect) - rsize
         Local ySize = (BHeight / Aspect) - rsize
         If xSize < 1 Then xSize = 1
         If ySize < 1 Then ySize = 1
         ScaleBrush(ima_BrushID, xSize, ySize, True)
      EndIf
      Local ima_Width  = GetAttribute(#BRUSH, ima_BrushID, #ATTRWIDTH)
      Local ima_Height = GetAttribute(#BRUSH, ima_BrushID, #ATTRHEIGHT)
      
      Local ima_osx = 0
      Local ima_osy = 0
      If helpers.FieldIsNil(oString, "offset") = 0
         If helpers.FieldIsNil(oString.Offset, "x") = 0 Then ima_osx = oString.Offset.x
         If helpers.FieldIsNil(oString.Offset, "y") = 0 Then ima_osy = oString.Offset.y
      EndIf
      
      /* Informazioni di base */
      Local ima_Visible     = #IFO_VISIBLE
      Local ima_Enabled     = #IFO_ENABLED
      Local ima_Type        = #IFOTYPE_BASIC
      Local ima_Class       = #IFOCLASS_IMAGE
      Local ima_Parent      = nil
      Local ima_Interactive = 1
      Local ima_Status      = #IFOSTATUS_NORMAL

      If helpers.FieldIsNil(oData, "visible")=0 Then ima_Visible = oData.Visible
      If helpers.FieldIsNil(oData, "enabled")=0 Then ima_Enabled = oData.Enabled
        
         ; Questo controllo e' un Child?
        If helpers.IsNil(IFOParent)=0
            ima_Type   = #IFOTYPE_CHILD
            ima_Parent = IFOParent
        EndIf

        ; QUA CI VA TUTTO IL BLOCCO DELLA MEMORIZZAZIONE DELLE INFORMAZIONI
        scui.IFO[ObjID] = { Visible        = ima_Visible,
                            Enabled        = ima_Enabled,
                            Status         = ima_Status,
                            oType          = ima_Type,
                            oClass         = ima_Class,
                            oParent        = ima_Parent,
                            oInteractive   = ima_Interactive,
                            Owner          = Owner,
                            oName          = oName,
                            ResizeMode     = ima_Resize,
                            ImageFile      = oString.Image,
                            ImageBrush     = ima_BrushID,
                            ImageX         = ima_offset,
                            ImageY         = ima_offset,
                            XOffset        = ima_osx,
                            YOffset        = ima_osy,
                            ImageWidth     = ima_Width,
                            ImageHeight    = ima_Height,
									 FullSize       = { x = FullSize.x, y = FullSize.y },
                            CenterImage    = ima_CenterImage,
                            oData          = { Container   = ima_Container,
                                               HContainer  = ima_HContainer },
                            Actions        = {}
                            }

        If helpers.FieldIsNil(oActions, "ondown" ) = 0 Then scui.IFO[ObjID].Actions.OnDown = oActions.OnDown
        If helpers.FieldIsNil(oActions, "onup"   ) = 0 Then scui.IFO[ObjID].Actions.OnUp = oActions.OnUp
        If helpers.FieldIsNil(oActions, "onin"   ) = 0 Then scui.IFO[ObjID].Actions.OnIn = oActions.OnIn
        If helpers.FieldIsNil(oActions, "onout"  ) = 0 Then scui.IFO[ObjID].Actions.OnOut = oActions.OnOut

        MakeButton(ObjID, #SIMPLEBUTTON, 
                       ima_Container.Position.x, ima_Container.Position.y,
                       ima_Container.Size.x,ima_Container.Size.y, 
                       { OnMouseOver = scui.HandleObject,
                         OnMouseOut  = scui.HandleObject,
                         OnMouseDown = scui.HandleObject,
                         OnMouseUp   = scui.HandleObject } )   
			/* Disattiva la zona se non visibile o disabilitato */
			If(ima_Enabled = #IFO_DISABLED Or ima_Enabled = #IFO_HIDDEN) Then DisableButton(id)
                         
        ; ROUTINE DI RENDERING
        If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(ObjID)
			Return(ObjID)


   Case #IFOCLASS_VIRTUALAREA

	   Local ObjID = id
	   If helpers.IsNil(oData   )=1 Then oData    = {}
	   If helpers.IsNil(oActions)=1 Then oActions = {}
	   If helpers.IsNil(oString )=1 Then oString  = {}
	  
	   ; Container
	   Local vir_Temp = { Position = { x = oPosition.x, y = oPosition.y },
	                      Size     = { x = oSize.x,     y = oSize.y } }
	   Local vir_Container = scui.NewBevel(scui.theme.VArea_NContainer, vir_Temp)
	   If helpers.FieldIsNil(oData, "container") = 0 Then vir_Container = scui.NewBevel(vir_Container, oData.Container, 1)

	   Local vir_mul = IIF(vir_Container.Type = #BEVELTYPE_SUNKEN , 2, IIF(vir_Container.Type <> #BEVELTYPE_NONE , 1, 0))
	   Local vir_Area = { xStart = oPosition.x + vir_mul * vir_Container.Height, yStart = oPosition.y + vir_mul * vir_Container.Height,
	                      xEnd = oPosition.x + oSize.x - vir_mul * 2, yEnd = oPosition.y + oSize.y - vir_mul * 2 }

	   Local vir_Brush = -1 ; helpers.GetBrushID()
	   vir_Brush = CreateBrush(Nil, oString.VirtualSize.x, oString.VirtualSize.y, #WHITE)
		Local vir_Offset = { x = 0, y = 0 }

		; Assegna il padre ai figli 
		Local ChildCount = helpers.CountEntries(oString.GadList)
		Local i = 0
      Local Childs = {}
		For i = 0 To ChildCount - 1
			Local ChildID = oString.GadList[i]
         Childs[i+1] = ChildID
			scui.IFO[ChildID].oParent = ObjID
		Next
		
		Local vir_Visible     = #IFO_VISIBLE
		Local vir_Enabled     = #IFO_ENABLED
		Local vir_Type        = #IFOTYPE_BASIC
		Local vir_Class       = #IFOCLASS_VIRTUALAREA
		Local vir_Parent      = nil
		Local vir_Interactive = 0
		Local vir_Status      = #IFOSTATUS_NORMAL

		If helpers.FieldIsNil(oData, "visible") = 0 Then vir_Visible = oData.Visible
		If helpers.FieldIsNil(oData, "enabled") = 0 Then vir_Enabled = oData.Enabled

		/* Verifica se si tratta di un child */
		If helpers.IsNil(IFOParent)=0
			vir_Type   = #IFOTYPE_CHILD
			vir_Parent = IFOParent
		EndIf

		scui.IFO[ObjID] = { Visible    = vir_Visible,
							 Enabled        = vir_Enabled,
							 Status         = vir_Status,
							 oType          = vir_Type,
							 oClass         = vir_Class,
							 oParent        = vir_Parent,
							 oInteractive   = vir_Interactive,
							 Owner          = Owner,
							 oName          = oName,
							 Childs         = Childs,
							 ChildCount     = ChildCount,
							 Offset         = vir_Offset,
							 ViewPort       = vir_Area,
							 VirtualSize    = { x = oString.VirtualSize.x, y = oString.VirtualSize.y },
							 Brush          = vir_Brush,
							 oData          = { Container   = vir_Container },
							 Actions        = { }
							 }

		/* Dal momento che i figli hanno già il padre settato il primo tracciamento */
		/* andra' a finire direttamente nel brush predisposto                       */
		Local ccnt = ChildCount - 1
		Local i = 0
		For i = 0 To ccnt
			scui.RenderObject(oString.GadList[i])
		Next

		If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(ObjID)
		Return(ObjID)
      
      
      
   Case #IFOCLASS_MENU
   ; --------------------------------------------------------------------------
	   Local ObjID = id
	   If helpers.IsNil(oData   )=1 Then oData    = {}
	   If helpers.IsNil(oActions)=1 Then oActions = {}
	   If helpers.IsNil(oString )=1 Then oString  = {}

      ;Local oPosition = { x = 100, y = 100 }
      ;Local oSize     = { x = 400, y = 14 }
      ; Ogni Item ha la seguente struttura 
      ; - Item Name
      ; - Item Type : Default = 1 - Item, 2 - Option, 3 - Flag, 4 - Submenu 
      Local Menu = oString.Menu ; { { "File", { {"New"}, {"Open"}, {"Save"}, {"Close"}, {"Exit"} } }, { "Modify" }, { "Search" }, { "Options" }, { "Tools" }, { "?" } }
      Local Mode = oString.Mode ; 1 ; 1 = Hori, 2 = Verti 
      Local Free = oString.Free ; True / False
      
      Local BtnCount = helpers.CountEntries(Menu)
      Local xSize = oSize.x
      Local ySize = oSize.y
      
      xPos = oPosition.x
      yPos = oPosition.y
      
      Local tmp_Bevel = scui.NewBevel(scui.theme.Menu_NBevel, {})
      Local tmp_HBevel = scui.NewBevel(scui.theme.Menu_HBevel, {})
      Local tmp_PBevel = scui.NewBevel(scui.theme.Menu_PBevel, {})
      
      Local BtnList = {}
      For Local c = 1 To BtnCount
         ;DebugPrint("Creating Menu button:", c, xPos, yPos, xSize, ySize)
         ; Qua ci metto una condizione per dare un'aspetto differente ai submenu 
         BtnList[c] = scui.NewObject(#IFOCLASS_BUTTON, oName .. ".Item." .. c,
                                       { x = xPos, y = yPos },
                                       { x = xSize, y = ySize },
                                       { Text  = cyc_Text,
                                         HText = cyc_HText,
                                         PText = cyc_PText,
                                         DText = cyc_DText,
                                         Bevel  = tmp_Bevel,
                                         HBevel = tmp_HBevel,
                                         PBevel = tmp_PBevel,
                                         DBevel = cyc_DCycle },
                                       { Values = { Menu[c-1][0] }, Lines = 1 },
                                       nil,
                                       ObjID,
                                       nil,
                                       1,
                                       Owner)
         If Mode = 1
            xPos = xPos + xSize + 1
         Else
            yPos = yPos + ySize + 1
         EndIf
      Next

		Local tmp_Visible     = #IFO_VISIBLE
		Local tmp_Enabled     = #IFO_ENABLED
		Local tmp_Type        = #IFOTYPE_BASIC
		Local tmp_Parent      = nil
		Local tmp_Interactive = 0
		Local tmp_Status      = #IFOSTATUS_NORMAL

      ;DebugPrint("Menu OBJID:", ObjID)
      scui.IFO[ObjID] = { Visible        = tmp_Visible,
							     Enabled        = tmp_Enabled,
                          Position       = oPosition,
                          Size           = oSize,
							     Status         = tmp_Status,
							     oType          = tmp_Type,
							     oClass         = #IFOCLASS_MENU,
							     oParent        = tmp_Parent,
							     oInteractive   = 0,
							     Owner          = Owner,
							     oName          = oName,
							     Childs         = BtnList,
							     ChildCount     = helpers.CountEntries(BtnList),
                          Menu           = Menu,
                          Free           = Free,
  							     oData          = { },
							     ;Actions        = { }
							 }
                      
		If helpers.IsNil(NoDraw) = 1 Then scui.RenderObject(ObjID)
      Return(ObjID)
		
    Default
        NPrint("IFOClass not supported!", oClass)
        Return
    EndSwitch
    
    
    
EndFunction
Function scui.RemoveObject(id) ;------------------------------------------------
;==============================
   ; docs updated 27.12.2008
   
   ; VA TOLTO ANCHE DAL LAYOUT
   
   ; Elimina il gagdet specificato
   If GetType(id) = #STRING Then id = scui.GetIFOID(id)
   If id < 0 Then Return
 
   ; Se il gadget e' stato gia' eliminato lo salta
   If Not(helpers.FieldIsNil(scui.IFO[id], "deleted")) Or scui.IFO[id].oName = "*DELETED*"
      Return()
   EndIf

   If helpers.FieldIsNil(scui.IFO[id], "childcount") = 0
      For c=1 To scui.IFO[id].ChildCount
         scui.RemoveObject(scui.IFO[id].Childs[c])
      Next
      If scui.IFO[id].oClass = #IFOCLASS_LISTVIEW
         ; controlla se esiste lo scroller
         If helpers.FieldIsNil(scui.IFO[id], "scrollerid") = 0 Then scui.RemoveObject(scui.IFO[id].ScrollerID)
      EndIf
      If scui.IFO[id].oClass = #IFOCLASS_TABS
         ; controlla se esiste lo pageselctor
         If helpers.FieldIsNil(scui.IFO[id], "pageselectorid") = 0 Then scui.RemoveObject(scui.IFO[id].PageSelectorID)
      EndIf
   Else
      If scui.IFO[id].oClass = #IFOCLASS_LISTVIEW
         ; controlla se esiste lo scroller
         If helpers.FieldIsNil(scui.IFO[id], "scrollerid") = 0 Then scui.RemoveObject(scui.IFO[id].ScrollerID)
      EndIf
      If scui.IFO[id].oClass = #IFOCLASS_TABS
         ; controlla se esiste lo pageselctor
         If helpers.FieldIsNil(scui.IFO[id], "pageselectorid") = 0 Then scui.RemoveObject(scui.IFO[id].PageSelectorID)
      EndIf
      If scui.IFO[id].oClass = #IFOCLASS_IMAGE
         FreeBrush(scui.IFO[id].ImageBrush)
      EndIf
   EndIf
   
   If scui.IFO[id].oInteractive = 1
      If scui.IFO[id].Enabled
         DeleteButton(id)
      EndIf
   EndIf

   scui.QuickFind[scui.IFO[id].oName] = Nil   
   
   scui.IFO[id].Deleted = 1
   ;scui.IFO[id].oName = "*DELETED*"
   scui.IFO[id].Owner = "*ORPHAN*"
   
EndFunction
Function scui.ObjectExists(id) ;------------------------------------------------
;==============================
   ; docs updated 27.12.2008

   ; Restituisce True se il gadget esiste altrimenti restituisce False

   If GetType(id) = #STRING Then id = scui.GetIFOID(id)
   If id < 0 Then Return(False)
    
   If helpers.IsNil(scui.IFO[id])=1 Then Return(False)
   If helpers.FieldIsNil(scui.IFO[id], "deleted")=0 Then Return(False)
   Return(True)
EndFunction
Function scui.IFO_Enable(id, RenderFlag) ;------------------------| PRIVATE |---
;========================================
   ; docs updated 27.12.2008

   ; Enable the given IFO

   If GetType(id) = #STRING Then id = scui.GetIFOID(id)
   If id < 0 Then Return
    
   If helpers.IsNil(RenderFlag)=1 Then RenderFlag = 1
    
   ; Verifica se e' stato cancellato
   If helpers.FieldIsNil(scui.IFO[id], "deleted")=0
      If scui.IFO[id].Deleted = 1
         ; E' un oggetto cancellato non faccio nulla
         Return
      EndIf
   EndIf
    
   ; Verifico se si tratta di un PARENT controllando se ha figli
   If helpers.FieldIsNil(scui.IFO[id], "childs")=0
      ; E' un <Parent> 
      scui.IFO[id].Enabled = #IFO_Enabled
      Local k = 0
      ; Abilito tutti i suoi figli
      For k = 1 To scui.IFO[id].ChildCount
         scui.IFO_Enable(scui.IFO[id].Childs[k], RenderFlag)
      Next
      ; Abilito il pulsante
      If scui.IFO[id].oInteractive = 1
         EnableButton(id)       
      EndIf
   Else
      ; E' un gadget senza figli
      If scui.IFO[id].oInteractive = 1
         EnableButton(id)       
      EndIf
      scui.IFO[id].Enabled = #IFO_ENABLED
   EndIf

   If RenderFlag = 1 Then scui.RenderObject(id)
EndFunction
Function scui.IFO_Disable(id, RenderFlag) ;-----------------------| PRIVATE |---
;=========================================
   ; docs updated 27.12.2008

   ; Disable the given IFO

   If GetType(id) = #STRING Then id = scui.GetIFOID(id)
   If id < 0 Then Return
    
   If helpers.IsNil(RenderFlag)=1 Then RenderFlag = 1
    
   ; Verifica se e' stato cancellato
   If helpers.FieldIsNil(scui.IFO[id], "deleted")=0
      If scui.IFO[id].Deleted = 1
         ; E' un oggetto cancellato non faccio nulla
         Return
      EndIf
   EndIf
    
   ; Verifico se si tratta di un PARENT controllando se ha figli
   If helpers.FieldIsNil(scui.IFO[id], "childs")=0
      ; E' un <Parent> 
      scui.IFO[id].Enabled = #IFO_DISABLED
      Local k = 0
      ; Abilito tutti i suoi figli
      For k = 1 To scui.IFO[id].ChildCount
         scui.IFO_Disable(scui.IFO[id].Childs[k], RenderFlag)
      Next
      ; Abilito il pulsante
      If scui.IFO[id].oInteractive = 1
         DisableButton(id)       
      EndIf
   Else
      ; E' un gadget senza figli
      If scui.IFO[id].oInteractive = 1
         DisableButton(id)       
      EndIf
      scui.IFO[id].Enabled = #IFO_DISABLED
   EndIf

   If RenderFlag = 1 Then scui.RenderObject(id)
EndFunction
Function scui.SnapshotEnabledStatus() ;---------------------------| PRIVATE |---
;=====================================
   ; docs updated 27.12.2008

   ; Save the Enabled flag of all defined IFOs

   Local k = 0
   For k = 1 To scui.IFO.IDCounter
      scui.IFO[k].Snapshot_Enabled = scui.IFO[k].Enabled
   Next
EndFunction
Function scui.RestoreEnabledStatus() ;----------------------------| PRIVATE |---
;====================================
   ; docs updated 27.12.2008

   ; Restore the Enabled flag of all defined IFOs previously saved with
   ; <scui.SnapshotEnabledStatus()>

   Local k = 0
   For k = 1 To scui.IFO.IDCounter
      If helpers.FieldIsNil(scui.IFO[k], "snapshot_enabled")=0
         scui.IFO[k].Enabled = scui.IFO[k].Snapshot_Enabled
      EndIf
   Next
   ;scui.RedrawObjects(1, scui.ActiveWindow)
EndFunction
Function scui.IFO_EnableAll(RenderFlag, owner) ;------------------| PRIVATE |---
;==============================================
   ; docs updated 28.12.2008

   ; Enable all gadgets or only the owner's ones in one go

   If helpers.IsNil(owner) = 0
      For k = 1 To scui.IFO.IDCounter
         If scui.IFO[k].Owner = owner Then scui.IFO_Enable(k, RenderFlag)
      Next
   Else
      For k = 1 To scui.IFO.IDCounter
         scui.IFO_Enable(k, RenderFlag)
      Next
   EndIf
EndFunction
Function scui.IFO_DisableAll(RenderFlag, owner) ;-----------------| PRIVATE |---
;===============================================
   ; docs updated 28.12.2008

   ; Disable all gadgets or only the owner's ones in one go

   If helpers.IsNil(owner) = 0
      For k = 1 To scui.IFO.IDCounter
         If scui.IFO[k].Owner = owner Then scui.IFO_Disable(k, RenderFlag)
      Next
   Else
      For k = 1 To scui.IFO.IDCounter
         scui.IFO_Disable(k, RenderFlag)
      Next
   EndIf
EndFunction
Function scui.NewText( base, changes, ignorepos ) ;---------------| PRIVATE |---
;=================================================
   ; docs updated 28.12.2008

   ; Create a copy of <base> and changes if <changes> is not nil
    
   If helpers.IsNil(changes) Then Return(helpers.CloneTable(base))
   ;If helpers.IsNil(changes) Then changes = {}
    
   newText = {}
   newText.Content = {}
   newText.Content.Values = {}
   If helpers.FieldIsNil(changes, "content") = 0
      If helpers.FieldIsNil(changes.Content, "values"        )=0 Then newText.Content.Values         = changes.Content.Values         Else newText.Content.Values         = base.Content.Values
      If helpers.FieldIsNil(changes.Content, "lines"         )=0 Then newText.Content.Lines          = changes.Content.Lines          Else newText.Content.Lines          = helpers.CountEntries(changes.Content.Values)
      If helpers.FieldIsNil(changes.Content, "verticaloffset")=0 Then newText.Content.VerticalOffset = changes.Content.VerticalOffset Else newText.Content.VerticalOffset = base.Content.VerticalOffset        
   Else
      If helpers.FieldIsNil(base, "content") = 0
         newText.Content.Values         = base.Content.Values
         newText.Content.Lines          = base.Content.Lines
         newText.Content.VerticalOffset = base.Content.VerticalOffset
      EndIf
   EndIf
   If helpers.FieldIsNil(changes, "fontname")=0 Then newText.FontName = changes.FontName Else newText.FontName = base.FontName
   If helpers.FieldIsNil(changes, "fontsize")=0 Then newText.FontSize = changes.FontSize Else newText.FontSize = base.FontSize
   newText.Color = {}
   If helpers.FieldIsNil(changes, "color")=0
      If helpers.FieldIsNil(changes.Color, "r")=0 Then newText.Color.r = changes.Color.r Else newText.Color.r = base.Color.r
      If helpers.FieldIsNil(changes.Color, "g")=0 Then newText.Color.g = changes.Color.g Else newText.Color.g = base.Color.g
      If helpers.FieldIsNil(changes.Color, "b")=0 Then newText.Color.b = changes.Color.b Else newText.Color.b = base.Color.b
   Else
      newText.Color.r = base.Color.r
      newText.Color.g = base.Color.g
      newText.Color.b = base.Color.b
   EndIf
   If helpers.FieldIsNil(changes, "style")=0 Then newText.Style = changes.Style Else newText.Style = base.Style
   newText.Shadow = {}
   newText.Shadow.Color = {}
   If helpers.FieldIsNil(changes, "shadow")=0
      If helpers.FieldIsNil(changes.Shadow, "type")=0 Then newText.Shadow.Type = changes.Shadow.Type Else newText.Shadow.Type = base.Shadow.Type
      If helpers.FieldIsNil(changes.Shadow, "distance")=0 Then newText.Shadow.Distance = changes.Shadow.Distance Else newText.Shadow.Distance = base.Shadow.Distance
      If helpers.FieldIsNil(changes.Shadow, "color")=0
         If helpers.FieldIsNil(changes.Shadow.Color, "r")=0 Then newText.Shadow.Color.r = changes.Shadow.Color.r Else newText.Shadow.Color.r = base.Shadow.Color.r
         If helpers.FieldIsNil(changes.Shadow.Color, "g")=0 Then newText.Shadow.Color.g = changes.Shadow.Color.g Else newText.Shadow.Color.g = base.Shadow.Color.g
         If helpers.FieldIsNil(changes.Shadow.Color, "b")=0 Then newText.Shadow.Color.b = changes.Shadow.Color.b Else newText.Shadow.Color.b = base.Shadow.Color.b        
         If helpers.FieldIsNil(changes.Shadow.Color, "a")=0 Then newText.Shadow.Color.a = changes.Shadow.Color.a Else newText.Shadow.Color.a = base.Shadow.Color.a        Else
         newText.Shadow.Color.r  = base.Shadow.Color.r
         newText.Shadow.Color.g  = base.Shadow.Color.g
         newText.Shadow.Color.b  = base.Shadow.Color.b
         newText.Shadow.Color.a  = base.Shadow.Color.a
      EndIf
   Else
      newText.Shadow.Type     = base.Shadow.Type
      newText.Shadow.Distance = base.Shadow.Distance
      newText.Shadow.Color.r  = base.Shadow.Color.r
      newText.Shadow.Color.g  = base.Shadow.Color.g
      newText.Shadow.Color.b  = base.Shadow.Color.b
      newText.Shadow.Color.a  = base.Shadow.Color.a
   EndIf
   newText.Edge = {}
   newText.Edge.Color = {}
   If helpers.FieldIsNil(changes, "edge")=0
      If helpers.FieldIsNil(changes.Edge, "type")=0 Then newText.Edge.Type = changes.Edge.Type Else newText.Edge.Type = base.Edge.Type
      If helpers.FieldIsNil(changes.Edge, "size")=0 Then newText.Edge.Size = changes.Edge.Size Else newText.Edge.Size = base.Edge.Size
      If helpers.FieldIsNil(changes.Edge, "style")=0 Then newText.Edge.Style = changes.Edge.Style Else newText.Edge.Style = base.Edge.Style
      If helpers.FieldIsNil(changes.Edge, "color")=0
         If helpers.FieldIsNil(changes.Edge.Color, "r")=0 Then newText.Edge.Color.r = changes.Edge.Color.r Else newText.Edge.Color.r = base.Edge.Color.r
         If helpers.FieldIsNil(changes.Edge.Color, "g")=0 Then newText.Edge.Color.g = changes.Edge.Color.g Else newText.Edge.Color.g = base.Edge.Color.g
         If helpers.FieldIsNil(changes.Edge.Color, "b")=0 Then newText.Edge.Color.b = changes.Edge.Color.b Else newText.Edge.Color.b = base.Edge.Color.b        
         If helpers.FieldIsNil(changes.Edge.Color, "a")=0 Then newText.Edge.Color.a = changes.Edge.Color.a Else newText.Edge.Color.a = base.Edge.Color.a
         If helpers.FieldIsNil(changes.Edge.Color, "contrast")=0 Then newText.Edge.Color.Contrast = changes.Edge.Color.Contrast Else newText.Edge.Color.Contrast = base.Edge.Color.Contrast
      Else
         newText.Edge.Color.r  = base.Edge.Color.r
         newText.Edge.Color.g  = base.Edge.Color.g
         newText.Edge.Color.b  = base.Edge.Color.b
         newText.Edge.Color.a  = base.Edge.Color.a
         newText.Edge.Color.Contrast = base.Edge.Color.Contrast
      EndIf
   Else
      newText.Edge.Type     = base.Edge.Type
      newText.Edge.Size     = base.Edge.Size
      newText.Edge.Style    = base.Edge.Style        
      newText.Edge.Color.r  = base.Edge.Color.r
      newText.Edge.Color.g  = base.Edge.Color.g
      newText.Edge.Color.b  = base.Edge.Color.b
      newText.Edge.Color.a  = base.Edge.Color.a
      newText.Edge.Color.Contrast = base.Edge.Color.Contrast
   EndIf
   If helpers.FieldIsNil(changes, "multicol")=0 Then newText.MultiCol = changes.MultiCol Else newText.MultiCol = base.MultiCol
   If helpers.FieldIsNil(changes, "colsizes")=0 Then newText.ColSizes = changes.ColSizes Else newText.ColSizes = base.ColSizes
   If helpers.FieldIsNil(changes, "colbreak")=0 Then newText.ColBreak = changes.ColBreak Else newText.ColBreak = base.ColBreak
   If helpers.FieldIsNil(changes, "alignment")=0 Then newText.Alignment = changes.Alignment Else newText.Alignment = base.Alignment
   newText.Margins = {}
   If helpers.FieldIsNil(changes, "margins")=0
      If helpers.FieldIsNil(changes.Margins, "x")=0 Then newText.Margins.x = changes.Margins.x Else newText.Margins.x = base.Margins.x
      If helpers.FieldIsNil(changes.Margins, "y")=0 Then newText.Margins.y = changes.Margins.y Else newText.Margins.y = base.Margins.y
   Else
      newText.Margins.x = base.Margins.x
      newText.Margins.y = base.Margins.y
   EndIf
   If helpers.IsNil(ignorepos) = 0
      ; Elimina eventuali dati di dimensioni e posizione
      ;changes.Area = nil
   EndIf    
   newText.Area = {}
   If helpers.FieldIsNil(changes, "area")=0 And helpers.IsNil(ignorepos) = 1
      If helpers.FieldIsNil(changes.Area, "xstart")=0 Then newText.Area.xStart = changes.Area.xStart Else newText.Area.xStart = base.Area.xStart
      If helpers.FieldIsNil(changes.Area, "ystart")=0 Then newText.Area.yStart = changes.Area.yStart Else newText.Area.yStart = base.Area.yStart
      If helpers.FieldIsNil(changes.Area, "xend"  )=0 Then newText.Area.xEnd   = changes.Area.xEnd   Else newText.Area.xEnd   = base.Area.xEnd
      If helpers.FieldIsNil(changes.Area, "yend"  )=0 Then newText.Area.yEnd   = changes.Area.yEnd   Else newText.Area.yEnd   = base.Area.yEnd
   Else
      If helpers.FieldIsNil(base, "area") = 0
         newText.Area.xStart = base.Area.xStart
         newText.Area.yStart = base.Area.yStart
         newText.Area.xEnd   = base.Area.xEnd
         newText.Area.yEnd   = base.Area.yEnd
      EndIf
   EndIf

   Return(newText)
EndFunction
Function scui.NewBevel( base, changes, ignorepos ) ;--------------| PRIVATE |---
   ; docs updated 28.12.2008

   ; Create a copy of <base> and changes if <changes> is not nil

   If helpers.IsNil(changes) Then Return(helpers.CloneTable(base))
   ;If helpers.IsNil(changes) Then changes = {}
    
   nBevel = {}
   If helpers.FieldIsNil( changes, "type"   )=0 Then nBevel.Type   = changes.Type   Else nBevel.Type   = base.Type
   If helpers.FieldIsNil( changes, "aspect" )=0 Then nBevel.Aspect = changes.Aspect Else nBevel.Aspect = base.Aspect
   nBevel.Outline = {}
   
   If helpers.FieldIsNil( changes, "vector" )=0
      nBevel.Vector = changes.Vector
   Else
      If helpers.FieldIsNil(base, "vector")=0 Then nBevel.Vector = base.Vector
   EndIf
   
   If helpers.FieldIsNil( changes, "outline" )=0
      If helpers.FieldIsNil( changes.Outline, "type"   )=0 Then nBevel.Outline.Type   = changes.Outline.Type   Else nBevel.Outline.Type   = base.Outline.Type
      If helpers.FieldIsNil( changes.Outline, "aspect" )=0 Then nBevel.Outline.Aspect = changes.Outline.Aspect Else nBevel.Outline.Aspect = base.Outline.Aspect
      If helpers.FieldIsNil( changes.Outline, "size1"  )=0 Then nBevel.Outline.Size1  = changes.Outline.Size1  Else nBevel.Outline.Size1  = base.Outline.Size1
      If helpers.FieldIsNil( changes.Outline, "size2"  )=0 Then nBevel.Outline.Size2  = changes.Outline.Size2  Else nBevel.Outline.Size2  = base.Outline.Size2
   Else
      nBevel.Outline.Type   = base.Outline.Type
      nBevel.Outline.Aspect = base.Outline.Aspect
      nBevel.Outline.Size1  = base.Outline.Size1
      nBevel.Outline.Size2  = base.Outline.Size2
   EndIf
    
   If helpers.FieldIsNil( changes, "fillmode"      )=0 Then nBevel.FillMode      = changes.FillMode      Else nBevel.FillMode      = base.FillMode
   If helpers.FieldIsNil( changes, "smooth"        )=0 Then nBevel.Smooth        = changes.Smooth        Else nBevel.Smooth        = base.Smooth    
   If helpers.FieldIsNil( changes, "gradientangle" )=0 Then nBevel.GradientAngle = changes.GradientAngle Else nBevel.GradientAngle = base.GradientAngle
   If helpers.FieldIsNil( changes, "height"        )=0 Then nBevel.Height        = changes.Height        Else nBevel.Height        = base.Height
    
   If helpers.IsNil(ignorepos) = 0
      ; Elimina eventuali dati di dimensioni e posizione
      ;changes.Position = nil
      ;changes.Size     = nil
   EndIf
    
   nBevel.Position = {}
   If helpers.FieldIsNil( changes, "position" )=0 And helpers.IsNil(ignorepos) = 1
      If helpers.FieldIsNil( changes.Position, "x" )=0 Then nBevel.Position.x = changes.Position.x Else nBevel.Position.x = base.Position.x
      If helpers.FieldIsNil( changes.Position, "y" )=0 Then nBevel.Position.y = changes.Position.y Else nBevel.Position.y = base.Position.y
   Else
      If helpers.FieldIsNil(base, "position") = 0
         If helpers.FieldIsNil( base.Position, "x" ) = 0 Then nBevel.Position.x = base.Position.x
         If helpers.FieldIsNil( base.Position, "y" ) = 0 Then nBevel.Position.y = base.Position.y
      Else
         nBevel.Position.x = base.Position.x
         nBevel.Position.y = base.Position.y
      EndIf
   EndIf

   nBevel.Size = {}
   If helpers.FieldIsNil( changes, "size" )= 0 And helpers.IsNil(ignorepos) = 1
      If helpers.FieldIsNil( changes.Size, "x" )=0 Then nBevel.Size.x = changes.Size.x Else nBevel.Size.x = base.Size.x
      If helpers.FieldIsNil( changes.Size, "y" )=0 Then nBevel.Size.y = changes.Size.y Else nBevel.Size.y = base.Size.y
   Else
      If helpers.FieldIsNil(base, "size") = 0
         If helpers.FieldIsNil( base.Size, "x" ) = 0 Then nBevel.Size.x = base.Size.x
         If helpers.FieldIsNil( base.Size, "y" ) = 0 Then nBevel.Size.y = base.Size.y
      EndIf
   EndIf
   nBevel.Colors = {}
   nBevel.Colors.Edges = {}
   nBevel.Colors.Fill1 = {}
   nBevel.Colors.Fill2 = {}
   nBevel.Colors.Outline = {}
   If helpers.FieldIsNil( changes, "colors" )=0
      nBevel.Colors.Edges = {}
      If helpers.FieldIsNil( changes.Colors, "edges" )=0
         If helpers.FieldIsNil( changes.Colors.Edges, "r" )=0 Then nBevel.Colors.Edges.r = changes.Colors.Edges.r Else nBevel.Colors.Edges.r = base.Colors.Edges.r 
         If helpers.FieldIsNil( changes.Colors.Edges, "g" )=0 Then nBevel.Colors.Edges.g = changes.Colors.Edges.g Else nBevel.Colors.Edges.g = base.Colors.Edges.g
         If helpers.FieldIsNil( changes.Colors.Edges, "b" )=0 Then nBevel.Colors.Edges.b = changes.Colors.Edges.b Else nBevel.Colors.Edges.b = base.Colors.Edges.b
         If helpers.FieldIsNil( changes.Colors.Edges, "contrast")=0 Then nBevel.Colors.Edges.Contrast = changes.Colors.Edges.Contrast Else nBevel.Colors.Edges.Contrast = base.Colors.Edges.Contrast
      Else
         nBevel.Colors.Edges.r = base.Colors.Edges.r
         nBevel.Colors.Edges.g = base.Colors.Edges.g
         nBevel.Colors.Edges.b = base.Colors.Edges.b
         nBevel.Colors.Edges.Contrast = base.Colors.Edges.Contrast            
      EndIf

      If helpers.FieldIsNil( changes.Colors, "fill1" )=0
         If helpers.FieldIsNil( changes.Colors.Fill1, "r" )=0 Then nBevel.Colors.Fill1.r = changes.Colors.Fill1.r Else nBevel.Colors.Fill1.r = base.Colors.Fill1.r
         If helpers.FieldIsNil( changes.Colors.Fill1, "g" )=0 Then nBevel.Colors.Fill1.g = changes.Colors.Fill1.g Else nBevel.Colors.Fill1.g = base.Colors.Fill1.g
         If helpers.FieldIsNil( changes.Colors.Fill1, "b" )=0 Then nBevel.Colors.Fill1.b = changes.Colors.Fill1.b Else nBevel.Colors.Fill1.b = base.Colors.Fill1.b
         If helpers.FieldIsNil( changes.Colors.Fill1, "contrast")=0 Then nBevel.Colors.Fill1.Contrast = changes.Colors.Fill1.Contrast Else  nBevel.Colors.Fill1.Contrast = base.Colors.Fill1.Contrast
      Else
         nBevel.Colors.Fill1.r = base.Colors.Fill1.r
         nBevel.Colors.Fill1.g = base.Colors.Fill1.g
         nBevel.Colors.Fill1.b = base.Colors.Fill1.b
         nBevel.Colors.Fill1.Contrast = base.Colors.Fill1.Contrast        
      EndIf

      If helpers.FieldIsNil( changes.Colors, "fill2" )=0
        If helpers.FieldIsNil( changes.Colors.Fill2, "r" )=0 Then nBevel.Colors.Fill2.r = changes.Colors.Fill2.r Else nBevel.Colors.Fill2.r = base.Colors.Fill2.r
        If helpers.FieldIsNil( changes.Colors.Fill2, "g" )=0 Then nBevel.Colors.Fill2.g = changes.Colors.Fill2.g Else nBevel.Colors.Fill2.g = base.Colors.Fill2.g
        If helpers.FieldIsNil( changes.Colors.Fill2, "b" )=0 Then nBevel.Colors.Fill2.b = changes.Colors.Fill2.b Else nBevel.Colors.Fill2.b = base.Colors.Fill2.b
        If helpers.FieldIsNil( changes.Colors.Fill2, "contrast")=0 Then nBevel.Colors.Fill2.Contrast = changes.Colors.Fill2.Contrast Else nBevel.Colors.Fill2.Contrast = base.Colors.Fill2.Contrast
      Else
        nBevel.Colors.Fill2.r = base.Colors.Fill2.r
        nBevel.Colors.Fill2.g = base.Colors.Fill2.g
        nBevel.Colors.Fill2.b = base.Colors.Fill2.b
        nBevel.Colors.Fill2.Contrast = base.Colors.Fill2.Contrast        
      EndIf

      If helpers.FieldIsNil( changes.Colors, "outline" )=0
        If helpers.FieldIsNil( changes.Colors.Outline, "r" )=0 Then nBevel.Colors.Outline.r = changes.Colors.Outline.r Else nBevel.Colors.Outline.r = base.Colors.Outline.r
        If helpers.FieldIsNil( changes.Colors.Outline, "g" )=0 Then nBevel.Colors.Outline.g = changes.Colors.Outline.g Else nBevel.Colors.Outline.g = base.Colors.Outline.g
        If helpers.FieldIsNil( changes.Colors.Outline, "b" )=0 Then nBevel.Colors.Outline.b = changes.Colors.Outline.b Else nBevel.Colors.Outline.b = base.Colors.Outline.b
        If helpers.FieldIsNil( changes.Colors.Outline, "contrast")=0 Then nBevel.Colors.Outline.Contrast = changes.Colors.Outline.Contrast Else nBevel.Colors.Outline.Contrast = base.Colors.Outline.Contrast
      Else
        nBevel.Colors.Outline.r = base.Colors.Outline.r
        nBevel.Colors.Outline.g = base.Colors.Outline.g
        nBevel.Colors.Outline.b = base.Colors.Outline.b
        nBevel.Colors.Outline.Contrast = base.Colors.Outline.Contrast
      EndIf
   Else
      nBevel.Colors.Edges.r = base.Colors.Edges.r
      nBevel.Colors.Edges.g = base.Colors.Edges.g
      nBevel.Colors.Edges.b = base.Colors.Edges.b
      nBevel.Colors.Edges.Contrast = base.Colors.Edges.Contrast
      nBevel.Colors.Fill1.r = base.Colors.Fill1.r
      nBevel.Colors.Fill1.g = base.Colors.Fill1.g
      nBevel.Colors.Fill1.b = base.Colors.Fill1.b
      nBevel.Colors.Fill1.Contrast = base.Colors.Fill1.Contrast
      nBevel.Colors.Fill2.r = base.Colors.Fill2.r
      nBevel.Colors.Fill2.g = base.Colors.Fill2.g
      nBevel.Colors.Fill2.b = base.Colors.Fill2.b
      nBevel.Colors.Fill2.Contrast = base.Colors.Fill2.Contrast
      nBevel.Colors.Outline.r = base.Colors.Outline.r
      nBevel.Colors.Outline.g = base.Colors.Outline.g
      nBevel.Colors.Outline.b = base.Colors.Outline.b
      nBevel.Colors.Outline.Contrast = base.Colors.Outline.Contrast
   EndIf

   Return(nBevel)
EndFunction
Function scui.Get(id) ;---------------------------------------------------------
   ; docs updated 28.12.2008

   ; Returns all available data of the IFO identified by <id>

   If GetType(id) = #STRING Then id = scui.GetIFOID(id)
   If id < 0 Then Return

   Local Obj     = scui.IFO[id]
   Local ObjData = {}

/* These Fields are returned for all classes                                 *
 * - Visible        Visible flag            - Enabled        Enabled flag    *
 * - oType          Object Type             - oClass         Object Class    *
 * - oInteractive   1 for Interactive Objects, 0 for non-interactive ones    *
 * - oName          Object Name             - Owner          Object Owner    *
 * - oParent        Parent IFO's ID         - Status         Object Status   */
   ObjData.Visible      = Obj.Visible
   ObjData.Enabled      = Obj.Enabled
   ObjData.oType        = Obj.oType
   ObjData.oClass       = Obj.oClass
   ObjData.oInteractive = Obj.oInteractive
   ObjData.oName        = Obj.oName
   ObjData.Owner        = Obj.Owner

   If Not(helpers.FieldIsNil(Obj, "oparent")) Then ObjData.oParent = Obj.oParent Else ObjData.oParent = -1
   If Not(helpers.FieldIsNil(Obj, "status" )) Then ObjData.Status  = Obj.Status  Else ObjData.Status  = -1
    
   /* Leggo i parametri SPECIFICI di ciascuna IFOCLASS */
   Switch Obj.oClass
      Case #IFOCLASS_BEVELBOX
/*       **********************************************************************
         * .Position, .Size, .Class, .Bevel, .ObjPtr, .ObjId, .Bevel, .Owner  *
         * .Visible, .oClass, .oInteractive, .oName                           *
         **********************************************************************/
         Local tmp = Obj.oData.Bevel
         ObjData.Position = { x = tmp.Position.x, y = tmp.Position.y }
         ObjData.Size     = { x = tmp.Size.x,     y = tmp.Size.y }
         ObjData.Enabled  = Nil
         ObjData.Status   = Nil
         ObjData.oType    = Nil
         ObjData.Class    = "BevelBox"
         ObjData.Bevel    = tmp
         ObjData.ObjPtr   = Obj
         ObjData.ObjId    = id

            
      Case #IFOCLASS_LABEL
         /* Position, Size                                                   */
         /* Bevel                                                            */
         /* Text                                                             */
         Local tmp = Obj.oData.Bevel
         ObjData.Position = { x = tmp.Position.x, y = tmp.Position.y }
         ObjData.Size     = { x = tmp.Size.x,     y = tmp.Size.y }
         ObjData.Enabled  = Nil
         ObjData.Status   = Nil
         ObjData.oType    = Nil

         ObjData.Class    = "Label"
         ObjData.Bevel    = tmp
         ObjData.Text     = Obj.oData.Text
         ObjData.Caption  = Obj.oData.Text.Content.Values
         ObjData.Lines    = Obj.oData.Text.Content.Lines
         ObjData.ObjPtr   = Obj
         ObjData.ObjId    = id
         
      Case #IFOCLASS_BUTTON
         /* Position, Size                                                   */
         /* Bevel, HBevel, PBevel, DBevel                                    */
         /* Text,  HText,  PText,  DText                                     */
         /* Actions                                                          */
         Local tmp = Obj.oData.Bevel
         ObjData.Position = { x = tmp.Position.x, y = tmp.Position.y }
         ObjData.Size     = { x = tmp.Size.x,     y = tmp.Size.y }

         ObjData.oType    = Nil
         
         Local tmp = Obj.oData
         ObjData.Bevel   = tmp.Bevel
         ObjData.HBevel  = tmp.HBevel
         ObjData.PBevel  = tmp.PBevel
         ObjData.DBevel  = tmp.DBevel
         ObjData.Text    = tmp.Text
         ObjData.HText   = tmp.HText
         ObjData.PText   = tmp.PText
         ObjData.DText   = tmp.DText
         ObjData.Caption = Obj.oData.Text.Content.Values
         ObjData.Lines   = Obj.oData.Text.Content.Lines
         ObjData.HCaption= Obj.oData.HText.Content.Values
         ObjData.HLines  = Obj.oData.HText.Content.Lines
         ObjData.PCaption= Obj.oData.PText.Content.Values
         ObjData.PLines  = Obj.oData.PText.Content.Lines
         ObjData.DCaption= Obj.oData.DText.Content.Values
         ObjData.DLines  = Obj.oData.DText.Content.Lines
         ObjData.ObjPtr  = Obj
         ObjData.ObjId   = id
         ObjData.Actions = Obj.Actions
            
      Case #IFOCLASS_SWITCH
         /* Position, Size                                                   */
         /* Bevel, HBevel, PBevel, DNBevel, DPBevel                          */
         /* Text,  HText,  PText,  DNText,  BPText                           */
         /* Actions, Value                                                   */
         Local tmp = Obj.oData.Bevel
         ObjData.Position     = { x = tmp.Position.x, y = tmp.Position.y }
         ObjData.Size         = { x = tmp.Size.x,     y = tmp.Size.y }
         
         Local tmp = Obj.oData
         ObjData.Bevel        = tmp.Bevel
         ObjData.HBevel       = tmp.HBevel
         ObjData.PBevel       = tmp.PBevel
         ObjData.DNBevel      = tmp.DNBevel
         ObjData.DPBevel      = tmp.DPBevel
         ObjData.Text         = tmp.Text
         ObjData.HText        = tmp.HText
         ObjData.PText        = tmp.PText
         ObjData.DNText       = tmp.DNText
         ObjData.DPText       = tmp.DPText
         ObjData.Actions      = Obj.Actions
         ObjData.Value        = Obj.Value

      Case #IFOCLASS_GAUGE
         /* Position, Size                                                   */
         /* Container, Cursor                                                */
         /* Text                                                             */
         /* Format, MMin, MMax, Current                                      */
         Local tmp = Obj.oData.Container
         ObjData.Position     = { x = tmp.Position.x, y = tmp.Position.y }
         ObjData.Size         = { x = tmp.Size.x,     y = tmp.Size.y }

         ObjData.Container    = Obj.oData.Container
         ObjData.Cursor       = Obj.oData.Cursor
         ObjData.Text         = Obj.oData.Text
         ObjData.Format       = Obj.oData.Format
         ObjData.MMin         = Obj.Values.MMin
         ObjData.MMax         = Obj.Values.MMax
         ObjData.Value        = Obj.Values.Current

      Case #IFOCLASS_STRINGBOX
         /* Position, Size                                                   */
         /* Bevel, HBevel, PBevel, DNBevel, DPBevel                          */
         /* Text,  HText,  PText,  DNText,  BPText                           */
         /* Actions, Value, MaxLen, InputType, CustomCharacters              */
         Local tmp = Obj.oData.Bevel
         ObjData.Position     = { x = tmp.Position.x, y = tmp.Position.y }
         ObjData.Size         = { x = tmp.Size.x,     y = tmp.Size.y }
         ObjData.Bevel        = Obj.oData.Bevel
         ObjData.HBevel       = Obj.oData.HBevel
         ObjData.PBevel       = Obj.oData.PBevel
         ObjData.DBevel       = Obj.oData.DBevel            
         ObjData.Text         = Obj.oData.Text 
         ObjData.HText        = Obj.oData.HText 
         ObjData.PText        = Obj.oData.PText 
         ObjData.DText        = Obj.oData.DText       
         ObjData.Actions      = Obj.Actions
         ObjData.MaxLen       = Obj.MaxLen
         ObjData.InputType    = Obj.InputType
         ObjData.Value        = Obj.oData.Text.Content.Values[0]
			ObjData.CustomCharacters = Obj.CustomCharacters

      Case #IFOCLASS_SIMPLESCROLLER
         /* Position, Size                                                   */
         /* Bevel, HBevel, PBevel, DBevel                                    */
         /* Text,  HText,  PText,  DText                                     */
			/* Container, HContainer, DContainer                                */
         /* MMax, MMin, Value, MinStep, ScrollerType                         */
         ObjData.Position     = { x = Obj.oData.Container.Position.x,
                                  y = Obj.oData.Container.Position.y }
         ObjData.Size         = { x = Obj.oData.Container.Size.x,
                                  y = Obj.oData.Container.Size.y }
         ObjData.Cursor       = Obj.oData.Cursor
         ObjData.HCursor      = Obj.oData.HCursor
         ObjData.PCursor      = Obj.oData.PCursor
         ObjData.DCursor      = Obj.oData.DCursor
         ObjData.Text         = Obj.oData.Text
         ObjData.HText        = Obj.oData.HText
         ObjData.PText        = Obj.oData.PText
         ObjData.DText        = Obj.oData.DText
         ObjData.Container    = Obj.oData.Container
         ObjData.HContainer   = Obj.oData.HContainer
         ObjData.DContainer   = Obj.oData.DContainer
         ObjData.Actions      = Obj.Actions
         ObjData.MMin         = Obj.Values.MMin
         ObjData.MMax         = Obj.Values.MMax
         ObjData.Value        = Obj.Values.Current
         ObjData.MinStep      = Obj.Values.MinStep
			ObjData.ScrollerType = Obj.Type

      Case #IFOCLASS_SCROLLER
         ObjData.Position     = { x = Obj.oData.Container.Position.x,
                                  y = Obj.oData.Container.Position.y }
         ObjData.Size         = { x = Obj.oData.Container.Size.x,
                                  y = Obj.oData.Container.Size.y }
         ObjData.Type         = Obj.Type
         ObjData.TotalItems   = Obj.TotalItems
         ObjData.VisibleItems = Obj.VisibleItems
         ObjData.CurrentItem  = Obj.FirstItem
         ObjData.Value        = Int(Obj.FirstItem) + Obj.ValueOffset
         ObjData.ValueOffset  = Obj.ValueOffset
         ObjData.ArrowStep    = Obj.ArrowStep
         ObjData.ClickStep    = Obj.ClickStep
         ObjData.TextMode     = Obj.TextMode
         ObjData.TextContent  = Obj.TextContent
         ObjData.HandleType   = Obj.HandleType
         
         ObjData.Container    = Obj.oData.Container
         ObjData.hContainer   = Obj.oData.hContainer
         ObjData.dContainer   = Obj.oData.dContainer
         ObjData.Cursor       = Obj.oData.Cursor
         ObjData.hCursor      = Obj.oData.hCursor
         ObjData.pCursor      = Obj.oData.pCursor
         ObjData.dCursor      = Obj.oData.dCursor
         ObjData.Text         = Obj.oData.Text
         ObjData.hText        = Obj.oData.hText
         ObjData.pText        = Obj.oData.pText
         ObjData.dText        = Obj.oData.dText
      
      Case #IFOCLASS_OPTIONS
         /* Position, Size                                                   */
			/* Childs, ChildCount                                               */
			/* Mode, DefaultOptions                                             */
			/* SwitchWidth, SwitchPosition, Rows, Columns, Options              */
			/* Container                                                        */
         /* NSwitch, HSwitch, PSwitch, DSwitch                               */
         /* SwiNText,  SwiHText,  SwiPText,  SwiDText                        */
			/* Container, HContainer, DContainer                                */
         /* MMax, MMin, Value, MinStep, ScrollerType                         */
			/* NLabel, LabelText                                                */
			/* Actions, Value                                                   */
			ObjData.Position     = { x = Obj.oData.Container.Position.x,
											 y = Obj.oData.Container.Position.y }
			ObjData.Size         = { x = Obj.oData.Container.Size.x,
											 y = Obj.oData.Container.Size.y }
			ObjData.Childs       = Obj.Childs
			ObjData.ChildCount   = Obj.ChildCount
			ObjData.Mode         = Obj.Mode
			ObjData.DefaultOptions = Obj.DefaultOptions
			ObjData.SwitchWidth    = Obj.SwitchWidth
			ObjData.SwitchPosition = Obj.SwitchPosition
			ObjData.Rows           = Obj.Rows
			ObjData.Columns        = Obj.Columns
			ObjData.Options        = Obj.Options
			ObjData.Container    = Obj.oData.Container
			ObjData.NSwitch      = Obj.oData.NSwitch
			ObjData.HSwitch      = Obj.oData.HSwitch
			ObjData.PSwitch      = Obj.oData.PSwitch
			ObjData.DSwitch      = Obj.oData.DSwitch
			ObjData.SwiNText     = Obj.oData.SwiNText
			ObjData.SwiHText     = Obj.oData.SwiHText
			ObjData.SwiPText     = Obj.oData.SwiPText
			ObjData.SwiDText     = Obj.oData.SwiDText
			ObjData.NLabel       = Obj.oData.NLabel
			ObjData.LabelText    = Obj.oData.LabelText
			ObjData.Actions      = Obj.Actions
			ObjData.Value        = {}
			Local i = 0
			Local ind = 0
			For i = 1 To Obj.ChildCount
				 Local c_id = Obj.Childs[i]
				 /* Salta tutto cio' che non e' Switch, ovvero le Label */
				 If scui.IFO[c_id].oClass = #IFOCLASS_SWITCH
					  ObjData.Value[ind] = scui.IFO[c_id].Value
					  ind = ind + 1
				 EndIf
			Next
         ObjData.ValuesCnt = ind
            
      Case #IFOCLASS_CYCLE
         /* Position, Size                                                   */
			/* NCycle, HCycle, PCycle, DNCycle, DPCycle                         */
			/* NText, HText, PText, DNText, DPText                              */
			/* NOptionBox, HOptionBox, POptionBox, NOptionText, HOptionText     */
			/* POptionText, Container                                           */
			/* NScrollerBox, HScrollerBox, DScrollerBox                         */
			/* NScrollerCurs, HScrollerCurs, PScrollerCurs, DScrollerCurs       */
			/* NScrollerText, HScrollerText, PScrollerText, DScrollerText       */
			/* Options, OptionsCount, OptionHeight, GrowDirection               */
			/* VisibleOptions, Actions, Value                                   */
         Local CycleGad = scui.IFO[Obj.Childs[1]]
			ObjData.Position     = { x = CycleGad.oData.Bevel.Position.x,
											 y = CycleGad.oData.Bevel.Position.y }
			ObjData.Size         = { x = CycleGad.oData.Bevel.Size.x,
											 y = CycleGad.oData.Bevel.Size.y }
			ObjData.NCycle       = CycleGad.oData.Bevel
			ObjData.HCycle       = CycleGad.oData.HBevel
			ObjData.PCycle       = CycleGad.oData.PBevel
			ObjData.DCycle      = CycleGad.oData.DBevel
			
			ObjData.NText        = CycleGad.oData.Text
			ObjData.HText        = CycleGad.oData.HText
			ObjData.PText        = CycleGad.oData.PText
			ObjData.DText       = CycleGad.oData.DText

			ObjData.NOptionBox   = Obj.oData.NOptionBox
			ObjData.HOptionBox   = Obj.oData.HOptionBox
			ObjData.POptionBox   = Obj.oData.POptionBox
			ObjData.NOptionText  = Obj.oData.NOptionText
			ObjData.POptionText  = Obj.oData.HOptionText
			ObjData.HOptionText  = Obj.oData.POptionText
			ObjData.NScrollerBox = Obj.oData.NScrollerBox
			ObjData.HScrollerBox = Obj.oData.HScrollerBox
			ObjData.DScrollerBox = Obj.oData.DScrollerBox
			ObjData.NScrollerCurs= Obj.oData.NScrollerCurs
			ObjData.HScrollerCurs= Obj.oData.HScrollerCurs
			ObjData.PScrollerCurs= Obj.oData.PScrollerCurs
			ObjData.DScrollerCurs= Obj.oData.DScrollerCurs
			ObjData.NScrollerText= Obj.oData.NScrollerText
			ObjData.HScrollerText= Obj.oData.HScrollerText
			ObjData.PScrollerText= Obj.oData.PScrollerText
			ObjData.DScrollerText= Obj.oData.DScrollerText
			ObjData.Container    = Obj.oData.Container
			ObjData.GrowDirection= Obj.GrowDirection
			ObjData.OptionsCount = Obj.OptionsCount
			ObjData.Options      = Obj.Options
			ObjData.OptionHeight = Obj.OptionHeight
			ObjData.Value        = Obj.CurrentOption
			ObjData.VisibleOptions = Obj.VisibleOptions
			ObjData.Actions      = Obj.Actions

      Case #IFOCLASS_LISTVIEW
         /* Position, Size                                                     */
			/* Mode, FieldCount, FieldNames, VisibleRows, EntriesCount, Entries   */
			/* ChildsCount, Childs, ScrollerID, Selected, Sizes, RowHeight        */
			/* Actions                                                            */
			/* NScrollerBox, HScrollerBox, DScrollerBox                           */
			/* NScrollerCursor, HScrollerCursor, PScrollerCursor, DScrollerCursor */
			/* NScrollerText, HScrollerText, PScrollerText, DScrollerText         */
			/* NHeaderBox, HHeaderBox, PHeaderBox, DHeaderBox                     */
			/* NHeaderText, HHeaderText, PHeaderText, DHeaderText                 */
			/* NChoiceBox, HChoiceBox, PChoiceBox                                 */
			/* NChoiceText, HChoiceText, PChoiceText                              */
			ObjData.Position     = { x = Obj.oData.Container.Position.x,
											 y = Obj.oData.Container.Position.y }
			ObjData.Size         = { x = Obj.oData.Container.Size.x,
											 y = Obj.oData.Container.Size.y }
			ObjData.Mode         = Obj.Mode
			ObjData.FieldCount   = Obj.FieldCount
			ObjData.FieldNames   = Obj.FieldNames
			ObjData.VisibleRows  = Obj.VisibleRows
			ObjData.EntriesCount = Obj.EntriesCount
			ObjData.Entries      = Obj.Entries
			ObjData.ChildsCount  = Obj.ChildCount
			ObjData.Childs       = Obj.Childs
			ObjData.Choices      = Obj.Choices
			If helpers.FieldIsNil(Obj, "scrollerid") = 0 Then ObjData.ScrollerID = Obj.ScrollerID
			ObjData.Selected     = Obj.Selected
			ObjData.Sizes        = Obj.Sizes
			ObjData.RowHeight    = Obj.RowHeight
			ObjData.Actions      = Obj.Actions
			ObjData.Container     = Obj.oData.Container
			ObjData.NScrollerBox  = Obj.oData.NScrollerBox
			ObjData.HScrollerBox  = Obj.oData.HScrollerBox
			ObjData.DScrollerBox  = Obj.oData.DScrollerBox
			ObjData.NScrollerCursor = Obj.oData.NScrollerCursor
			ObjData.HScrollerCursor = Obj.oData.HScrollerCursor
			ObjData.PScrollerCursor = Obj.oData.PScrollerCursor
			ObjData.DScrollerCursor = Obj.oData.DScrollerCursor
			ObjData.NScrollerText = Obj.oData.NScrollerText
			ObjData.HScrollerText = Obj.oData.HScrollerText
			ObjData.PScrollerText = Obj.oData.PScrollerText
			ObjData.DScrollerText = Obj.oData.DScrollerText
			ObjData.NHeaderBox    = Obj.oData.NHeaderBox
			ObjData.HHeaderBox    = Obj.oData.HHeaderBox
			ObjData.PHeaderBox    = Obj.oData.PHeaderBox
			ObjData.DHeaderBox    = Obj.oData.DHeaderBox
			ObjData.NHeaderText   = Obj.oData.NHeaderText
			ObjData.HHeaderText   = Obj.oData.HHeaderText
			ObjData.PHeaderText   = Obj.oData.PHeaderText
			ObjData.DHeaderText   = Obj.oData.DHeaderText            
			ObjData.NChoiceBox    = Obj.oData.NChoiceBox
			ObjData.HChoiceBox    = Obj.oData.HChoiceBox
			ObjData.PChoiceBox    = Obj.oData.PChoiceBox
			ObjData.NChoiceText   = Obj.oData.NChoiceText
			ObjData.HChoiceText   = Obj.oData.HChoiceText
			ObjData.PChoiceText   = Obj.oData.PChoiceText

		Case #IFOCLASS_TABS
         /* Position, Size                                                     */
			/* NSelBox, HSelBox, PSelBox, DSelBox                                 */
			/* NSelText, HSelText, PSelText, DSelText                             */
			/* PageNames, PageSelectorID, PageCount, ActivePage                   */
			/* TabChilds, BigContainer, SmallContainer, ContentFrame              */
			ObjData.Position     = { x = Obj.oData.BigContainer.Position.x,
											 y = Obj.oData.BigContainer.Position.y }
			ObjData.Size         = { x = Obj.oData.BigContainer.Size.x,
											 y = Obj.oData.BigContainer.Size.y }
			ObjData.NSelBox = Obj.NSelBox
			ObjData.HSelBox = Obj.HSelBox
			ObjData.PSelBox = Obj.PSelBox
			ObjData.DSelBox = Obj.DSelBox
			ObjData.NSelText = Obj.NSelText
			ObjData.HSelText = Obj.HSelText
			ObjData.PSelText = Obj.PSelText
			ObjData.DSelText = Obj.DSelText
			ObjData.PageNames = Obj.PageNames
			ObjData.PageSelectorID = Obj.PageSelectorID
			ObjData.PageCount = Obj.PageCount
			ObjData.ActivePage = Obj.ActivePage
			ObjData.TabChilds = Obj.TabChilds
			ObjData.BigContainer = Obj.oData.BigContainer
			ObjData.SmallContainer = Obj.oData.SmallContainer
			ObjData.ContentFrame = Obj.oData.ContentFrame
		
        Case #IFOCLASS_IMAGE
            ObjData.Position = { x = Obj.oData.Container.Position.x, y = Obj.oData.Container.Position.y }
            ObjData.Size = { x = Obj.oData.Container.Size.x, y = Obj.oData.Container.Size.y }
            ObjData.BrushID = Obj.ImageBrush
            ObjData.ImageFile = Obj.ImageFile
            ObjData.PictureOffset = { x = Obj.ImageX, y = Obj.ImageY }
            ObjData.ImageOffset = { x = Obj.XOffset, y = Obj.YOffset }
            ObjData.ImageSize   = { x = Obj.ImageWidth, y = Obj.ImageHeight }
				ObjData.FullSize    = { x = Obj.FullSize.x, y = Obj.FullSize.y }
            ObjData.ImagePosition = { x = Obj.ImageX, y = Obj.ImageY }
            ObjData.ResizeMode  = Obj.ResizeMode
            ObjData.Actions = Obj.Actions

         Case #IFOCLASS_MENU
            ObjData.Position = { x = Obj.Position.x, y = Obj.Position.y }
            ObjData.Size     = { x = Obj.Size.x,     y = Obj.Size.y }

    EndSwitch
    
    Return(ObjData)
    
EndFunction
Function scui.GetIFOID(name) ;--------------------------------------------------
   ; docs updated 28.12.2008

   If helpers.FieldIsNil(scui.QuickFind, name) Then Return(-1)
   Return(scui.QuickFind[name])
   
EndFunction
Function scui.Set(id, tags, redraw) ;-------------------------------------------
   ; docs updated 28.12.2008

   ; Sets one or more tags of the given IFO

   If GetType(id) = #STRING Then id = scui.GetIFOID(id)
   If id < 0 Then Return

   Local Obj = scui.IFO[id]
   Local ObjData = scui.IFO[id].oData
    
   /* These attributes are valid for all IFO classes                         */
   /* Visible, Enabled, oParent, Status, oName, Owner                        */
	; *** ATTENZIONE: <Enabled> e <Visible> devono essere applicati anche ai ***
	; ***             childs nel caso di gadget complessi, come il ListView  ***
	; ***             per esempio.                                           ***
	
   scui.Win.Select(Obj.Owner)
   
   /* VISIBLE */
   If helpers.FieldIsNil(tags, "visible") = 0
      Obj.Visible = tags.Visible
      If Obj.oInteractive = 1
         If Obj.oClass <> #IFOCLASS_CYCLE
            If tags.Visible = #IFO_HIDDEN Then DisableButton(id) Else EnableButton(id)
         EndIf
      EndIf
		; GESTIONE CHILDLIST -------------------------------------------------
		If helpers.FieldIsNil(Obj, "childlist") = 0
			Local GrpCnt = helpers.CountEntries(Obj.ChildList)
			For Local g = 1 To GrpCnt
				Local childs = helpers.CountEntries(Obj.ChildList[g])
				For Local ccnt = 1 To childs Do scui.Set(Obj.ChildList[g][ccnt].Id, { Visible = tags.Visible } )
			Next
		EndIf

      ; Verifica se esistono Child
      If helpers.FieldIsNil(Obj, "childs") = 0
         Local cnt = helpers.CountEntries(Obj.Childs)
         Local i
         For i = 1 To cnt
            scui.Set(Obj.Childs[i], { Visible = tags.Visible }, redraw)
         Next
      EndIf
      ; Per il ListView verifica se esiste lo scroller
      If helpers.FieldIsNil(Obj, "scrollerid") = 0 Then scui.Set(Obj.ScrollerID, { Visible = tags.Visible }, redraw)

      ; Se un IFO diventa invisible ridisegno il padre se esiste, altrimenti ridisegno
      ; tutta la gui, solo se redraw e' settato.
      If helpers.IsNil(redraw) = 0
         If helpers.FieldIsNil(Obj, "daddy") = 1
            If scui.prefs.RedrawWhenHide Then scui.RedrawObjects()
         Else
            scui.RenderObject(Obj.Daddy)
         EndIf
      EndIf
   EndIf       
    
   /* ENABLED */
   If helpers.FieldIsNil(tags, "enabled") = 0
      Obj.Enabled = tags.Enabled
      ; inoltre devo forzare lo stato su normal per tutti gli oggetti tranne gli
      ; switch
      If Obj.oClass <> #IFOCLASS_SWITCH
         Obj.Status = #IFOSTATUS_NORMAL
      EndIf
      
      If Obj.oInteractive = 1
         If Obj.oClass <> #IFOCLASS_CYCLE
            If tags.Enabled = #IFO_DISABLED Then DisableButton(id) Else EnableButton(id)
         EndIf
      EndIf

		; GESTIONE CHILDLIST -------------------------------------------------
		If helpers.FieldIsNil(Obj, "childlist") = 0
			Local GrpCnt = helpers.CountEntries(Obj.ChildList)
			For Local g = 1 To GrpCnt
				Local childs = helpers.CountEntries(Obj.ChildList[g])
				For Local ccnt = 1 To childs Do scui.Set(Obj.ChildList[g][ccnt].Id, { Enabled = tags.Enabled } )
			Next
		EndIf

      ; Verifica se esistono Child
      If helpers.FieldIsNil(Obj, "childs") = 0
         Local cnt = helpers.CountEntries(Obj.Childs)
         Local i
         For i = 1 To cnt
            scui.Set(Obj.Childs[i], { Enabled = tags.Enabled }, redraw)
         Next
      EndIf
      ; Per il ListView verifica se esiste lo scroller
      If helpers.FieldIsNil(Obj, "scrollerid") = 0 Then scui.Set(Obj.ScrollerID, { Enabled = tags.Enabled }, redraw)

   EndIf

   /* OPARENT : STA ROBA E' MOLTO PERICOLOSA, VALUTARE BENE SE SERVE         */
   /* oParent = -1 --> Remove the assigned Parent from the IFO               */
   If helpers.FieldIsNil(tags, "oparent") = 0
      If tags.oParent = -1
         ; *** QUESTO CONTROLLO NON E' PIU' UN CHILD DEVO VERIFICARE CHE
         ; *** IL PARENT NON LO ABBIA MEMORIZZATO COME CHILD
         Obj.oParent = nil
      Else
         ; *** OCCHIO PERCHE' QUA DEVO VERIFICARE LE DIMESIONI
         ; *** DI QUESTO CHILD RISPETTO AL NUOVO PARENT E COMUNQUE DEVO
         ; *** CONTROLLARE SE DEV'ESSERE MEMORIZZATO IN QUALCHE LISTA
         Obj.oParent = tags.oParent
      EndIf
   EndIf

   /* STATUS */
   If helpers.FieldIsNil(tags, "status" ) = 0 Then Obj.Status = tags.Status

   /* ONAME ---> IL NOME NON SI CAMBIA! */
   ;If helpers.FieldIsNil(tags, "oname" ) = 0 Then Obj.oName = tags.oName

   /* OWNER */
   If helpers.FieldIsNil(tags, "owner" ) = 0
		Obj.Owner = tags.Owner
		
		; GESTIONE CHILDLIST -------------------------------------------------
		If helpers.FieldIsNil(Obj, "childlist") = 0
			Local GrpCnt = helpers.CountEntries(Obj.ChildList)
			For Local g = 1 To GrpCnt
				Local childs = helpers.CountEntries(Obj.ChildList[g])
				For Local ccnt = 1 To childs Do scui.Set(Obj.ChildList[g][ccnt].Id, { Owner = tags.Owner } )
			Next
		EndIf
	EndIf

   /* Setto i parametri SPECIFICI di ciascuna IFOCLASS */
   Switch Obj.oClass
      ;------------------------------------------------------------------------
      Case #IFOCLASS_BEVELBOX
	   ;------------------------------------------------------------------------
		   /* POSITION                                                         */
	      If Not(helpers.FieldIsNil(tags, "position"))
	         Local xOffset, yOffset = 0, 0
	         ; Per ogni coordinata calcola l'offset di spostamento ed aggiorna la
	         ; posizione dell'oggetto.
	         If Not(helpers.FieldIsNil(tags.Position, "x"))
	            xOffset = tags.Position.x - ObjData.Bevel.Position.x
	            ObjData.Bevel.Position.x = tags.Position.x
	         EndIf
	         If Not(helpers.FieldIsNil(tags.Position, "y"))
	            yOffset = tags.Position.y - ObjData.Bevel.Position.y
	            ObjData.Bevel.Position.y = tags.Position.y
	         EndIf

				scui.MoveChilds(Obj, xOffset, yOffset)
				
			EndIf
			
         /* SIZE                                                             */
         If Not(helpers.FieldIsNil(tags, "size"))
				Local xFact, yFact = 1, 1
	         ; Per ogni coordinata calcola il fattore di ridimensionamento ed
	         ; aggiorna la dimensione dell'oggetto.
            If Not(helpers.FieldIsNil(tags.Size, "x"))
					xFact = tags.Size.x / ObjData.Bevel.Size.x
					ObjData.Bevel.Size.x = tags.Size.x
				EndIf
            If Not(helpers.FieldIsNil(tags.Size, "y"))
					yFact = tags.Size.y / ObjData.Bevel.Size.y
					ObjData.Bevel.Size.y = tags.Size.y
				EndIf

				scui.ResizeChilds(Obj, xFact, yFact)
				
         EndIf

         /* BEVEL                                                            */
         If Not(helpers.FieldIsNil(tags, "bevel"))
            tags.Bevel.Position = Nil
            tags.Bevel.Size     = Nil
            helpers.SetTable(ObjData.Bevel, tags.Bevel, False)
         EndIf
         
         
      Case #IFOCLASS_MENU
      ;DebugPrint("Setting MENU CLASS")
	      ;------------------------------------------------------------------------
		   /* POSITION */
	      If helpers.FieldIsNil(tags, "position") = 0
	         Local xOffset, yOffset = 0, 0
	         ; Per ogni coordinata calcola l'offset di spostamento ed aggiorna la |
	         ; posizione dell'oggetto                                             |
	         If helpers.FieldIsNil(tags.Position, "x") = 0
	            xOffset = tags.Position.x - Obj.Position.x
	            Obj.Position.x = tags.Position.x
	         EndIf
	         If helpers.FieldIsNil(tags.Position, "y") = 0
	            yOffset = tags.Position.y - Obj.Position.y
	            Obj.Position.y = tags.Position.y
	         EndIf
				/* Sposta tutti i Child presenti nel controllo                   */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					Local ChildData = scui.Get(ChildID)
					Local NewPos = { x = ChildData.Position.x + xOffset,
					                 y = ChildData.Position.y + yOffset }
					scui.Set(ChildID, { Position = NewPos })
   			Next

				scui.MoveChilds(Obj, xOffset, yOffset)
				
			EndIf
			
         /* SIZE */
         If helpers.FieldIsNil(tags, "size") = 0
				Local xFact, yFact       = 1, 1
	         ; Per ogni coordinata calcola il fattore di ridimensionamento ed     |
	         ; aggiorna la dimensione dell'oggetto                                |
            If helpers.FieldIsNil(tags.Size, "x") = 0
					xFact = tags.Size.x / Obj.Size.x
					Obj.Size.x = tags.Size.x
				EndIf
            If helpers.FieldIsNil(tags.Size, "y") = 0
					yFact = tags.Size.y / Obj.Size.y
					Obj.Size.y = tags.Size.y
				EndIf

				scui.ResizeChilds(Obj, xFact, yFact)
				
         EndIf

         /* BEVEL */
         ;If helpers.FieldIsNil(tags, "bevel") = 0 Then ObjData.Bevel = scui.NewBevel(ObjData.Bevel, tags.Bevel, 1)

      ;------------------------------------------------------------------------
      Case #IFOCLASS_LABEL
      ;------------------------------------------------------------------------
         /* POSITION */
         If Not(helpers.FieldIsNil(tags, "position"))
            Local xOffset, yOffset = 0, 0
            If Not(helpers.FieldIsNil(tags.Position, "x")) Then xOffset = tags.Position.x - ObjData.Bevel.Position.x
            If Not(helpers.FieldIsNil(tags.Position, "y")) Then yOffset = tags.Position.y - ObjData.Bevel.Position.y
            scui.MoveBevel(ObjData.Bevel, xOffset, yOffset, 1)
            scui.MoveText(ObjData.Text, xOffset, yOffset, 1)
				
				scui.MoveChilds(Obj, xOffset, yOffset)
				
         EndIf

         /* SIZE */
         If Not(helpers.FieldIsNil(tags, "size"))
            Local xOffset, yOffset = 0, 0
            Local xFact, yFact = 1, 1
            If Not(helpers.FieldIsNil(tags.Size, "x"))
					xFact = tags.Size.x / ObjData.Bevel.Size.x
					xOffset = tags.Size.x - ObjData.Bevel.Size.x
				EndIf
            If Not(helpers.FieldIsNil(tags.Size, "y"))
					yFact = tags.Size.y / ObjData.Bevel.Size.y
					yOffset = tags.Size.y - ObjData.Bevel.Size.y
				EndIf
            
            scui.ResizeBevel(ObjData.Bevel , xOffset, yOffset, 1)
            scui.ResizeText(ObjData.Text , xOffset, yOffset, 1)
				
				scui.ResizeChilds(Obj, xFact, yFact)

         EndIf

         /* BEVEL */
         If Not(helpers.FieldIsNil(tags, "bevel"))
            tags.Bevel.Position = Nil
            tags.Bevel.Size     = Nil
            helpers.SetTable(ObjData.Bevel, tags.Bevel, False)
         EndIf
    
         /* TEXT */
         If Not(helpers.FieldIsNil(tags, "text"))
            tags.Text.Area = Nil
            helpers.SetTable(ObjData.Text , tags.Text, False)
         EndIf
         
         /* CAPTION */
         If Not(helpers.FieldIsNil(tags, "caption"))
            helpers.SetTable(ObjData.Text.Content.Values , tags.Caption, False)
            ObjData.Text.Content.Lines = helpers.CountEntries(tags.Caption)
         EndIf
         
         /* LINES */
         If Not(helpers.FieldIsNil(tags, "lines"))
            Local MaxLines = helpers.CountEntries(ObjData.Text.Content.Values)
            If tags.Lines > MaxLines Then tags.Lines = MaxLines
            ObjData.Text.Content.Lines = tags.Lines
         EndIf

      ;------------------------------------------------------------------------
      Case #IFOCLASS_BUTTON
      ;------------------------------------------------------------------------
         /* POSITION */
         If helpers.FieldIsNil(tags, "position") = 0
            Local xOffset, yOffset = 0, 0
            If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.Bevel.Position.x
            If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.Bevel.Position.y
            scui.MoveBevel(ObjData.Bevel,  xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.HBevel, xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.PBevel, xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.DBevel, xOffset, yOffset, 1)
            scui.MoveText(ObjData.Text,  xOffset, yOffset, 1)
            scui.MoveText(ObjData.HText, xOffset, yOffset, 1)
            scui.MoveText(ObjData.PText, xOffset, yOffset, 1)
            scui.MoveText(ObjData.DText, xOffset, yOffset, 1)

            Local Bevel = ObjData.Bevel
            DeleteButton(id)
            MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
                       { OnMouseOver = scui.HandleObject, OnMouseOut  = scui.HandleObject, OnMouseDown = scui.HandleObject, OnMouseUp   = scui.HandleObject } )                  
            If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
				
				scui.MoveChilds(Obj, xOffset, yOffset)
				
         EndIf

         /* SIZE */
         If helpers.FieldIsNil(tags, "size") = 0
            Local xOffset, yOffset = 0, 0
            Local xFact, yFact     = 1, 1
            If helpers.FieldIsNil(tags.Size, "x") = 0
					xOffset = tags.Size.x - ObjData.Bevel.Size.x
					xFact = tags.Size.x / ObjData.Bevel.Size.x
				EndIf
            If helpers.FieldIsNil(tags.Size, "y") = 0 
					yOffset = tags.Size.y - ObjData.Bevel.Size.y
					yFact = tags.Size.y / ObjData.Bevel.Size.y
				EndIf
            scui.ResizeBevel(ObjData.Bevel , xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.HBevel, xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.PBevel, xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.DBevel, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.Text , xOffset, yOffset, 1)
            scui.ResizeText(ObjData.HText, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.PText, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.DText, xOffset, yOffset, 1)                

            Local Bevel = ObjData.Bevel
            DeleteButton(id)
            
            MakeButton(id, #SIMPLEBUTTON , Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
                       { OnMouseOver = scui.HandleObject, OnMouseOut  = scui.HandleObject, OnMouseDown = scui.HandleObject, OnMouseUp   = scui.HandleObject } )                  
            If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
				
				scui.ResizeChilds(Obj, xFact, yFact)
				
         EndIf

         /* ASPECT */
         /* AllBevels --> BevelStruct (Changes all bevels)                      */
         If Not(helpers.FieldIsNil(tags, "allbevels"))
            tags.AllBevels.Position = Nil
            tags.AllBevels.Size     = Nil
            helpers.SetTable(ObjData.Bevel, tags.AllBevels, False)
            helpers.SetTable(ObjData.HBevel, tags.AllBevels, False)
            helpers.SetTable(ObjData.PBevel, tags.AllBevels, False)
            helpers.SetTable(ObjData.DBevel, tags.AllBevels, False)
         EndIf

		   /* Bevel, HBevel, PBevel, DBevel --> BevelStruct                       */
         If Not(helpers.FieldIsNil(tags, "bevel" )) Then helpers.SetTable(ObjData.Bevel, tags.Bevel, False)
         If Not(helpers.FieldIsNil(tags, "hbevel")) Then helpers.SetTable(ObjData.HBevel, tags.HBevel, False)
         If Not(helpers.FieldIsNil(tags, "pbevel")) Then helpers.SetTable(ObjData.PBevel, tags.PBevel, False)
         If Not(helpers.FieldIsNil(tags, "dbevel")) Then helpers.SetTable(ObjData.DBevel, tags.DBevel, False)

         /* AllTexts --> TextStruct (Changes all texts)                         */
         If Not(helpers.FieldIsNil(tags, "alltexts"))
            tags.AllTexts.Area = Nil
            helpers.SetTable(ObjData.Text,  tags.AllTexts, False)
            helpers.SetTable(ObjData.HText, tags.AllTexts, False)
            helpers.SetTable(ObjData.PText, tags.AllTexts, False)
            helpers.SetTable(ObjData.DText, tags.AllTexts, False)
         EndIf

         /* Text, HText, PText, DText --> TextStruct                            */
         If Not(helpers.FieldIsNil(tags, "text"  )) Then helpers.SetTable(ObjData.Text,   tags.Text,  False)
         If Not(helpers.FieldIsNil(tags, "htext" )) Then helpers.SetTable(ObjData.HText , tags.HText, False)
         If Not(helpers.FieldIsNil(tags, "ptext" )) Then helpers.SetTable(ObjData.PText , tags.PText, False)
         If Not(helpers.FieldIsNil(tags, "dtext" )) Then helpers.SetTable(ObjData.DText , tags.DText, False)

         /* All Captions */
         If Not(helpers.FieldIsNil(tags, "allcaptions" ))
            helpers.SetTable(ObjData.Text.Content.Values, tags.allcaptions, False)
            helpers.SetTable(ObjData.HText.Content.Values, tags.allcaptions, False)
            helpers.SetTable(ObjData.PText.Content.Values, tags.allcaptions, False)
            helpers.SetTable(ObjData.DText.Content.Values, tags.allcaptions, False)
         EndIf
         
         /* All Lines */
         If Not(helpers.FieldIsNil(tags, "alllines"))
            ObjData.Text.Content.Lines = tags.AllLines
            ObjData.HText.Content.Lines = tags.AllLines
            ObjData.PText.Content.Lines = tags.AllLines
            ObjData.DText.Content.Lines = tags.AllLines
         EndIf
         
         /* Caption, HCaption, PCaption, DCaption */
         If Not(helpers.FieldIsNil(tags, "caption" )) Then helpers.SetTable(ObjData.Text.Content.Values,  tags.Caption, False)
         If Not(helpers.FieldIsNil(tags, "hcaption")) Then helpers.SetTable(ObjData.HText.Content.Values, tags.HCaption, False)
         If Not(helpers.FieldIsNil(tags, "pcaption")) Then helpers.SetTable(ObjData.PText.Content.Values, tags.PCaption, False)
         If Not(helpers.FieldIsNil(tags, "dcaption")) Then helpers.SetTable(ObjData.DText.Content.Values, tags.DCaption, False)
         
         /* Lines, HLines, PLines, DLines */
         If Not(helpers.FieldIsNil(tags, "lines" )) Then ObjData.Text.Content.Lines  = tags.Lines
         If Not(helpers.FieldIsNil(tags, "hlines")) Then ObjData.HText.Content.Lines = tags.HLines
         If Not(helpers.FieldIsNil(tags, "plines")) Then ObjData.PText.Content.Lines = tags.PLines
         If Not(helpers.FieldIsNil(tags, "dlines")) Then ObjData.DText.Content.Lines = tags.DLines
         
		   /* ACTIONS */
		   /* Actions.<Event> = 0 --> Remove the current assigned function        */
         /* OnPushed, OnDown                                                    */
         If Not(helpers.FieldIsNil(tags, "actions"))
            If Not(helpers.FieldIsNil(tags.Actions, "onpushed"))
               If tags.Actions.OnPushed = scui.NULLFUNC Then Obj.Actions.OnPushed = nil Else Obj.Actions.OnPushed = tags.Actions.OnPushed
            EndIf
            If Not(helpers.FieldIsNil(tags.Actions, "ondown"))
               If tags.Actions.OnDown = scui.NULLFUNC Then Obj.Actions.OnDown = nil Else Obj.Actions.OnDown = tags.Actions.OnDown
            EndIf
         EndIf

      Case #IFOCLASS_SWITCH
      ;------------------------------------------------------------------------
         /* POSITION */
         If helpers.FieldIsNil(tags, "position") = 0
            Local xOffset, yOffset = 0, 0
            If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.Bevel.Position.x
            If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.Bevel.Position.y
                
            scui.MoveBevel(ObjData.Bevel,   xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.HBevel,  xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.PBevel,  xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.DNBevel, xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.DPBevel, xOffset, yOffset, 1)
            scui.MoveText(ObjData.Text,   xOffset, yOffset, 1)
            scui.MoveText(ObjData.HText,  xOffset, yOffset, 1)
            scui.MoveText(ObjData.PText,  xOffset, yOffset, 1)
            scui.MoveText(ObjData.DNText, xOffset, yOffset, 1)
            scui.MoveText(ObjData.DPText, xOffset, yOffset, 1)

            Local Bevel = ObjData.Bevel
            DeleteButton(id)
            MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
                       { OnMouseOver = scui.HandleObject, OnMouseOut  = scui.HandleObject, OnMouseDown = scui.HandleObject, OnMouseUp   = scui.HandleObject } )                  
            If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
				
				scui.MoveChilds(Obj, xOffset, yOffset)
				
         EndIf

			/* SIZE */
         If helpers.FieldIsNil(tags, "size") = 0
            Local xOffset, yOffset = 0, 0
            Local xFact, yFact = 1, 1
            If helpers.FieldIsNil(tags.Size, "x") = 0
					xOffset = tags.Size.x - ObjData.Bevel.Size.x
					xFact = tags.Size.x / ObjData.Bevel.Size.x
				EndIf
            If helpers.FieldIsNil(tags.Size, "y") = 0 
					yOffset = tags.Size.y - ObjData.Bevel.Size.y
					yFact = tags.Size.y / ObjData.Bevel.Size.y
            EndIf
				
            scui.ResizeBevel(ObjData.Bevel,   xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.HBevel,  xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.PBevel,  xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.DNBevel, xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.DPBevel, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.Text,   xOffset, yOffset, 1)
            scui.ResizeText(ObjData.HText,  xOffset, yOffset, 1)
            scui.ResizeText(ObjData.PText,  xOffset, yOffset, 1)
            scui.ResizeText(ObjData.DNText, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.DPText, xOffset, yOffset, 1)

            Local Bevel = ObjData.Bevel
            DeleteButton(id)
            MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
                       { OnMouseOver = scui.HandleObject, OnMouseOut  = scui.HandleObject, OnMouseDown = scui.HandleObject, OnMouseUp   = scui.HandleObject } )                  
            If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
				
				scui.ResizeChilds(Obj, xFact, yFact)
				
         EndIf

         /* ASPECT */
         /* AllBevels --> BevelStruct (Changes all bevels)                      */
         If helpers.FieldIsNil(tags, "allbevels") = 0
            ObjData.Bevel   = scui.NewBevel(ObjData.Bevel,   tags.AllBevels, 1)
            ObjData.HBevel  = scui.NewBevel(ObjData.HBevel,  tags.AllBevels, 1)
            ObjData.PBevel  = scui.NewBevel(ObjData.PBevel,  tags.AllBevels, 1)
            ObjData.DNBevel = scui.NewBevel(ObjData.DNBevel, tags.AllBevels, 1)
            ObjData.DPBevel = scui.NewBevel(ObjData.DPBevel, tags.AllBevels, 1)
         EndIf

		   /* Bevel, HBevel, PBevel, DNBevel, DPBevel --> BevelStruct             */
         If helpers.FieldIsNil(tags, "bevel"  ) = 0 Then ObjData.Bevel   = scui.NewBevel(ObjData.Bevel,   tags.Bevel,   1)
         If helpers.FieldIsNil(tags, "hbevel" ) = 0 Then ObjData.HBevel  = scui.NewBevel(ObjData.HBevel,  tags.HBevel,  1)
         If helpers.FieldIsNil(tags, "pbevel" ) = 0 Then ObjData.PBevel  = scui.NewBevel(ObjData.PBevel,  tags.PBevel,  1)
         If helpers.FieldIsNil(tags, "dnbevel") = 0 Then ObjData.DNBevel = scui.NewBevel(ObjData.DNBevel, tags.DNBevel, 1)
         If helpers.FieldIsNil(tags, "dpbevel") = 0 Then ObjData.DPBevel = scui.NewBevel(ObjData.DPBevel, tags.DPBevel, 1)

         /* AllTexts --> TextStruct (Changes all texts)                         */
         If helpers.FieldIsNil(tags, "alltexts") = 0
            ObjData.Text   = scui.NewText(ObjData.Text,   tags.AllTexts, 1)
            ObjData.HText  = scui.NewText(ObjData.HText,  tags.AllTexts, 1)
            ObjData.PText  = scui.NewText(ObjData.PText,  tags.AllTexts, 1)
            ObjData.DNText = scui.NewText(ObjData.DNText, tags.AllTexts, 1)
            ObjData.DPText = scui.NewText(ObjData.DPText, tags.AllTexts, 1)
         EndIf

         /* Text, HText, PText, DNText, DPText --> TextStruct                   */
         If helpers.FieldIsNil(tags, "text"  ) = 0 Then ObjData.Text   = scui.NewText (ObjData.Text ,   tags.Text,   1)
         If helpers.FieldIsNil(tags, "htext" ) = 0 Then ObjData.HText  = scui.NewText (ObjData.HText ,  tags.HText,  1)
         If helpers.FieldIsNil(tags, "ptext" ) = 0 Then ObjData.PText  = scui.NewText (ObjData.PText ,  tags.PText,  1)
         If helpers.FieldIsNil(tags, "dntext") = 0 Then ObjData.DNText = scui.NewText (ObjData.DNText , tags.DNText, 1)
         If helpers.FieldIsNil(tags, "dptext") = 0 Then ObjData.DPText = scui.NewText (ObjData.DPText , tags.DPText, 1)

			/* Value                                                               */
			If helpers.FieldIsNil(tags, "value") = 0 Then Obj.Value = tags.Value
			
		   /* ACTIONS */
		   /* Actions.<Event> = 0 --> Remove the current assigned function        */
         /* OnChanged                                                           */
         If helpers.FieldIsNil(tags, "actions") = 0
            If helpers.FieldIsNil(tags.Actions, "onchanged") = 0
               If tags.Actions.OnChanged = 0 Then Obj.Actions.OnChanged = nil Else Obj.Actions.OnChanged = tags.Actions.OnChanged
            EndIf
         EndIf

      Case #IFOCLASS_GAUGE
      ;------------------------------------------------------------------------

         /* POSITION */
         If helpers.FieldIsNil(tags, "position") = 0
            Local xOffset, yOffset = 0, 0
            If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.Container.Position.x
            If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.Container.Position.y
                
            scui.MoveBevel(ObjData.Container, xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.Cursor, xOffset, yOffset, 1)
            scui.MoveText(ObjData.Text, xOffset, yOffset, 1)
            
            scui.MoveChilds(Obj, xOffset, yOffset)
         EndIf
            
         /* SIZE */
         If helpers.FieldIsNil(tags, "size") = 0
            Local xOffset, yOffset = 0, 0
            Local xFact, yFact = 1, 1
            If helpers.FieldIsNil(tags.Size, "x") = 0
               xOffset = tags.Size.x - ObjData.Container.Size.x
               xFact = tags.Size.x / ObjData.Container.Size.x
            EndIf
            If helpers.FieldIsNil(tags.Size, "y") = 0
               yOffset = tags.Size.y - ObjData.Container.Size.y
               yFact = tags.Size.y / ObjData.Container.Size.y
            EndIf

            Obj.BarSize = Obj.BarSize + xOffset
            scui.ResizeBevel(ObjData.Container, xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.Cursor, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.Text, xOffset, yOffset, 1)
            
            scui.ResizeChilds(Obj, xFact, yFact)
         EndIf
            
         /* ASPECT */
         /* Container, Cursor --> BevelStruct                                */
         If helpers.FieldIsNil(tags, "container") = 0 Then ObjData.Container = scui.NewBevel(ObjData.Container, tags.Container, 1)
         If helpers.FieldIsNil(tags, "cursor"   ) = 0 Then ObjData.Cursor    = scui.NewBevel(ObjData.Cursor   , tags.Cursor, 1)

			/* Text --> TextStruct                                              */
         If helpers.FieldIsNil(tags, "text") = 0 Then ObjData.Text = scui.NewText(ObjData.Text, tags.Text, 1)

			/* VALUES */
			/* MMin, MMax, Value, Format                                        */
         If helpers.FieldIsNil(tags, "mmin"  ) = 0 Then Obj.Values.MMin    = tags.MMin
         If helpers.FieldIsNil(tags, "mmax"  ) = 0 Then Obj.Values.MMax    = tags.MMax
         If helpers.FieldIsNil(tags, "value" ) = 0 Then Obj.Values.Current = tags.Value
         If helpers.FieldIsNil(tags, "format") = 0 Then Obj.oData.Format   = tags.Format
            
      Case #IFOCLASS_STRINGBOX
      ;------------------------------------------------------------------------
         /* POSITION */
         If helpers.FieldIsNil(tags, "position") = 0
            Local xOffset, yOffset = 0, 0
            If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.Bevel.Position.x
            If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.Bevel.Position.y
                
            scui.MoveBevel(ObjData.Bevel, xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.HBevel, xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.PBevel, xOffset, yOffset, 1)
            scui.MoveBevel(ObjData.DBevel, xOffset, yOffset, 1)
            scui.MoveText(ObjData.Text, xOffset, yOffset, 1)
            scui.MoveText(ObjData.HText, xOffset, yOffset, 1)
            scui.MoveText(ObjData.PText, xOffset, yOffset, 1)
            scui.MoveText(ObjData.DText, xOffset, yOffset, 1)

            Local Bevel = ObjData.Bevel
            DeleteButton(id)
            MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
                       { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )                  
            If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
            
            scui.MoveChilds(Obj, xOffset, yOffset)
         EndIf

         /* SIZE */
         If helpers.FieldIsNil(tags, "size") = 0
            Local xOffset, yOffset = 0, 0
            Local xFact, yFact = 1, 1
            If helpers.FieldIsNil(tags.Size, "x") = 0
               xOffset = tags.Size.x - ObjData.Bevel.Size.x
               xFact = tags.Size.x / ObjData.Bevel.Size.x
            EndIf
            If helpers.FieldIsNil(tags.Size, "y") = 0
               yOffset = tags.Size.y - ObjData.Bevel.Size.y
               yFact = tags.Size.y / ObjData.Bevel.Size.y
            EndIf
            scui.ResizeBevel(ObjData.Bevel, xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.HBevel, xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.PBevel, xOffset, yOffset, 1)
            scui.ResizeBevel(ObjData.DBevel, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.Text, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.HText, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.PText, xOffset, yOffset, 1)
            scui.ResizeText(ObjData.DText, xOffset, yOffset, 1)

            Local Bevel = ObjData.Bevel
            DeleteButton(id)
            MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
                       { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )                  
            If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
            
            scui.ResizeChilds(Obj, xFact, yFact)
         EndIf
         
         /* ASPECT */
         /* AllBevels --> BevelStruct                                        */
         If helpers.FieldIsNil(tags, "allbevels") = 0
            ObjData.Bevel  = scui.NewBevel(ObjData.Bevel,  tags.AllBevels, 1)
            ObjData.HBevel = scui.NewBevel(ObjData.HBevel, tags.AllBevels, 1)
            ObjData.PBevel = scui.NewBevel(ObjData.PBevel, tags.AllBevels, 1)
            ObjData.DBevel = scui.NewBevel(ObjData.DBevel, tags.AllBevels, 1)
         EndIf

         /* Bevel, HBevel, PBevel, DBevel --> BevelStruct                    */
         If helpers.FieldIsNil(tags, "bevel" ) = 0 Then ObjData.Bevel  = scui.NewBevel(ObjData.Bevel, tags.Bevel, 1)
         If helpers.FieldIsNil(tags, "hbevel") = 0 Then ObjData.HBevel = scui.NewBevel(ObjData.HBevel, tags.HBevel, 1)
         If helpers.FieldIsNil(tags, "pbevel") = 0 Then ObjData.PBevel = scui.NewBevel(ObjData.PBevel, tags.PBevel, 1)
         If helpers.FieldIsNil(tags, "dbevel") = 0 Then ObjData.DBevel = scui.NewBevel(ObjData.DBevel, tags.DBevel, 1)

         /* AllTexts --> TextStruct                                          */
         If helpers.FieldIsNil(tags, "alltexts") = 0
            ObjData.Text  = scui.NewText(ObjData.Text,  tags.AllTexts, 1)
            ObjData.HText = scui.NewText(ObjData.HText, tags.AllTexts, 1)
            ObjData.PText = scui.NewText(ObjData.PText, tags.AllTexts, 1)
            ObjData.DText = scui.NewText(ObjData.DText, tags.AllTexts, 1)
         EndIf

         /* Text, HText, PText, DText --> TextStruct                         */
         If helpers.FieldIsNil(tags, "text" ) = 0 Then ObjData.Text   = scui.NewText (ObjData.Text , tags.Text, 1)
         If helpers.FieldIsNil(tags, "htext") = 0 Then ObjData.HText  = scui.NewText (ObjData.HText , tags.HText, 1)
         If helpers.FieldIsNil(tags, "ptext") = 0 Then ObjData.PText  = scui.NewText (ObjData.PText , tags.PText, 1)
         If helpers.FieldIsNil(tags, "dtext") = 0 Then ObjData.DText  = scui.NewText (ObjData.DText , tags.DText, 1)
            
         /* Value                                                            */
         If helpers.FieldIsNil(tags, "value") = 0
            ObjData.Text.Content.Values[0]  = tags.Value
            ObjData.HText.Content.Values[0] = tags.Value
            ObjData.PText.Content.Values[0] = tags.Value
            ObjData.DText.Content.Values[0] = tags.Value
            Obj.Clear1st = 0
         EndIf
         
         /* Clear1st                                                        */
         If helpers.FieldIsNil(tags, "clear1st") = 0 
            If tags.Clear1st = #REMOVE_TAG
               Obj.Clear1st = 0
               Obj.Cleared  = 1
            Else
               Obj.Clear1st = tags.Clear1st
               Obj.Cleared  = nil
            EndIf
         EndIf
         
         /* MaxLen, InputType, CustomCharacters                             */
         If helpers.FieldIsNil(tags, "maxlen")    = 0 Then Obj.MaxLen    = tags.MaxLen
         If helpers.FieldIsNil(tags, "inputtype") = 0 Then Obj.InputType = tags.InputType
         If helpers.FieldIsNil(tags, "customcharactes") = 0 Then Obj.CustomCharacters = tags.CustomCharacters
         
         /* ACTIONS */
		   /* Actions.<Event> = 0 --> Remove the current assigned function        */
         /* OnExit, OnChange                                                    */
         If helpers.FieldIsNil(tags, "actions") = 0
            If helpers.FieldIsNil(tags.Actions, "onclick") = 0
               If tags.Actions.OnClick = 0 Then Obj.Actions.OnClick = nil Else Obj.Actions.OnClick = tags.Actions.OnClick
            EndIf
            If helpers.FieldIsNil(tags.Actions, "onexit") = 0
               If tags.Actions.OnExit = 0 Then Obj.Actions.OnExit = nil Else Obj.Actions.OnExit = tags.Actions.OnExit
            EndIf
            If helpers.FieldIsNil(tags.Actions, "onchange") = 0
               If tags.Actions.OnChange = 0 Then Obj.Actions.OnChange = nil Else Obj.Actions.OnChange = tags.Actions.OnChange
            EndIf
            If helpers.FieldIsNil(tags.Actions, "onkeypress") = 0
               If tags.Actions.OnKeypress = 0 Then Obj.Actions.OnKeypress = nil Else Obj.Actions.OnKeypress = tags.Actions.OnKeypress
            EndIf
         EndIf
         
      Case #IFOCLASS_SIMPLESCROLLER
      ;------------------------------------------------------------------------
         /* POSITION */
			If helpers.FieldIsNil(tags, "position") = 0
				Local xOffset, yOffset = 0, 0

				If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.Container.Position.x
				If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.Container.Position.y
				 
				scui.MoveBevel(ObjData.Cursor, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.HCursor, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.PCursor, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.DCursor, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.Container, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.HContainer, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.DContainer, xOffset, yOffset, 1)
				scui.MoveText(ObjData.Text, xOffset, yOffset, 1)
				scui.MoveText(ObjData.HText, xOffset, yOffset, 1)
				scui.MoveText(ObjData.PText, xOffset, yOffset, 1)
				scui.MoveText(ObjData.DText, xOffset, yOffset, 1)

            Obj.Cursor.xStart = Obj.Cursor.xStart + xOffset
            Obj.Cursor.yStart = Obj.Cursor.yStart + yOffset
            Obj.Cursor.xEnd = Obj.Cursor.xEnd + xOffset
            Obj.Cursor.yEnd = Obj.Cursor.yEnd + yOffset
            
				 Local Bevel = scui.IFO[id].oData.Container
				 DeleteButton(id)
				 MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
							  { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )
				 If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
             
             scui.MoveChilds(Obj, xOffset, yOffset)
			EndIf

			/* SIZE */
			If helpers.FieldIsNil(tags, "size") = 0
				Local xOffset, yOffset = 0, 0
				Local xFact, yFact = 1, 1    
				If helpers.FieldIsNil(tags.Size, "x") = 0
               xOffset = tags.Size.x - ObjData.Container.Size.x
               xFact = tags.Size.x / ObjData.Container.Size.x
            EndIf
				If helpers.FieldIsNil(tags.Size, "y") = 0
               yOffset = tags.Size.y - ObjData.Container.Size.y
               yFact = tags.Size.y / ObjData.Container.Size.y
            EndIf
			  
				scui.ResizeBevel(ObjData.Cursor, xOffset, yOffset, 1)
				scui.ResizeBevel(ObjData.HCursor, xOffset, yOffset, 1)
				scui.ResizeBevel(ObjData.PCursor, xOffset, yOffset, 1)
				scui.ResizeBevel(ObjData.DCursor, xOffset, yOffset, 1)
				scui.ResizeBevel(ObjData.Container, xOffset, yOffset, 1)
				scui.ResizeBevel(ObjData.HContainer, xOffset, yOffset, 1)
				scui.ResizeBevel(ObjData.DContainer, xOffset, yOffset, 1)
				scui.ResizeText(ObjData.Text, xOffset, yOffset, 1)
				scui.ResizeText(ObjData.HText, xOffset, yOffset, 1)
				scui.ResizeText(ObjData.PText, xOffset, yOffset, 1)
				scui.ResizeText(ObjData.DText, xOffset, yOffset, 1)

				Local Bevel = scui.IFO[id].oData.Container
				DeleteButton(id)
				MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
							 { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )                  
				If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
            
            scui.ResizeChilds(Obj, xFact, yFact)
			EndIf

			/* MMin, MMax, Value, MinStep */
			/* These tags will cause a rebuild */
			If helpers.FieldIsNil(tags, "mmin"   ) = 0 Then Obj.Values.MMin    = tags.MMin
			If helpers.FieldIsNil(tags, "mmax"   ) = 0 Then Obj.Values.MMax    = tags.MMax
			If helpers.FieldIsNil(tags, "value"  ) = 0 Then Obj.Values.Current = tags.Value
			If helpers.FieldIsNil(tags, "minstep") = 0 Then Obj.Values.MinStep = tags.MinStep

			/* ScrollerType */
			If helpers.FieldIsNil(tags, "scrollertype") = 0 Then Obj.Type = tags.ScrollerType

			/* ASPECT */
			/* Cursor, HCursor, PCursor, DCursor */
			If helpers.FieldIsNil(tags, "cursor" ) = 0 Then ObjData.Cursor  = scui.NewBevel(ObjData.Cursor, tags.Cursor, 1)
			If helpers.FieldIsNil(tags, "hcursor") = 0 Then ObjData.HCursor = scui.NewBevel(ObjData.HCursor, tags.HCursor, 1)
			If helpers.FieldIsNil(tags, "pcursor") = 0 Then ObjData.PCursor = scui.NewBevel(ObjData.PCursor, tags.PCursor, 1)
			If helpers.FieldIsNil(tags, "dcursor") = 0 Then ObjData.DCursor = scui.NewBevel(ObjData.DCursor, tags.DCursor, 1)
			
			/* Container, HContainer, DContainer */
			If helpers.FieldIsNil(tags, "container" ) = 0 Then ObjData.Container  = scui.NewBevel(ObjData.Container, tags.Container, 1)
			If helpers.FieldIsNil(tags, "hcontainer") = 0 Then ObjData.HContainer = scui.NewBevel(ObjData.HContainer, tags.HContainer, 1)
			If helpers.FieldIsNil(tags, "dcontainer") = 0 Then ObjData.DContainer = scui.NewBevel(ObjData.DContainer, tags.DContainer, 1)
			
			/* Text, HText, PText, DText */
			If helpers.FieldIsNil(tags, "text"  ) = 0 Then ObjData.Text   = scui.NewText (ObjData.Text , tags.Text, 1)
			If helpers.FieldIsNil(tags, "htext" ) = 0 Then ObjData.HText  = scui.NewText (ObjData.HText , tags.HText, 1)
			If helpers.FieldIsNil(tags, "ptext" ) = 0 Then ObjData.PText  = scui.NewText (ObjData.PText , tags.PText, 1)
			If helpers.FieldIsNil(tags, "dtext" ) = 0 Then ObjData.DText  = scui.NewText (ObjData.DText , tags.DText, 1)
         
         /* CursorText */
         If helpers.FieldIsNil(tags, "cursortext") = 0
            ObjData.Text  = scui.NewText(ObjData.Text,  tags.CursorText, 1)
            ObjData.HText = scui.NewText(ObjData.HText, tags.CursorText, 1)
            ObjData.PText = scui.NewText(ObjData.PText, tags.CursorText, 1)
            ObjData.DText = scui.NewText(ObjData.DText, tags.CursorText, 1)
         EndIf
         
         /* ACTIONS */
		   /* Actions.<Event> = 0 --> Remove the current assigned function        */
         /* OnChange, OnDrag                                                    */
			If helpers.FieldIsNil(tags, "actions") = 0
				 If helpers.FieldIsNil(tags.Actions, "onchange") = 0
					  If tags.Actions.OnChange = 0 Then Obj.Actions.OnChange = nil Else Obj.Actions.OnChange = tags.Actions.OnChange
				 EndIf
				 If helpers.FieldIsNil(tags.Actions, "ondrag"  ) = 0
					  If tags.Actions.OnDrag = 0 Then Obj.Actions.OnDrag = 0 Else Obj.Actions.OnDrag   = tags.Actions.OnDrag
				 EndIf
			EndIf
            
			/* Check if we have to rebuild the objct */
			If helpers.FieldIsNil(tags, "scrollertype") = 0 Or helpers.FieldIsNil(tags, "mmin") = 0 Or helpers.FieldIsNil(tags, "mmax") = 0 Or helpers.FieldIsNil(tags, "value") = 0 Or  helpers.FieldIsNil(tags, "minstep") = 0 Or helpers.FieldIsNil(tags, "size") = 0
				scui.NewObject( nil, nil, nil, nil, nil, nil, nil, nil, id )
			EndIf

      Case #IFOCLASS_SCROLLER
      ;------------------------------------------------------------------------
		
         /* POSITION */
			If helpers.FieldIsNil(tags, "position") = 0
				Local xOffset, yOffset = 0, 0

				If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.Container.Position.x
				If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.Container.Position.y
				 
				scui.MoveBevel(ObjData.Cursor, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.HCursor, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.PCursor, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.DCursor, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.Container, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.HContainer, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.DContainer, xOffset, yOffset, 1)
				scui.MoveText(ObjData.Text, xOffset, yOffset, 1)
				scui.MoveText(ObjData.HText, xOffset, yOffset, 1)
				scui.MoveText(ObjData.PText, xOffset, yOffset, 1)
				scui.MoveText(ObjData.DText, xOffset, yOffset, 1)

            Obj.CursorArea.Position.x = Obj.CursorArea.Position.x + xOffset
            Obj.CursorArea.Position.y = Obj.CursorArea.Position.y + yOffset
            
				Local Bevel = scui.IFO[id].CursorArea
				DeleteButton(id)
				MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
						  { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )
				If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
            
				; Se esistono sposto i pulsanti
				/* Sposta tutti i Child presenti nel controllo                   */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					Local ChildData = scui.Get(ChildID)
					Local NewPos = { x = ChildData.Position.x + xOffset,
					                 y = ChildData.Position.y + yOffset }
					scui.Set(ChildID, { Position = NewPos })
   			Next

				
            scui.MoveChilds(Obj, xOffset, yOffset)
			EndIf

			/* SIZE */
			If helpers.FieldIsNil(tags, "size") = 0
				Local xOffset, yOffset = 0, 0
				Local xFact, yFact = 1, 1    
				If helpers.FieldIsNil(tags.Size, "x") = 0
               xOffset = tags.Size.x - ObjData.Container.Size.x
               xFact = tags.Size.x / ObjData.Container.Size.x
            EndIf
				If helpers.FieldIsNil(tags.Size, "y") = 0
               yOffset = tags.Size.y - ObjData.Container.Size.y
               yFact = tags.Size.y / ObjData.Container.Size.y
            EndIf
			  
				scui.ResizeBevel(ObjData.Container, xOffset, yOffset, 1)

            Obj.CursorArea.Size.x = Obj.CursorArea.Size.x + xOffset
            Obj.CursorArea.Size.y = Obj.CursorArea.Size.y + yOffset

				Local Bevel = scui.IFO[id].CursorArea
				DeleteButton(id)
				MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
							 { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )                  
				If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(id)
            
            scui.ResizeChilds(Obj, xFact, yFact)

			EndIf

         ; The following 3 tags will cause a rebuild
			If helpers.FieldIsNil(tags, "totalitems"   ) = 0 Then Obj.TotalItems   = tags.TotalItems
			If helpers.FieldIsNil(tags, "visibleitems" ) = 0 Then Obj.VisibleItems = tags.VisibleItems
			If helpers.FieldIsNil(tags, "currentitem"  ) = 0 Then Obj.FirstItem    = tags.CurrentItem
         
			If helpers.FieldIsNil(tags, "arrowstep" ) = 0 Then Obj.ArrowStep = tags.ArrowStep
         If helpers.FieldIsNil(tags, "clickstep" ) = 0 Then Obj.ClickStep = tags.ClickStep
         
         If helpers.FieldIsNil(tags, "textmode"    ) = 0 Then Obj.TextMode    = tags.TextMode
         If helpers.FieldIsNil(tags, "textcontent" ) = 0 Then Obj.TextContent = tags.TextContent
         
         If helpers.FieldIsNil(tags, "handletype" ) = 0 Then Obj.HandleType = tags.HandleType
         
			/* ASPECT */
			/* Cursor, HCursor, PCursor, DCursor */
			If helpers.FieldIsNil(tags, "cursor" ) = 0 Then ObjData.Cursor  = scui.NewBevel(ObjData.Cursor, tags.Cursor, 1)
			If helpers.FieldIsNil(tags, "hcursor") = 0 Then ObjData.HCursor = scui.NewBevel(ObjData.HCursor, tags.HCursor, 1)
			If helpers.FieldIsNil(tags, "pcursor") = 0 Then ObjData.PCursor = scui.NewBevel(ObjData.PCursor, tags.PCursor, 1)
			If helpers.FieldIsNil(tags, "dcursor") = 0 Then ObjData.DCursor = scui.NewBevel(ObjData.DCursor, tags.DCursor, 1)
			
			/* Container, HContainer, DContainer */
			If helpers.FieldIsNil(tags, "container" ) = 0 Then ObjData.Container  = scui.NewBevel(ObjData.Container, tags.Container, 1)
			If helpers.FieldIsNil(tags, "hcontainer") = 0 Then ObjData.HContainer = scui.NewBevel(ObjData.HContainer, tags.HContainer, 1)
			If helpers.FieldIsNil(tags, "dcontainer") = 0 Then ObjData.DContainer = scui.NewBevel(ObjData.DContainer, tags.DContainer, 1)
			
			/* Text, HText, PText, DText */
			If helpers.FieldIsNil(tags, "text"  ) = 0 Then ObjData.Text   = scui.NewText (ObjData.Text , tags.Text, 1)
			If helpers.FieldIsNil(tags, "htext" ) = 0 Then ObjData.HText  = scui.NewText (ObjData.HText , tags.HText, 1)
			If helpers.FieldIsNil(tags, "ptext" ) = 0 Then ObjData.PText  = scui.NewText (ObjData.PText , tags.PText, 1)
			If helpers.FieldIsNil(tags, "dtext" ) = 0 Then ObjData.DText  = scui.NewText (ObjData.DText , tags.DText, 1)
             
         /* ACTIONS */
		   /* Actions.<Event> = 0 --> Remove the current assigned function        */
         /* OnChange, OnDrag                                                    */
			If helpers.FieldIsNil(tags, "actions") = 0
				 If helpers.FieldIsNil(tags.Actions, "onchange") = 0
					  If tags.Actions.OnChange = 0 Then Obj.Actions.OnChange = nil Else Obj.Actions.OnChange = tags.Actions.OnChange
				 EndIf
				 If helpers.FieldIsNil(tags.Actions, "ondrag"  ) = 0
					  If tags.Actions.OnDrag = 0 Then Obj.Actions.OnDrag = 0 Else Obj.Actions.OnDrag   = tags.Actions.OnDrag
				 EndIf
			EndIf
            
			/* Check if we have to rebuild the objct */
			If helpers.FieldIsNil(tags, "totalitems"  ) = 0 Or helpers.FieldIsNil(tags, "visibleitems") = 0 Or helpers.FieldIsNil(tags, "currentitem") = 0 Or helpers.FieldIsNil(tags, "size") = 0
				scui.NewObject( nil, nil, nil, nil, nil, nil, nil, nil, id )
			EndIf

      Case #IFOCLASS_OPTIONS
      ;------------------------------------------------------------------------
         Local Rebuild = 0
         /* POSITION */
         If helpers.FieldIsNil(tags, "position") = 0
            Local xOffset, yOffset = 0, 0

            If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.Container.Position.x
            If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.Container.Position.y

				/* Sposta tutti i Child presenti nel controllo                   */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					Local ChildData = scui.Get(ChildID)
					Local NewPos = { x = ChildData.Position.x + xOffset,
					                 y = ChildData.Position.y + yOffset }
					scui.Set(ChildID, { Position = NewPos })
   			Next
            scui.MoveBevel(ObjData.Container, xOffset, yOffset, 1)
            
            scui.MoveChilds(Obj, xOffset, yOffset)
         EndIf

			/* SIZE */
         If helpers.FieldIsNil(tags, "size") = 0
            Local xOffset, yOffset = 0, 0
            Local xFact, yFact = 1, 1    
            If helpers.FieldIsNil(tags.Size, "x") = 0 Then xOffset = tags.Size.x - ObjData.Container.Size.x
            If helpers.FieldIsNil(tags.Size, "y") = 0 Then yOffset = tags.Size.y - ObjData.Container.Size.y
              
				; Qua non è possibile fare come è stato fatto per la posizione perche'     
				; la dimensione proviene dal flag SwitchWidth, dovrei ridimensionare tutto 
				; in verticale e in orizzontale solo le label                              
            scui.ResizeBevel(ObjData.Container, xOffset, yOffset, 1)
            Rebuild = 1
            
            scui.ResizeChilds(Obj, xFact, yFact)
         EndIf

         /* ASPECT */
         /* Container, SwicthWidth, SwitchPosition, SwitchMode, Rows, Columns */
			/* Options, NSwitch, HSwitch, PSwitch, DSwitch, NLabel, LabelText                    */
			/* SwiNText, SwiHText, SwiPText, SwiDText, Value, Mode                               */
			
			If helpers.FieldIsNil(tags, "container" )   = 0
				ObjData.Container  = scui.NewBevel(ObjData.Container, tags.Container)
				Rebuild = 1
			EndIf

         If helpers.FieldIsNil(tags, "options" ) = 0
            Local original = helpers.CountEntries(Obj.Options)
            Local new = helpers.CountEntries(tags.Options)
            Obj.Options = tags.Options

            ; Se il numero delle opzioni e' il medesimo sostituisce il contenuto
            ; e basta
            If original = new
               Local child_list = Obj.Childs
               ; Se Fullwidth cambia il testo degli switch altrimenti cambia
               ; il testo delle label
               Local cc = Obj.ChildCount
               If Obj.SwitchMode = #OPTSWITCH_FULLWIDTH
                  Local opt_cnt = 0
                  For Local i = 1 To cc
                     Local Child = Obj.Childs[i]
                     If scui.IFO[Child].oClass = #IFOCLASS_SWITCH
                        scui.Set(Child, { AllTexts = { Content = { Values = { tags.Options[opt_cnt] }}}}, 1)
                        opt_cnt = opt_cnt + 1
                     EndIf
                  Next
               Else
                  Local opt_cnt = 0
                  For Local i = 1 To cc
                     Local Child = Obj.Childs[i]
                     If scui.IFO[Child].oClass = #IFOCLASS_LABEL
                        scui.Set(Child, { Text = { Content = { Values = { tags.Options[opt_cnt] }}}}, 1)
                        opt_cnt = opt_cnt + 1
                     EndIf
                  Next               
               EndIf
            Else
               Rebuild = 1
            EndIf
         EndIf

         If helpers.FieldIsNil(tags, "switchwidth" ) = 0 
            Obj.InitialWidth = tags.SwitchWidth
            Rebuild = 1
         EndIf
			
         If helpers.FieldIsNil(tags, "switchposition" ) = 0 
            Obj.SwitchPosition = tags.SwitchPosition
            Rebuild = 1
         EndIf
			
         If helpers.FieldIsNil(tags, "switchmode" ) = 0 
            Obj.SwitchMode = tags.SwitchMode
            Rebuild = 1
         EndIf
			
         If helpers.FieldIsNil(tags, "rows" ) = 0 
            Obj.Rows = tags.Rows
            Rebuild = 1
         EndIf
			
         If helpers.FieldIsNil(tags, "columns" ) = 0 
            Obj.Columns = tags.Columns
            Rebuild = 1
         EndIf
			
         If helpers.FieldIsNil(tags, "nswitch" ) = 0 
            ObjData.NSwitch = tags.NSwitch
				/* Modifica tutti i Child Switch presenti nel controllo             */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_SWITCH Then scui.Set(ChildID, { Bevel = tags.NSwitch })
   			Next
         EndIf

         If helpers.FieldIsNil(tags, "hswitch" ) = 0 
            ObjData.HSwitch = tags.HSwitch
				/* Modifica tutti i Child Switch presenti nel controllo             */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_SWITCH Then scui.Set(ChildID, { HBevel = tags.HSwitch })
   			Next
         EndIf

         If helpers.FieldIsNil(tags, "pswitch" ) = 0 
            ObjData.PSwitch = tags.PSwitch
				/* Modifica tutti i Child Switch presenti nel controllo             */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_SWITCH Then scui.Set(ChildID, { PBevel = tags.PSwitch })
   			Next
         EndIf

         If helpers.FieldIsNil(tags, "dswitch" ) = 0 
            ObjData.DSwitch = tags.DSwitch
				/* Modifica tutti i Child Switch presenti nel controllo             */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_SWITCH Then scui.Set(ChildID, { DNBevel = tags.DSwitch,
																												   DPBevel = tags.DSwitch })
   			Next
         EndIf
			
         If helpers.FieldIsNil(tags, "nlabel" ) = 0 
            ObjData.NLabel = tags.NLabel
				/* Modifica tutti i Child Label presenti nel controllo              */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_LABEL Then scui.Set(ChildID, { Bevel = tags.NLabel })
   			Next
         EndIf

         If helpers.FieldIsNil(tags, "labeltext" ) = 0 
            ObjData.LabelText = tags.LabelText
				/* Modifica tutti i Child Label presenti nel controllo              */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_LABEL Then scui.Set(ChildID, { Text = tags.LabelText })
   			Next
         EndIf

         If helpers.FieldIsNil(tags, "swintext" ) = 0 
            ObjData.SwiNText = tags.SwiNText
				/* Modifica tutti i Child Switch presenti nel controllo             */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_SWITCH Then scui.Set(ChildID, { Text = tags.SwiNText })
   			Next
         EndIf

         If helpers.FieldIsNil(tags, "swihtext" ) = 0 
            ObjData.SwiHText = tags.SwiHText
				/* Modifica tutti i Child Switch presenti nel controllo             */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_SWITCH Then scui.Set(ChildID, { HText = tags.SwiHText })
   			Next
         EndIf

         If helpers.FieldIsNil(tags, "swiptext" ) = 0 
            ObjData.SwiPText = tags.SwiPText
				/* Modifica tutti i Child Switch presenti nel controllo             */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_SWITCH Then scui.Set(ChildID, { PText = tags.SwiPText })
   			Next
         EndIf

         If helpers.FieldIsNil(tags, "swidtext" ) = 0 
            ObjData.SwiDText = tags.SwiDText
				/* Modifica tutti i Child Switch presenti nel controllo             */
				Local CCount = Obj.ChildCount
				Local i
				For i = 1 To CCount
					Local ChildID = Obj.Childs[i]
					If scui.IFO[ChildID].oClass = #IFOCLASS_SWITCH Then scui.Set(ChildID, { DNText = tags.SwiDText,
																													DPText = tags.SwiDText })
   			Next
         EndIf

         If helpers.FieldIsNil(tags, "mode" ) = 0 
            Obj.Mode = tags.Mode
         EndIf

         If helpers.FieldIsNil(tags, "value" ) = 0
				; ATTENZIONE: Qua devo eventualmente lanciare l'evento previsto! 
            Local i = 0
            Local ind = 0
            For i = 1 To Obj.ChildCount
               Local c_id = Obj.Childs[i]
               If scui.IFO[c_id].oClass = #IFOCLASS_SWITCH
						scui.Set(c_id, { Value = tags.value[ind] } )
                  ind = ind + 1
               EndIf
            Next
         EndIf

         /* ACTIONS */
		   /* Actions.<Event> = 0 --> Remove the current assigned function        */
         /* OnChanged                                                           */
         If helpers.FieldIsNil(tags, "actions") = 0
            If helpers.FieldIsNil(tags.Actions, "onchanged") = 0
               If tags.Actions.OnChanged = 0 Then Obj.Actions.OnChanged = nil Else Obj.Actions.OnChanged = tags.Actions.OnChanged
            EndIf
         EndIf

			If helpers.IsNil(redraw) = 0 Then nodrawflag = 1
			If rebuild Then scui.NewObject(nil, nil, nil, nil, nil, nil, nil, nil, id, nodrawflag)
			; *** ATTENZIONE: Queste righe qua sotto, sinceramente, non le capisco...  ***
         ;If scui.IFO[id].Owner <> scui.ActiveWindow Then DisableButton(id) <=== ???
         ; *** FORSE QUA CI VA UN BEL ENABLEOWNER ALTRO CHE! ***

      Case #IFOCLASS_CYCLE
      ;------------------------------------------------------------------------
         Local CycleGad = scui.IFO[Obj.Childs[1]]
			Local CycleGadData = CycleGad.oData
         Local CycleID  = Obj.Childs[1]

			/* POSITION */
         If helpers.FieldIsNil(tags, "position") = 0
            Local xOffset, yOffset = 0, 0

            If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - CycleGadData.Bevel.Position.x
            If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - CycleGadData.Bevel.Position.y
                
            scui.MoveBevel(CycleGadData.Bevel, xOffset, yOffset, 1)
            scui.MoveBevel(CycleGadData.HBevel, xOffset, yOffset, 1)
            scui.MoveBevel(CycleGadData.PBevel, xOffset, yOffset, 1)
            scui.MoveBevel(CycleGadData.DBevel, xOffset, yOffset, 1)
            scui.MoveText(CycleGadData.Text, xOffset, yOffset, 1)
            scui.MoveText(CycleGadData.HText, xOffset, yOffset, 1)
            scui.MoveText(CycleGadData.PText, xOffset, yOffset, 1)
            scui.MoveText(CycleGadData.DText, xOffset, yOffset, 1)
            Obj.ButtonPosition.x = CycleGadData.Bevel.Position.x
            Obj.ButtonPosition.y = CycleGadData.Bevel.Position.y

            Local Bevel = CycleGad.oData.Bevel
            DeleteButton(CycleID)
            MakeButton(CycleID, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
                       { OnMouseOver = scui.HandleObject , OnMouseOut  = scui.HandleObject , OnMouseDown = scui.HandleObject , OnMouseUp   = scui.HandleObject } )                  
            If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(CycleID)
            
            scui.MoveChilds(Obj, xOffset, yOffset)
         EndIf
           
			/* SIZE */
			If helpers.FieldIsNil(tags, "size") = 0
				Local xOffset, yOffset = 0, 0
				Local xFact, yFact = 1, 1
				If helpers.FieldIsNil(tags.Size, "x") = 0
               xOffset = tags.Size.x - CycleGad.oData.Bevel.Size.x
               xFact = tags.Size.x / CycleGad.oData.Bevel.Size.x
            EndIf
				If helpers.FieldIsNil(tags.Size, "y") = 0
               yOffset = tags.Size.y - CycleGad.oData.Bevel.Size.y
               yFact = tags.Size.y / CycleGad.oData.Bevel.Size.y
				EndIf
				; Local Obj = scui.IFO[id].oData
				scui.ResizeBevel(CycleGad.oData.Bevel, xOffset, yOffset, 1)
				scui.ResizeBevel(CycleGad.oData.HBevel, xOffset, yOffset, 1)
				scui.ResizeBevel(CycleGad.oData.PBevel, xOffset, yOffset, 1)
				scui.ResizeBevel(CycleGad.oData.DBevel, xOffset, yOffset, 1)
				scui.ResizeText(CycleGad.oData.Text, xOffset, yOffset, 1)
				scui.ResizeText(CycleGad.oData.HText, xOffset, yOffset, 1)
				scui.ResizeText(CycleGad.oData.PText, xOffset, yOffset, 1)
				scui.ResizeText(CycleGad.oData.DText, xOffset, yOffset, 1)
				Obj.ButtonSize.x = CycleGad.oData.Bevel.Size.x
				Obj.ButtonSize.y = CycleGad.oData.Bevel.Size.y

				Local Bevel = CycleGad.oData.Bevel
				DeleteButton(CycleID)
				MakeButton(CycleID, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
							 { OnMouseOver = scui.HandleObject, OnMouseOut  = scui.HandleObject, OnMouseDown = scui.HandleObject, OnMouseUp   = scui.HandleObject } )                  
				If Obj.Visible = #IFO_HIDDEN Or Obj.Enabled = #IFO_DISABLED Then DisableButton(CycleID)
            
            scui.ResizeChilds(Obj, xFact, yFact)
			EndIf
           
			/* ASPECT */
			/* MenuWidth, GrowDirection, Options, OptionHeight, VisibleOptions */
			If helpers.FieldIsNil(tags, "menuwidth") = 0 Then Obj.ButtonSize.x  = tags.MenuWidth
			If helpers.FieldIsNil(tags, "growdirection") = 0 Then Obj.GrowDirection = tags.GrowDirection
			If helpers.FieldIsNil(tags, "options") = 0
				Obj.Options      = tags.Options
				Obj.OptionsCount = helpers.CountEntries(tags.Options)
            If Obj.CurrentOption > Obj.OptionsCount Then Obj.CurrentOption = Obj.OptionsCount
				scui.Set(CycleID, { AllTexts = { Content = { Values = { Obj.Options[Obj.CurrentOption - 1] } } } })
			EndIf
			If helpers.FieldIsNil(tags, "optionheight") = 0 Then Obj.OptionHeight = tags.OptionHeight
			If helpers.FieldIsNil(tags, "visibleoptions" ) = 0 Then Obj.VisibleOptions = tags.VisibleOptions
			        
			/* Value */
			If helpers.FieldIsNil(tags, "value") = 0
				 If tags.Value <> Obj.CurrentOption
					  If tags.Value < 1 Then tags.Value = 1
					  If tags.Value > Obj.OptionsCount Then tags.Value = Obj.OptionsCount
					  Obj.PreviousOption = Obj.CurrentOption
					  Obj.CurrentOption = tags.Value
					  scui.Set( Obj.Childs[1], { AllTexts = { Content = { Values = { Obj.Options[tags.Value - 1] } } } } )
					  Obj.SelectionFlag = 1
					  If helpers.FieldIsNil(Obj.Actions, "onchanged")=0 Then Obj.Actions.OnChanged( { id = id, event = "OnChanged" } )                
				 EndIf
			EndIf
			/* BevelStructs & TextStructs */
         If helpers.FieldIsNil(tags, "alltexts") = 0
            CycleGadData.Text   = scui.NewText(CycleGadData.Text ,    tags.AllTexts)
            CycleGadData.HText  = scui.NewText(CycleGadData.HText ,   tags.AllTexts)
            CycleGadData.PText  = scui.NewText(CycleGadData.PText ,   tags.AllTexts)
            CycleGadData.DNText = scui.NewText(CycleGadData.DText ,  tags.AllTexts)
            ;CycleGadData.DPText = scui.NewText(CycleGadData.DPText ,  tags.AllTexts)
         EndIf
			If helpers.FieldIsNil(tags, "bevel") = 0 Then CycleGadData.Bevel   = scui.NewBevel(CycleGadData.Bevel,   tags.Bevel,   1)
			If helpers.FieldIsNil(tags, "hbevel") = 0 Then CycleGadData.HBevel  = scui.NewBevel(CycleGadData.HBevel,  tags.HBevel,  1)
			If helpers.FieldIsNil(tags, "pbevel") = 0 Then CycleGadData.PBevel  = scui.NewBevel(CycleGadData.PBevel,  tags.PBevel,  1)
			If helpers.FieldIsNil(tags, "dnbevel") = 0 Then CycleGadData.DNBevel = scui.NewBevel(CycleGadData.DNBevel, tags.DNBevel, 1)
			If helpers.FieldIsNil(tags, "dpbevel") = 0 Then CycleGadData.DPBevel = scui.NewBevel(CycleGadData.DPBevel, tags.DPBevel, 1)
			If helpers.FieldIsNil(tags, "text") = 0 Then CycleGadData.Text    = scui.NewText (CycleGadData.Text ,   tags.Text,   1)
			If helpers.FieldIsNil(tags, "htext") = 0 Then CycleGadData.HText   = scui.NewText (CycleGadData.HText ,  tags.HText,  1)
			If helpers.FieldIsNil(tags, "ptext") = 0 Then CycleGadData.PText   = scui.NewText (CycleGadData.PText ,  tags.PText,  1)
			If helpers.FieldIsNil(tags, "dntext") = 0 Then CycleGadData.DNText  = scui.NewText (CycleGadData.DNText , tags.DNText, 1)
			If helpers.FieldIsNil(tags, "dptext") = 0 Then CycleGadData.DPText  = scui.NewText (CycleGadData.DPText , tags.DPText, 1)
			If helpers.FieldIsNil(tags, "noptionbox") = 0 Then scui.IFO[id].oData.NOptionBox  = scui.NewBevel (scui.IFO[id].oData.NOptionBox , tags.NOptionBox, 1)
			If helpers.FieldIsNil(tags, "hoptionbox") = 0 Then scui.IFO[id].oData.HOptionBox  = scui.NewBevel (scui.IFO[id].oData.HOptionBox , tags.HOptionBox, 1)
			If helpers.FieldIsNil(tags, "poptionbox") = 0 Then scui.IFO[id].oData.POptionBox  = scui.NewBevel (scui.IFO[id].oData.POptionBox , tags.POptionBox, 1)
			If helpers.FieldIsNil(tags, "noptiontext") = 0 Then scui.IFO[id].oData.NOptionText  = scui.NewText (scui.IFO[id].oData.NOptionText , tags.NOptionText, 1)
			If helpers.FieldIsNil(tags, "hoptiontext") = 0 Then scui.IFO[id].oData.HOptionText  = scui.NewText (scui.IFO[id].oData.HOptionText , tags.HOptionText, 1)
			If helpers.FieldIsNil(tags, "poptiontext") = 0 Then scui.IFO[id].oData.POptionText  = scui.NewText (scui.IFO[id].oData.POptionText , tags.POptionText, 1)
			If helpers.FieldIsNil(tags, "nscrollerbox") = 0 Then scui.IFO[id].oData.NScrollerBox  = scui.NewBevel (scui.IFO[id].oData.NScrollerBox , tags.NScrollerBox, 1)
			If helpers.FieldIsNil(tags, "hscrollerbox") = 0 Then scui.IFO[id].oData.HScrollerBox  = scui.NewBevel (scui.IFO[id].oData.HScrollerBox , tags.HScrollerBox, 1)
			If helpers.FieldIsNil(tags, "dscrollerbox") = 0 Then scui.IFO[id].oData.DScrollerBox  = scui.NewBevel (scui.IFO[id].oData.DScrollerBox , tags.DScrollerBox, 1)
			If helpers.FieldIsNil(tags, "nscrollercurs") = 0 Then scui.IFO[id].oData.NScrollerCurs  = scui.NewBevel (scui.IFO[id].oData.NScrollerCurs , tags.NScrollerCurs, 1)
			If helpers.FieldIsNil(tags, "hscrollercurs") = 0 Then scui.IFO[id].oData.HScrollerCurs  = scui.NewBevel (scui.IFO[id].oData.HScrollerCurs , tags.HScrollerCurs, 1)
			If helpers.FieldIsNil(tags, "pscrollercurs") = 0 Then scui.IFO[id].oData.PScrollerCurs  = scui.NewBevel (scui.IFO[id].oData.PScrollerCurs , tags.PScrollerCurs, 1)
			If helpers.FieldIsNil(tags, "dscrollercurs") = 0 Then scui.IFO[id].oData.DScrollerCurs  = scui.NewBevel (scui.IFO[id].oData.DScrollerCurs , tags.DScrollerCurs, 1)
			If helpers.FieldIsNil(tags, "nscrollertext") = 0 Then scui.IFO[id].oData.NScrollerText  = scui.NewText (scui.IFO[id].oData.NScrollerText , tags.NScrollerText, 1)
			If helpers.FieldIsNil(tags, "hscrollertext") = 0 Then scui.IFO[id].oData.HScrollerText  = scui.NewText (scui.IFO[id].oData.HScrollerText , tags.HScrollerText, 1)
			If helpers.FieldIsNil(tags, "pscrollertext") = 0 Then scui.IFO[id].oData.PScrollerText  = scui.NewText (scui.IFO[id].oData.PScrollerText , tags.PScrollerText, 1)
			If helpers.FieldIsNil(tags, "dscrollertext") = 0 Then scui.IFO[id].oData.DScrollerText  = scui.NewText (scui.IFO[id].oData.DScrollerText , tags.DScrollerText, 1)
			If helpers.FieldIsNil(tags, "container") = 0 Then scui.IFO[id].oData.Container  = scui.NewBevel (scui.IFO[id].oData.Container , tags.Container, 1)

         /* ACTIONS */
		   /* Actions.<Event> = 0 --> Remove the current assigned function        */
         /* OnChanged, OnReleased                                               */
         If helpers.FieldIsNil(tags, "actions") = 0
            If helpers.FieldIsNil(tags.Actions, "onreleased") = 0
               If tags.Actions.OnReleased = 0 Then Obj.Actions.OnReleased = nil Else Obj.Actions.OnReleased = tags.Actions.OnReleased
            EndIf
            If helpers.FieldIsNil(tags.Actions, "onchanged" ) = 0
               If tags.Actions.OnChanged = 0 Then Obj.Actions.OnChanged  = nil Else Obj.Actions.OnChanged  = tags.Actions.OnChanged
            EndIf
         EndIf
            
      Case #IFOCLASS_LISTVIEW
		;------------------------------------------------------------------------
         Local Rebuild = False
			/* POSITION */
         If helpers.FieldIsNil(tags, "position") = 0
            Local xOffset, yOffset = 0, 0

            If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.Container.Position.x
            If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.Container.Position.y
                
            scui.MoveBevel(ObjData.Container, xOffset, yOffset, 1)
				
            /* Sposto tutti i figli */
				Local ccnt = Obj.ChildCount
				Local i = 0
				For i = 1 To ccnt
					Local cid = Obj.Childs[i]
					Local cobj = scui.Get(cid)
					Local new_x = cobj.Position.x + xOffset
					Local new_y = cobj.Position.y + yOffset
					scui.Set(cid, { Position = { x = new_x, y = new_y } } )
				Next
				
				/* Se esiste sposto anche lo scroller */
				If helpers.FieldIsNil(Obj, "scrollerid") = 0
					Local sid = Obj.ScrollerId
					Local sobj = scui.Get(sid)
					Local new_x = sobj.Position.x + xOffset
					Local new_y = sobj.Position.y + yOffset
					scui.Set(sid, { Position = { x = new_x, y = new_y } } )				
				EndIf
            
            scui.MoveChilds(Obj, xOffset, yOffset)
         EndIf
         
         /* SIZE */
         If helpers.FieldIsNil(tags, "size") = 0
            Local xOffset, yOffset = 0, 0
            Local xFact, yFact = 1, 1
            If helpers.FieldIsNil(tags.Size, "x") = 0
               xOffset = tags.Size.x - ObjData.Container.Size.x
               xFact = tags.Size.x / ObjData.Container.Size.x
            EndIf
            If helpers.FieldIsNil(tags.Size, "y") = 0
               yOffset = tags.Size.y - ObjData.Container.Size.y
               yFact = tags.Size.y / ObjData.Container.Size.y
            EndIf
                
            scui.ResizeBevel(ObjData.Container, xOffset, yOffset, 1)
            Rebuild = True
            
            scui.ResizeChilds(Obj, xFact, yFact)
         EndIf

			/* ASPECT */
			/* RowHeight, FieldNames, Entries, Sizes, Selected, Mode, Container */
			If helpers.FieldIsNil(tags, "rowheight") = 0
				Obj.RowHeight = tags.RowHeight
				Rebuild = True
			EndIf
			If helpers.FieldIsNil(tags, "fieldnames") = 0
				Local nncnt = helpers.CountEntries(tags.fieldnames)
				Local colcnt = Obj.FieldCount
				If nncnt < colcnt Then colcnt = nncnt
				Local i = 0
				For i = 1 To colcnt
					Obj.FieldNames[i-1] = tags.FieldNames[i-1]
					Local cid = Obj.Childs[i]
					scui.Set(cid, { AllTexts = { Content = { Values = { tags.FieldNames[i-1] } } } } )
				Next
			EndIf
			If helpers.FieldIsNil(tags, "entries") = 0
				Obj.Entries = tags.Entries
				Obj.Selected = { }
				Rebuild = True
			EndIf
			If helpers.FieldIsNil(tags, "sizes") = 0
				Obj.Sizes = tags.Sizes
				Rebuild = True
			EndIf
			If helpers.FieldIsNil(tags, "selected") = 0
				Obj.Selected = tags.Selected
				Rebuild = True
			EndIf
         If helpers.FieldIsNil(tags, "mode") = 0 Then Obj.Mode = tags.Mode
         If helpers.FieldIsNil(tags, "container") = 0 Then ObjData.Container  = scui.NewBevel (ObjData.Container , tags.Container, 1)

         /* NScrollerBox, HScrollerBox, DScrollerBox                           */
         /* NScrollerCursor, HScrollerCursor, PScrollerCursor, DScrollerCursor */
         /* NScrollerText, HScrollerText, PScrollerText, DScrollerText         */
         /* NHeaderBox, HHeaderBox, PHeaderBox, DHeaderBox                     */
         /* NHeaderText, HHeaderText, PHeaderText, DHeaderText                 */
         /* NChoiceBox, HChoiceBox, PChoiceBox                                 */
         /* NChoiceText, HChoiceText, PChoiceText                              */
         Local ExScr = (helpers.FieldIsNil(Obj, "scrollerid") = 0)
         If helpers.FieldIsNil(tags, "nscrollerbox") = 0
            ObjData.NScrollerBox  = scui.NewBevel (ObjData.NScrollerBox , tags.NScrollerBox, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { Container = ObjData.NScrollerBox })
         EndIf
         If helpers.FieldIsNil(tags, "hscrollerbox") = 0
            ObjData.HScrollerBox  = scui.NewBevel (ObjData.HScrollerBox , tags.HScrollerBox, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { HContainer = ObjData.HScrollerBox })
         EndIf
         If helpers.FieldIsNil(tags, "dscrollerbox") = 0
            ObjData.DScrollerBox  = scui.NewBevel (ObjData.DScrollerBox , tags.DScrollerBox, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { DContainer = ObjData.DScrollerBox })
         EndIf
         If helpers.FieldIsNil(tags, "nscrollercursor") = 0
            ObjData.NScrollerCursor  = scui.NewBevel (ObjData.NScrollerCursor , tags.NScrollerCursor, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { Cursor = ObjData.NScrollerCursor })
         EndIf
         If helpers.FieldIsNil(tags, "hscrollercursor") = 0
            ObjData.HScrollerCursor  = scui.NewBevel (ObjData.HScrollerCursor , tags.HScrollerCursor, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { HCursor = ObjData.HScrollerCursor })
         EndIf
         If helpers.FieldIsNil(tags, "pscrollercursor") = 0
            ObjData.PScrollerCursor  = scui.NewBevel (ObjData.PScrollerCursor , tags.PScrollerCursor, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { PCursor = ObjData.PScrollerCursor })
         EndIf
         If helpers.FieldIsNil(tags, "dscrollercursor") = 0
            ObjData.DScrollerCursor  = scui.NewBevel (ObjData.DScrollerCursor , tags.DScrollerCursor, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { DCursor = ObjData.DScrollerCursor })
         EndIf
         If helpers.FieldIsNil(tags, "nscrollertext") = 0
            ObjData.NScrollerText  = scui.NewText (ObjData.NScrollerText , tags.NScrollerText, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { Text = ObjData.NScrollerText })
         EndIf
         If helpers.FieldIsNil(tags, "hscrollertext") = 0
            ObjData.HScrollerText  = scui.NewText (ObjData.HScrollerText , tags.HScrollerText, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { HText = ObjData.HScrollerText })
         EndIf
         If helpers.FieldIsNil(tags, "pscrollertext") = 0
            ObjData.PScrollerText  = scui.NewText (ObjData.PScrollerText , tags.PScrollerText, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { PText = ObjData.PScrollerText })
         EndIf
         If helpers.FieldIsNil(tags, "dscrollertext") = 0
            ObjData.DScrollerText  = scui.NewText (ObjData.DScrollerText , tags.DScrollerText, 1)
            If ExScr Then scui.Set(Obj.ScrollerId, { DText = ObjData.DScrollerText })
         EndIf
         /* Nel caso degli header ho scelto il rebuild perche' nel caso in cui */
         /* venissero modificate piu' di una tag il ciclo sarebbe molto piu'   */
         /* dispendioso di un rebuild                                          */
         If helpers.FieldIsNil(tags, "nheaderbox") = 0
            ObjData.NHeaderBox  = scui.NewBevel (ObjData.NHeaderBox , tags.NHeaderBox, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "hheaderbox") = 0
            ObjData.HHeaderBox  = scui.NewBevel (ObjData.HHeaderBox , tags.HHeaderBox, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "pheaderbox") = 0
            ObjData.PHeaderBox  = scui.NewBevel (ObjData.PHeaderBox , tags.PHeaderBox, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "dheaderbox") = 0
            ObjData.DHeaderBox  = scui.NewBevel (ObjData.DHeaderBox , tags.DHeaderBox, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "nheadertext") = 0
            ObjData.NHeaderText  = scui.NewText (ObjData.NHeaderText , tags.NHeaderText, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "hheadertext") = 0
            ObjData.HHeaderText  = scui.NewText (ObjData.HHeaderText , tags.HHeaderText, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "pheadertext") = 0
            ObjData.PHeaderText  = scui.NewText (ObjData.PHeaderText , tags.PHeaderText, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "dheadertext") = 0
            ObjData.DHeaderText  = scui.NewText (ObjData.DHeaderText , tags.DHeaderText, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "nchoicebox") = 0
            ObjData.NChoiceBox  = scui.NewBevel (ObjData.NChoiceBox , tags.NChoiceBox, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "hchoicebox") = 0
            ObjData.HChoiceBox  = scui.NewBevel (ObjData.HChoiceBox , tags.HChoiceBox, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "pchoicebox") = 0
            ObjData.PChoiceBox  = scui.NewBevel (ObjData.PChoiceBox , tags.PChoiceBox, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "nchoicetext") = 0
            ObjData.NChoiceText  = scui.NewText (ObjData.NChoiceText , tags.NChoiceText, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "hchoicetext") = 0
            ObjData.HChoiceText  = scui.NewText (ObjData.HChoiceText , tags.HChoiceText, 1)
            Rebuild = True
         EndIf
         If helpers.FieldIsNil(tags, "pchoicetext") = 0
            ObjData.PChoiceText  = scui.NewText (ObjData.PChoiceText , tags.PChoiceText, 1)
            Rebuild = True
         EndIf

         /* ACTIONS */
		   /* Actions.<Event> = 0 --> Remove the current assigned function        */
         /* OnChanged, OnReleased                                               */
         If helpers.FieldIsNil(tags, "actions") = 0
            If helpers.FieldIsNil(tags.Actions, "onchanged" ) = 0 
               If tags.Actions.OnChanged = 0 Then Obj.Actions.OnChanged  = nil Else Obj.Actions.OnChanged  = tags.Actions.OnChanged
            EndIf
         EndIf

         /* Questo sotto e' necessario perche' altrimenti il controllo viene */
         /* tracciato due volte!                                             */
         If helpers.IsNil(Redraw) = 0 Then nodrawflag = 1
         If Rebuild Then scui.NewObject(nil, nil, nil, nil, nil, nil, nil, nil, id, nodrawflag)
         ;If scui.IFO[id].Owner <> scui.ActiveWindow Then DisableButton(id)

      Case #IFOCLASS_TABS
		;------------------------------------------------------------------------
         Local Rebuild = False
			/* POSITION */
         If helpers.FieldIsNil(tags, "position") = 0
            Local xOffset, yOffset = 0, 0

            If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.BigContainer.Position.x
            If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.BigContainer.Position.y
                
            scui.MoveBevel(ObjData.BigContainer, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.SmallContainer, xOffset, yOffset, 1)
				scui.MoveBevel(ObjData.ContentFrame, xOffset, yOffset, 1)
				
            /* Sposto il Cycle */
				Local cobj = scui.Get(Obj.PageSelectorID)
				Local new_x = cobj.Position.x + xOffset
				Local new_y = cobj.Position.y + yOffset
				scui.Set(Obj.PageSelectorID, { Position = { x = new_x, y = new_y } } )
				
				/* Sposto tutti i Gadget */
				Local pagecnt = Obj.PageCount - 1
				Local p
				For p = 0 To pagecnt
					Local ccnt = helpers.CountEntries(Obj.TabChilds[p]) - 1
					Local i = 0
					For i = 0 To ccnt
						Local cid = Obj.TabChilds[p][i].id
						Local cobj = scui.Get(cid)
						Local new_x = cobj.Position.x + xOffset
						Local new_y = cobj.Position.y + yOffset
						scui.Set(cid, { Position = { x = new_x, y = new_y } } )
					Next
				Next
            
            scui.MoveChilds(Obj, xOffset, yOffset)
         EndIf
			
			/* SIZE */
         /*** NOT SUPPORTED AT THIS STAGE ***/
         If helpers.FieldIsNil(tags, "size") = 0
				DebugPrint("TABS Gadget Resize: Not Supported at this stage! CHILDS Resize not supported too!!!")
			EndIf

			/* NSelBox, HSelBox, PSelBox, DSelBox                               */
			If helpers.FieldIsNil( tags, "nselbox" ) = 0
				Obj.NSelBox = scui.NewBevel(Obj.NSelBox, tags.NSelBox, 1)
				scui.Set(Obj.PageSelectorId, { Bevel = tags.NSelBox } )
			EndIf
			If helpers.FieldIsNil( tags, "nselbox" ) = 0
				Obj.HSelBox = scui.NewBevel(Obj.HSelBox, tags.NSelBox, 1)
				scui.Set(Obj.PageSelectorId, { HBevel = tags.HSelBox } )
			EndIf
			If helpers.FieldIsNil( tags, "nselbox" ) = 0
				Obj.PSelBox = scui.NewBevel(Obj.PSelBox, tags.NSelBox, 1)
				scui.Set(Obj.PageSelectorId, { PBevel = tags.PSelBox } )
			EndIf
			If helpers.FieldIsNil( tags, "nselbox" ) = 0
				Obj.DSelBox = scui.NewBevel(Obj.DSelBox, tags.NSelBox, 1)
				scui.Set(Obj.PageSelectorId, { DBevel = tags.DSelBox } )
			EndIf

			/* NSelText, HSelText, PSelText, DSelText                               */
			If helpers.FieldIsNil( tags, "nseltext" ) = 0
				Obj.NSelText = scui.NewText(Obj.NSelText, tags.NSelText, 1)
				scui.Set(Obj.PageSelectorId, { Text = tags.NSelText } )
			EndIf
			If helpers.FieldIsNil( tags, "nseltext" ) = 0
				Obj.HSelText = scui.NewText(Obj.HSelText, tags.NSelText, 1)
				scui.Set(Obj.PageSelectorId, { HText = tags.HSelText } )
			EndIf
			If helpers.FieldIsNil( tags, "nseltext" ) = 0
				Obj.PSelText = scui.NewText(Obj.PSelText, tags.NSelText, 1)
				scui.Set(Obj.PageSelectorId, { PText = tags.PSelText } )
			EndIf
			If helpers.FieldIsNil( tags, "nseltext" ) = 0
				Obj.DSelText = scui.NewText(Obj.DSelText, tags.NSelText, 1)
				scui.Set(Obj.PageSelectorId, { DText = tags.DSelText } )
			EndIf

			/* Page Names */
			If helpers.FieldIsNil( tags, "pagenames" ) = 0
				Local pages = Obj.PageCount
				Local newpages = helpers.CountEntries(tags.PageNames)
				Local endloop = pages - 1
				If newpages < pages Then endloop = newpages - 1

				Local i
				For i = 0 To endloop
					Obj.PageNames[i] = tags.PageNames[i]
				Next
				scui.Set(Obj.PageSelectorId, { Options = tags.PageNames } )
			EndIf
			
			/* BigContainer, SmallContainer, ContentFrame                       */
			If helpers.FieldIsNil(tags, "bigcontainer") = 0 Then ObjData.BigContainer = scui.NewBevel(ObjData.BigContainer, tags.BigContainer, 1)
			If helpers.FieldIsNil(tags, "smallcontainer") = 0 Then ObjData.SmallContainer = scui.NewBevel(ObjData.SmallContainer, tags.SmallContainer, 1)
			If helpers.FieldIsNil(tags, "contentframe") = 0 Then ObjData.ContentFrame = scui.NewBevel(ObjData.ContentFrame, tags.ContentFrame, 1)

         /* Questo sotto e' necessario perche' altrimenti il controllo viene */
         /* tracciato due volte!                                             */
         If helpers.IsNil(Redraw) = 0 Then nodrawflag = 1
         If Rebuild Then scui.NewObject(nil, nil, nil, nil, nil, nil, nil, nil, id, nodrawflag)
		
      Case #IFOCLASS_IMAGE
		;------------------------------------------------------------------------
         Local Rebuild = False
         /* POSITION */
         If helpers.FieldIsNil(tags, "position") = 0
            Local xOffset, yOffset = 0, 0
            If helpers.FieldIsNil(tags.Position, "x") = 0 Then xOffset = tags.Position.x - ObjData.Container.Position.x
            If helpers.FieldIsNil(tags.Position, "y") = 0 Then yOffset = tags.Position.y - ObjData.Container.Position.y
            scui.MoveBevel(ObjData.Container, xOffset, yOffset, 1)
            
            Local Bevel = ObjData.Container
            DeleteButton(id)
            MakeButton(id, #SIMPLEBUTTON, Bevel.Position.x, Bevel.Position.y, Bevel.Size.x, Bevel.Size.y, 
                           { OnMouseOver = scui.HandleObject, OnMouseOut  = scui.HandleObject, OnMouseDown = scui.HandleObject, OnMouseUp   = scui.HandleObject } )                  
             If (Obj.Visible = #IFO_HIDDEN) Or (Obj.Enabled = #IFO_DISABLED) Then DisableButton(id)
             
             scui.MoveChilds(Obj, xOffset, yOffset)
         EndIf

         /* SIZE */
         If helpers.FieldIsNil(tags, "size") = 0
            Local xOffset, yOffset = 0, 0
            Local xFact, yFact = 1, 1
            If helpers.FieldIsNil(tags.Size, "x") = 0
               xOffset = tags.Size.x - ObjData.Container.Size.x
               xFact = tags.Size.x / ObjData.Container.Size.x
            EndIf
            If helpers.FieldIsNil(tags.Size, "y") = 0
               yOffset = tags.Size.y - ObjData.Container.Size.y
               yFact = tags.Size.y / ObjData.Container.Size.y
            EndIf
            
            scui.ResizeBevel(ObjData.Container, xOffset, yOffset, 1)
            Local Bevel = ObjData.Container
            Rebuild = True
            
            scui.ResizeChilds(Obj, xFact, yFact)
         EndIf

         /* ASPECT */
			If helpers.FieldIsNil(tags, "container") = 0 Then ObjData.Container = scui.NewBevel(ObjData.Container, tags.Container, 1)
			If helpers.FieldIsNil(tags, "hcontainer") = 0 Then ObjData.HContainer = scui.NewBevel(ObjData.HContainer, tags.HContainer, 1)
         If helpers.FieldIsNil(tags, "resize") = 0
            Obj.ResizeMode = tags.Resize
            Rebuild = True
         EndIf

         /* OFFSET */
         If helpers.FieldIsNil(tags, "offset") = 0
            If helpers.FieldIsNil(tags.Offset, "x") = 0 Then Obj.XOffset = tags.Offset.x
            If helpers.FieldIsNil(tags.Offset, "y") = 0 Then Obj.YOffset = tags.Offset.y
         EndIf
			
			/* PICTURE */
			If helpers.FieldIsNil(tags, "image") = 0
				Obj.ImageFile = tags.Image
				Rebuild = True
			EndIf

         /* EVENTS */
         If helpers.FieldIsNil(tags, "ondown") = 0
            If GetType(tags.OnDown) = #STRING
               Obj.Actions.OnDown = Nil
            Else
               Obj.Actions.OnDown = tags.OnDown
            EndIf
         EndIf

         If helpers.FieldIsNil(tags, "onup") = 0
            If GetType(tags.OnUp) = #STRING
               Obj.Actions.OnUp = Nil
            Else
               Obj.Actions.OnUp = tags.OnUp
            EndIf
         EndIf
         
         If helpers.FieldIsNil(tags, "onin") = 0
            If GetType(tags.OnIn) = #STRING
               Obj.Actions.OnIn = Nil
            Else
               Obj.Actions.OnIn = tags.OnIn
            EndIf
         EndIf
         
         If helpers.FieldIsNil(tags, "onout") = 0
            If GetType(tags.OnOut) = #STRING
               Obj.Actions.OnOut = Nil
            Else
               Obj.Actions.OnOut = tags.OnOut
            EndIf
         EndIf  
         
         If helpers.IsNil(Redraw) = 0 Then nodrawflag = 1
         If Rebuild Then scui.NewObject(nil, nil, nil, nil, nil, nil, nil, nil, id, nodrawflag)

         ; === MANCA LA VIRTUAL AREA!!! ===
    EndSwitch
    
    If helpers.IsNil(redraw) = 0
        ; quando avro' una funzione di grabbing dello schermo sara' velocissimo
        ; *** Alla fine ci vuole probabilmente anche un refresh delle finestre aperte ***
        If scui.prefs.UseDoubleBuffer = 1
            Local BGFilename = GetTempFileName()
            SaveSnapshot(BGFilename, #SNAPDISPLAY)
            LoadBrush(#MYBRUSH_BACKGROUND1, BGFilename)
            DeleteFile(BGFilename)
            BeginDoubleBuffer
            DisplayBrush(#MYBRUSH_BACKGROUND1, 0, 0)
            scui.RenderObject(id)
            Flip
            EndDoubleBuffer
        Else
            scui.RenderObject(id)
        EndIf
    EndIf
	 
EndFunction
Function scui.MoveBevel(Bevel, x, y, relative) ;------------------| PRIVATE |---
   ; docs updated 28.12.2008

   ; Move the given Bevel structure

   If helpers.IsNil(Bevel) Then Return
    
   Local Position = Bevel.Position
    
   If helpers.IsNil(relative) = 1
      If helpers.IsNil(x) = 0 Then Position.x = x
      If helpers.IsNil(y) = 0 Then Position.y = y
   Else
      If helpers.IsNil(x) = 0 Then Position.x = Position.x + x
      If helpers.IsNil(y) = 0 Then Position.y = Position.y + y
   EndIf
        
EndFunction
Function scui.ResizeBevel(Bevel, x, y, relative) ;----------------| PRIVATE |---
   ; docs updated 28.12.2008

   ; Resize the given Bevel structure

   If helpers.IsNil(Bevel) Then Return
    
   Local Size = Bevel.Size
    
   If helpers.IsNil(relative) = 1
      If helpers.IsNil(x) = 0 Then Size.x = x
      If helpers.IsNil(y) = 0 Then Size.y = y
   Else
      If helpers.IsNil(x) = 0 Then Size.x = Size.x + x
      If helpers.IsNil(y) = 0 Then Size.y = Size.y + y
   EndIf

EndFunction
Function scui.MoveText(Text, x, y, relative) ;--------------------| PRIVATE |---
   ; docs updated 28.12.2008

   ; Move the given Text structure

   If helpers.IsNil(Text) Then Return
    
   Local xSize = Text.Area.xEnd - Text.Area.xStart
   Local ySize = Text.Area.yEnd - Text.Area.yStart
   Local Area  = Text.Area
    
   If helpers.IsNil(relative) = 1
      If helpers.IsNil(x) = 0
         Area.xStart = x
         Area.xEnd   = Area.xStart + xSize
      EndIf
      If helpers.IsNil(y) = 0
         Area.yStart = y
         Area.yEnd   = Area.yStart + ySize
      EndIf
   Else
      If helpers.IsNil(x) = 0
         Area.xStart = Area.xStart + x
         Area.xEnd   = Area.xStart + xSize
      EndIf
      If helpers.IsNil(y) = 0
         Area.yStart = Area.yStart + y
         Area.yEnd   = Area.yStart + ySize
      EndIf
   EndIf
EndFunction
Function scui.ResizeText(Text, x, y, relative) ;------------------| PRIVATE |---
   ; docs updated 28.12.2008

   ; Resize the given Text structure

   If helpers.IsNil(Text) Then Return
    
   Local Area = Text.Area
    
   If helpers.IsNil(relative) = 1
      If helpers.IsNil(x) = 0 Then Area.xEnd = x
      If helpers.IsNil(y) = 0 Then Area.yEnd = y
   Else
      If helpers.IsNil(x) = 0 Then Area.xEnd = Area.xEnd + x
      If helpers.IsNil(y) = 0 Then Area.yEnd = Area.yEnd + y
   EndIf
EndFunction
Function scui.Error(title, description) ;-------------------------| PRIVATE |---
; patchare questa funzione per creare dei LOG anziche' mandare dei messaggi a
; vieDo!!
   ; docs updated 28.12.2008

   ; A simple function to handle errors

   Local Result = SystemRequest(title, description, "CONTINUE|QUIT")
   If Result = 0 Then End()
    
EndFunction
Function scui.SaveTheme(filename) ;---------------------------------------------
   ; docs updated 28.12.2008

   ; Save the current theme definition
   ; === IMPLEMENTARE UN CONTROLLO DI VERSIONE
; *** inoltre usare le nuove funzioni di hollywood per le tabelle ***
    Filez.SaveTable(scui.theme, filename)
EndFunction
Function scui.LoadTheme(filename) ;---------------------------------------------
   ; docs updated 28.12.2008

   ; Load a new theme definition
   ; === IMPLEMENTARE UN CONTROLLO DI VERSIONE
; *** inoltre usare le nuove funzioni di hollywood per le tabelle ***

    Filez.LoadTable(scui.theme, filename)
EndFunction
Function scui.SavePrefs(filename) ;---------------------------------------------
   ; docs updated 28.12.2008

   ; Save the current Scui preferences
; *** inoltre usare le nuove funzioni di hollywood per le tabelle ***

   Filez.SaveTable(scui.prefs, filename)
EndFunction
Function scui.LoadPrefs(filename) ;---------------------------------------------
   ; docs updated 28.12.2008

   ; Load the Scui preferences
; *** inoltre usare le nuove funzioni di hollywood per le tabelle ***

   Filez.LoadTable(scui.prefs, filename)
EndFunction
Function scui.Switch_SetText(id, text) ;----------------------------------------
   ; docs updated 28.12.2008

   ; Set all switch's text, <text> is a table of strings, one for each text line
;*** DECODIFICARE ID COME PER LE ALTRE FUNZIONI ***
   ; id = IFO id
   ; text = text table
   Local newText = { Values = text, Lines = helpers.CountEntries(text) } 
   scui.IFO[id].oData.Text.Content.Values   = newText.Values
   scui.IFO[id].oData.Text.Content.Lines    = newText.Lines
   scui.IFO[id].oData.HText.Content.Values  = newText.Values
   scui.IFO[id].oData.HText.Content.Lines   = newText.Lines
   scui.IFO[id].oData.PText.Content.Values  = newText.Values
   scui.IFO[id].oData.PText.Content.Lines   = newText.Lines
   ; --- INDAGARE ---> Potrebbe essere il testo nel cursore degli scroller
   If helpers.FieldIsNil(scui.IFO[id].oData, "dntext") = 0
      scui.IFO[id].oData.DNText.Content.Values = newText.Values
      scui.IFO[id].oData.DNText.Content.Lines  = newText.Lines
   EndIf
   If helpers.FieldIsNil(scui.IFO[id].oData, "dptext") = 0
      scui.IFO[id].oData.DPText.Content.Values = newText.Values
      scui.IFO[id].oData.DPText.Content.Lines  = newText.Lines
   EndIf
EndFunction
Function scui.ResetActionStatus() ;-------------------------------| PRIVATE |---
   ; docs updated 28.12.2008

   ; function used by the Keyboard Handler
   Local c = helpers.CountEntries(scui.Windows)
   For Local i = 0 To c - 1
      scui.Windows[i].ActionStatus = ""
   Next
EndFunction
Function helpers.CloneTable(table) ;--------------------------------------------
   ; docs updated 28.12.2008

   ; function used to clone the given table
   
   If helpers.IsNil(table) Then Return()
   
   Local a, b
   Local dest = {}
   
   ; Process the table recursively...
   a, b = NextItem(table)
   While GetType(a) <> #NIL
      If GetType(b) = #TABLE
         dest[a] = helpers.CloneTable(b)
      Else
         dest[a] = b
      EndIf
      a, b = NextItem(table, a)
   Wend
   Return(dest)
EndFunction
Function helpers.SetTable(Source, Changes, ReturnsNew) ;------------------------
   ; docs updated 28.12.2008

   ; sets all fields found in <Changes> with a corrispondence
   ; in <Source>, returns a new modified table

   ; Se ReturnsNew e' nil oppure True restituisce una nuova tabella
   ; altrimenti modifica direttamente Source
   
   ; *** QUESTA ROUTINE DEVE PRENDERE IL POSTO DEI VARI NEWBEVEL E NEWTEXT ***
   ; *************************************************************************
   ; Questa routine e' decisamente piu' veloce perche' vengono presi in
   ; considerazione solo gli elementi da cambiare e non tutti quelli previsti
   ; per poi cambiare quelli definiti in changes
   ; *************************************************************************
   ; E' possibile variare SOLO gli elementi esistenti in <Source>, non e' possibile
   ; cambiare un elemento da un tipo fisso ad una tabella e viceversa
   ; -------------------------------------------------------------------------
   Local NewTable = {}
   
   If helpers.IsNil(Source) Then Return()
   
   If Not(helpers.IsNil(ReturnsNew))
      If ReturnsNew
         NewTable = helpers.CloneTable(Source)
      Else
         NewTable = Source
      EndIf
   EndIf
   
   If helpers.IsNil(Changes) Then Return(NewTable)
    
   Local index, value
   ; Traverse Changes Table
   index, value = NextItem(Changes)
   While GetType(index) <> #NIL
      If GetType(value) = #TABLE
         If helpers.FieldIsNil(NewTable, index) = 0
            If GetType(NewTable[index]) = #TABLE Then NewTable[index] = helpers.SetTable(NewTable[index], value, True)
         EndIf
      Else
         If GetType(Index) = #STRING
            If helpers.FieldIsNil(NewTable, index) = 0
               NewTable[index] = value
            EndIf
         Else
            NewTable[index] = value
         EndIf
      EndIf
      index, value = NextItem(Changes, index)
   Wend
   Return(NewTable)
EndFunction
Function scui.Layout(name, mode, Area, Options, GadList, Recursive) ; OLETE |---
   ; docs updated 28.12.2008

   ; Used to adjust the position of a list of gadgets inside a target area.

   ; WEIGHT = 0 --> NO DOT RESIZE
   If helpers.IsNil(name) Then Return(GadList)
   If helpers.IsNil(mode) Then Return(GadList)
   If helpers.IsNil(area) Then Return(GadList)
   If helpers.IsNil(gadlist) Then Return(GadList)
   If helpers.IsNil(options) Then Return(GadList)

   If helpers.IsNil(Recursive) = 1
      ; Check if Layout Name Exists
      If helpers.FieldIsNil(scui.LayoutList, name) = 0
         Return(GadList)
      EndIf
   EndIf

   ; Check if Owner is the same for all gadgets
   Local GadCount = helpers.CountEntries(GadList)
   If GadCount < 1 Then Return(GadList)
   Local g
   Local FatherOwner = scui.IFO[GadList[0]].Owner
   For g = 1 To (GadCount - 1)
      If scui.IFO[GadList[g]].Owner <> FatherOwner
         Return(GadList)
      EndIf
   Next
    
   ; Fixed gap?
   Local FixedGap = True
   If helpers.FieldIsNil(Options, "fixedgap") = 0 Then FixedGap = Options.FixedGap
    
   ; Get the Owner's Area
   Local FatherArea
   If FatherOwner = #SCREENID
      FatherArea = { x = 0, y = 0, Width = GetAttribute(#DISPLAY, 0, #ATTRWIDTH), Height = GetAttribute(#DISPLAY, 0, #ATTRHEIGHT)}
   Else
      FatherArea = { x = 0, y = 0, Width = scui.Windows[name].Size.x, Height = scui.Windows[name].Size.y }
   EndIf
    
   Local HGap     = 2
   Local VGap     = 2
   If helpers.FieldIsNil(Options, "vgap") = 0 Then VGap = Options.VGap
   If helpers.FieldIsNil(Options, "hgap") = 0 Then HGap = Options.HGap
    
   Local Columns  = GadCount
   If helpers.FieldIsNil(Options, "columns") = 0 Then Columns = Options.Columns
   Local Rows     = Round((GadCount / Columns) + 0.49)
    
   Local VWeights = {}
   If helpers.FieldIsNil(Options, "vweights") = 1
      Local mw = 1 / GadCount
      Local g
      For g = 1 To GadCount
         VWeights[g-1] = mw
      Next
   Else
      VWeights = Options.VWeights
   EndIf

   Local HWeights = {}
   If helpers.FieldIsNil(Options, "hweights") = 1
      Local mw = 1 / GadCount
      Local g
      For g = 1 To GadCount
         HWeights[g-1] = mw
      Next
   Else
      HWeights = Options.HWeights
   EndIf
    
   Switch mode
      Case #LAYOUTMODE_VERTICAL
         ; VERTICAL LAYOUT
         ; Calcola la larghezza di ogni gadget
         Local HSize = Area.Width
         ; Calcola l'altezza
         ;Local VSize = (Area.Height/GadCount) - VGap * (GadCount - 1)
         ; Ridimensiona & Posiziona i Gadgets
         Local g
         Local x = Area.x
         Local y = Area.y
         AreaH = Area.Height - (GadCount-1) * HGap
         For g = 1 To GadCount
            Local VSize = AreaH * VWeights[g-1]
            scui.Set(GadList[g-1], { Position = { x = x    , y = y },
                                     Size     = { x = HSize - 1, y = VSize - 1 } })
            y = y + VSize + Int(HGap)
         Next
            
      Case #LAYOUTMODE_HORIZONTAL
         ; HORIZONTAL LAYOUT
         ; Calcola la larghezza di ogni gadget
         ;Local HSize = Area.Width
         ; Calcola l'altezza
         Local VSize = Area.Height
         ; Ridimensiona & Posiziona i Gadgets
         Local g
         Local x = Area.x
         Local y = Area.y
         AreaW  = Area.Width  - (GadCount-1) * VGap
         For g = 1 To GadCount
            Local HSize = AreaW * HWeights[g-1]
            scui.Set(GadList[g-1], { Position = { x = x    , y = y },
                                     Size     = { x = HSize - 1, y = VSize - 1} })
            x = x + HSize + Int(VGap)
         Next
       
      Case #LAYOUTMODE_GRID
         Local g = 0
         Local gh
         Local gv
         Local x = Area.x
         Local y = Area.y
         Local xs = x
         Local ys = y
         AreaH = Area.Height - Columns * HGap
         AreaW  = Area.Width  - Rows * VGap

         For gv = 1 To Rows
            ;If g > GadCount Then Break
            x = xs
            Local VSize = AreaH * VWeights[gv-1]
            For gh = 1 To Columns
               g = g + 1
               If g > GadCount Then Break
               Local HSize = AreaW * HWeights[gh-1]
               scui.Set(GadList[g-1], { Position = { x = x    , y = y },
                                        Size     = { x = HSize - 1, y = VSize - 1} })
               x = x + HSize + Int(VGap)
            Next
            y = y + VSize + Int(HGap)   
         Next
            
      Default
         ; MODE NON RICONOSCIUTO!!
         
   EndSwitch

   If helpers.IsNil(Recursive) = 1 Then scui.RedrawObjects(False, FatherOwner)
    
   ; Stores the layout
   scui.LayoutList[name] = { OwnerArea = FatherArea,
                             Area      = Area,
                             Mode      = mode,
                             GadList   = GadList,
                             Owner     = FatherOwner,
                             VGap      = VGap,
                             HGap      = HGap,
                             VWeights  = VWeights,
                             HWeights  = HWeights,
                             Columns   = Columns,
                             FixedGap  = FixedGap }
   Return(GadList)
EndFunction
Function scui.RefreshLayout(Name, Owner, Recursive) ;------------| OBSOLETE |---
   ; docs updated 28.12.2008

   ; Used to recalculate and readjust the specified layout, if <Name> is
   ; nil all defined layouts will be refreshed
   Local w = scui.Win.FindByName(Owner)
   SelectDisplay(w.HWId, True)
   DebugPrint("{Refresh Layout}:", w.HWId, w.Name, "(", Name, Owner, Recursive, ")")
   
   ; Calcola i moltiplicatori in base all'area dell'Owner
   Local SW, SH
   If helpers.IsNil(name) = 0
      ; SOLO IL LAYOUT SPECIFICATO
      ; Se il layout non esiste esce
      If helpers.FieldIsNil(scui.LayoutList, name) = 1 Then Return
      If scui.LayoutList[name].Owner = #SCREENID
         SW = GetAttribute(#DISPLAY, w.HWId, #ATTRWIDTH)
         SH = GetAttribute(#DISPLAY, w.HWId, #ATTRHEIGHT)
      Else
         SW = scui.Windows[scui.LayoutList[name].Owner].Size.x
         SH = scui.Windows[scui.LayoutList[name].Owner].Size.y
      EndIf
      DebugPrint("== GOT SW, SH:", SW, SH, " ==")

      ; Controlla se un refresh e' realmente necessario
      Local lay = scui.LayoutList[Name]
      If (SW <> lay.OwnerArea.Width) Or (SH <> lay.OwnerArea.Height)
         Local newArea = { x = SW / lay.OwnerArea.Width * lay.Area.x, y = SH / lay.OwnerArea.Height * lay.Area.y, Width = SW / lay.OwnerArea.Width * lay.Area.Width, Height = SH / lay.OwnerArea.Height * lay.Area.Height}
         Local newVGap = IIF(lay.FixedGap, lay.VGap, SW / lay.OwnerArea.Width * lay.VGap)
         Local newHGap = IIF(lay.FixedGap, lay.HGap, SH / lay.OwnerArea.Height * lay.HGap)
         Local Opt = { VGap = newVGap,
                       HGap = newHGap,
                       VWeights = lay.VWeights,
                       HWeights = lay.HWeights,
                       Columns  = lay.Columns,
                       FixedGap = lay.FixedGap }
         DebugPrint("* Executing scui.Layout *")
         scui.Layout(Name, lay.Mode, NewArea, Opt, lay.GadList, 1)    
      EndIf
      if helpers.IsNil(Recursive) = 1 Then scui.RedrawObjects()
        
   Else
      DebugPrint("=== REFERESH ALL OWNER'S LAYOUTS ===")
      ; TUTTI I LAYOUT DI OWNER
      Local lcnt = helpers.CountEntries(scui.LayoutList)
      DebugPrint("Layout count:", lcnt)
      If lcnt > 0
         Local i, v
         i, v = NextItem(scui.LayoutList)
         While GetType(i) <> #NIL
            If scui.LayoutList[i].Owner = Owner Then scui.RefreshLayout(i, Owner, 1)
            DebugPrint(i, v)
            i, v = NextItem(scui.LayoutList, i)
         Wend
         scui.RedrawObjects()
      EndIf
   EndIf
EndFunction
Function scui.SafeClipRegion(ClipID, Shape, xStart, yStart, Width, Height) ;---
   ; docs updated 29.12.2008

   ; Create a ClipRegion and adjust coordinates to prevent illegal values.
   ; Used by the system to handle offscreen gadgets

    Local ScreenW = GetAttribute(#DISPLAY, 0, #ATTRWIDTH)
    Local ScreenH = GetAttribute(#DISPLAY, 0, #ATTRHEIGHT)
    If (xStart + Width)  > ScreenW Then Width  = ScreenW - xStart
    If (yStart + Height) > ScreenH Then Height = ScreenH - yStart
    If ((xStart + Width) =< 0)
        xStart = 0
        Width  = 1
    EndIf
    If ((yStart + Height) =< 0)
        yStart = 0
        Height = 1
    EndIf
    If Width  = 0
		Width  = 1
		xStart = xStart - 1
	 EndIf
    If Height = 0
		Height = 1
		yStart = yStart - 1
	 EndIf

    CreateClipRegion(ClipID, Shape, xStart, yStart, Width, Height)
EndFunction
Function scui.NULLFUNC()
EndFunction
Function scui.Win.HandleDropEvent(msg) ;--------------------------| PRIVATE |---
   ; Verifica se c'e' un evento legato alla finestra in cui sono stati droppati
   ; i files
   Local w = scui.Win.FindByHandler(msg.id)

   If Not(helpers.FieldIsNil(scui.Windows[w.id], "ondrop"))
      ; Chiama l'evento associato
      scui.Windows[w.id].OnDrop(msg)
   EndIf

EndFunction
Function scui.Win.HandleResizeEvent(msg) ;------------------------| PRIVATE |---
   ; docs updated 29.12.2008

   ; Used to setup a Gui layout for gui auto-resize when the main Hollywood
   ; window changes.

   ; Se c'è uno stringbox acceso e e sto attivando una finestra diversa
   ; da quella corrente lo disattivo inviandogli un RETURN
   
   If helpers.IsNil(Check) Then Check = False
   
   Local w = scui.Win.FindByHandler(msg.id)
   SelectDisplay(msg.id, True)
   
   If scui.Keyboard[w.Name].Mode = #KEYBOARD_INPUTMODE
      scui.Keyboard_Handler( { key = Chr(10), action = "OnKeyDown", id = msg.id } )
   EndIf
   
   Local ScreenW = GetAttribute(#DISPLAY, msg.id, #ATTRWIDTH)
   Local ScreenH = GetAttribute(#DISPLAY, msg.id, #ATTRHEIGHT)
   Local Force = False
   Local Refresh = False
   
   ; Verifica che il resize sia realmente necessario
   If scui.Windows[w.id].Size[0] = msg.Width
      If scui.Windows[w.id].Size[1] = msg.Height
         ; La dimensione non e' affatto cambiata, esce dalla routine
         Refresh = False
         Return()
      Else
         Refresh = True
      EndIf
   Else
      Refresh = True
   EndIf
   
   ;DebugPrint("SCREEN IS:", ScreenW, ScreenH)
   If ScreenW > scui.Windows[w.id].MaxSize.Width
      ScreenW = scui.Windows[w.id].MaxSize.Width
      Force = True
   EndIf

   If ScreenH > scui.Windows[w.id].MaxSize.Height
      ScreenH = scui.Windows[w.id].MaxSize.Height
      Force = True
   EndIf

   ;If helpers.FieldIsNil(scui, "mainminsize") = 0
   If ScreenW < scui.Windows[w.id].MinSize.Width
      ScreenW = scui.Windows[w.id].MinSize.Width
      Force = True
   EndIf
   If ScreenH < scui.Windows[w.id].MinSize.Height
      ScreenH = scui.Windows[w.id].MinSize.Height
      Force = True
   EndIf
   If Force
      Local xx = GetAttribute(#DISPLAY, msg.id, #ATTRXPOS)
      Local yy = GetAttribute(#DISPLAY, msg.id, #ATTRYPOS)
      Local hw = GetAttribute(#DISPLAY, msg.id, #ATTRHOSTWIDTH)
      Local hh = GetAttribute(#DISPLAY, msg.id, #ATTRHOSTHEIGHT)
      ; HO QUALCHE DUBBIO SULL'UTILITA' DI QUESTE DUE RIGHE QUA SOTTO
      If xx + ScreenW + 20 > hw Then xx = hw - ScreenW - 20
      If yy + ScreenH + 20 > hh Then yy = hh - ScreenH - 20
      If Refresh 
         ChangeDisplaySize(ScreenW, ScreenH, { X = xx, Y = yy })
      EndIf
   EndIf
   ;EndIf
   
   ;NON DOVREBBE SERVIRE PIU'
   ;scui.RefreshLayout( nil, w.Name )
    
   ; Gestione MasterIFOs
   Local mcnt = helpers.CountEntries(scui.MasterIFOs)
   If mcnt > 0
      For Local i = 0 To mcnt - 1
         ; Seleziona solo i  master del display che ha generato l'evento
         If w.Name = scui.IFO[scui.MasterIFOs[i].id].Owner
            If ((ScreenW <> scui.MasterIFOs[i].w) Or (ScreenH <> scui.MasterIFOs[i].h)) Or Force Or Refresh
               Local DeltaX = ScreenW - scui.MasterIFOs[i].w
               Local DeltaY = ScreenH - scui.MasterIFOs[i].h
               Local tmp = scui.Get(scui.MasterIFOs[i].id)
               Local NewSize = { x = tmp.Size.x + DeltaX, y = tmp.Size.y + DeltaY }
               scui.Set(scui.MasterIFOs[i].id, { Size = NewSize }, 1)
               scui.MasterIFOs[i].w = ScreenW
               scui.MasterIFOs[i].h = ScreenH
            EndIf
         EndIf
      Next
   EndIf

   ; Aggiorna la struttura della finestra ridimensionata
   scui.Windows[w.id].Size[0] = msg.width ;GetAttribute(#DISPLAY, msg.id, #ATTRWIDTH)
   scui.Windows[w.id].Size[1] = msg.height ;GetAttribute(#DISPLAY, msg.id, #ATTRHEIGHT)
   
   ; Se definita chiama la funzione utente
   If Not(helpers.FieldIsNil(scui.Windows[w.id], "onsize"))
      ; Chiama l'evento associato
      scui.Windows[w.id].OnSize(msg)
   EndIf
   
   ; Al termine del rendering (che potrebbe essere lungo)
   ; le dimensioni potrebbero essere ulteriormente cambiate
   ; per questo motivo forzo un'altro aggionrmanto
   Local CurrW, CurrH = GetAttribute(#DISPLAY, msg.id, #ATTRWIDTH), GetAttribute(#DISPLAY, msg.id, #ATTRHEIGHT)

   If (CurrW <> msg.Width) Or (CurrH <> msg.Height)
      msg.Width  = CurrW
      msg.Height = CurrH
      scui.Win.HandleResizeEvent(msg)
   EndIf
   ;If Check Then scui.Win.HandleResizeEvent(msg, False)
   
EndFunction
Function scui.Win.HandleMoveEvent(msg) ;--------------------------| PRIVATE |---
   Local w = scui.Win.FindByHandler(msg.id)
   
   If scui.Keyboard[w.Name].Mode = #KEYBOARD_INPUTMODE
      scui.Keyboard_Handler( { key = Chr(10), action = "OnKeyDown", id = msg.id } )
   EndIf
   
   ; Verifica che il move sia realmente necessario
   If scui.Windows[w.id].Position[0] <> msg.x Or scui.Windows[w.id].Position[1] <> msg.y
      ; Aggiorna la struttura della finestra ridimensionata
      scui.Windows[w.id].Position[0] = GetAttribute(#DISPLAY, msg.id, #ATTRXPOS)
      scui.Windows[w.id].Position[1] = GetAttribute(#DISPLAY, msg.id, #ATTRYPOS)
      
      ; Se definita chiama la funzione utente
      If Not(helpers.FieldIsNil(scui.Windows[w.id], "onmove"))
         scui.Windows[w.id].OnMove(msg)
      EndIf
   EndIf
EndFunction
Function scui.Win.HandleActiveEvent(msg) ;------------------------| PRIVATE |---
   Local w = scui.Win.FindByHandler(msg.id)
   
   If scui.Keyboard[w.Name].Mode = #KEYBOARD_INPUTMODE
      scui.Keyboard_Handler( { key = Chr(10), action = "OnKeyDown", id = msg.id } )
   EndIf
   
   ; Localizza la finestra correntemente attiva
   ; che corrisponde con l'ultima finestra di WinOrder
   Local active1 = helpers.CountEntries(scui.WinOrder) - 1
   
   ; Localizza la finestra da attivare in WinOrder
   Local active2 = -1
   For Local i = 0 To (active1 - 1)
      If scui.WinOrder[i] = w.Name
         active2 = i
         Break
      EndIf
   Next
   
   ; Elimina la posizione della finestra da attivare e la pone in ultima posizione
   RemoveItem(scui.WinOrder, active2)
   InsertItem(scui.WinOrder, w.Name)
   
   ; Scorre tutte le finestre dell'applicazione disattivandole
   ; tutte tranne quella attivata
   Local wcnt = helpers.CountEntries(scui.Windows) - 1
   For Local i = 0 To wcnt
      If i = w.id
         scui.Windows[i].Active = True
      Else
         scui.Windows[i].Active = False
      EndIf
   Next
   
   ; Questo trucchetto mi serve per forzare un refresh dei gadget
   scui.SelectedDisplay = w.Name
   scui.JustActivated = True
   
   ; Se definita chiama la funzione utente
   If Not(helpers.FieldIsNil(scui.Windows[w.id], "onactivate"))
      scui.Windows[w.id].OnActivate(msg)
   EndIf
 
EndFunction
Function scui.Win.HandleInactiveEvent(msg) ;----------------------| PRIVATE |---
   Local w = scui.Win.FindByHandler(msg.id)
   
   If scui.Windows[w.id].Modal
      scui.Win.Activate(w.Name)
   EndIf
   
   If scui.Keyboard[w.Name].Mode = #KEYBOARD_INPUTMODE
      scui.Keyboard_Handler( { key = Chr(10), action = "OnKeyDown", id = msg.id } )
   EndIf
   
   ; Scorre tutte le finestre dell'applicazione disattivandole
   Local wcnt = helpers.CountEntries(scui.Windows) - 1
   For Local i = 0 To wcnt
      scui.Windows[i].Active = False
   Next
   
   ; Quando una finestra viene disattivata tutti i suoi gadget in stato hilight
   ; devono essere forzatamente disattivati
   If scui.Windows[w.id].Opened
      Local cnt = scui.IFO.IDCounter
      For Local i = 1 To cnt
         If scui.IFO[i].Owner = w.Name
            If Not(helpers.FieldIsNil(scui.IFO[i], "status"))
               If (scui.IFO[i].Status = #IFOSTATUS_HILIGHTED) And (scui.IFO[i].oName <> "*DELETED*")
                  scui.Set(i, { Status = #IFOSTATUS_NORMAL }, 1)
               EndIf
            EndIf
         EndIf
      Next
   EndIf
   
   ; Se definita chiama la funzione utente
   If Not(helpers.FieldIsNil(scui.Windows[w.id], "ondeactivate"))
      scui.Windows[w.id].OnDeactivate(msg)
   EndIf
 
EndFunction
Function scui.Win.HandleHideEvent(msg) ;--------------------------| PRIVATE |---
   Local w = scui.Win.FindByHandler(msg.id)
   
   If scui.Keyboard[w.Name].Mode = #KEYBOARD_INPUTMODE
      scui.Keyboard_Handler( { key = Chr(10), action = "OnKeyDown", id = msg.id } )
   EndIf
   
   
   ; Se definita chiama la funzione utente
   If Not(helpers.FieldIsNil(scui.Windows[w.id], "onhide"))
      scui.Windows[w.id].OnHide(msg)
   EndIf
EndFunction   
Function scui.Win.HandleShowEvent(msg) ;--------------------------| PRIVATE |---
   Local w = scui.Win.FindByHandler(msg.id)
   
   If scui.Keyboard[w.name].Mode = #KEYBOARD_INPUTMODE
      scui.Keyboard_Handler( { key = Chr(10), action = "OnKeyDown", id = msg.id } )
   EndIf
   
   
   ; Se definita chiama la funzione utente
   If Not(helpers.FieldIsNil(scui.Windows[w.id], "onshow"))
      scui.Windows[w.id].OnShow(msg)
   EndIf
EndFunction   
Function scui.Win.HandleCloseEvent(msg) ;-------------------------| PRIVATE |---
   Local w = scui.Win.FindByHandler(msg.id)
   
   If scui.Keyboard[w.name].Mode = #KEYBOARD_INPUTMODE
      scui.Keyboard_Handler( { key = Chr(10), action = "OnKeyDown", id = msg.id } )
   EndIf
        
   ; Altrimenti chiude la finestra
   If scui.Windows[w.id].AutoClose
      ; *** CREARE UN COMANDO DI CHIUSURA DELLA FINESTRA CHE PRIMA
      ; DISINSTALLA TUTTI GLI HANDLER ALTRIMENTI HOLLYWOOD SI INCAZZA
      ; *** IL COMANDO DI APERTURA INVECE DOVRA' RIPRISTINARLI DOPO
      ; L'APERTURA
      CloseDisplay(w.HWID)
      scui.Windows[w.id].Opened = False
      scui.Win.Activate(#SCREENID)
   EndIf
   
   ; Se definita chiama la funzione utente
   If Not(helpers.FieldIsNil(scui.Windows[w.id], "onclose"))
      scui.Windows[w.id].OnClose(msg)
   EndIf

   ; Se l'evento arriva dal display principale chiude l'applicazione (solo
   ; se AutoEnd e' stato settato a TRUE
   If w.Name = #SCREENID
      If scui.Windows[w.id].AutoEnd Then End
   EndIf

EndFunction   
Function scui.Win.MinSize( WinName, minSize ) ;---------------------------------
   ; docs updated 29.12.2008

   ; Sets the minimum allowed size of the main Hollywood window
   ; minSize is a table with the fields <Width> and <Height>

   Local w = scui.Win.FindByName(WinName)
   If Not(helpers.FieldIsNil(minSize, "width"))
      scui.Windows[w.id].MinSize.Width = minSize.Width
   EndIf
   If Not(helpers.FieldIsNil(minSize, "height"))
      scui.Windows[w.id].MinSize.Height = minSize.Height
   EndIf
   
EndFunction
Function scui.Win.MaxSize( WinName, maxSize ) ;---------------------------------
   ; docs updated 29.12.2008

   ; Sets the maximum allowed size of the main Hollywood window
   ; minSize is a table with the fields <Width> and <Height>


   Local w = scui.Win.FindByName(WinName)
   If Not(helpers.FieldIsNil(maxSize, "width"))
      scui.Windows[w.id].MaxSize.Width = maxSize.Width
   EndIf
   If Not(helpers.FieldIsNil(maxSize, "height"))
      scui.Windows[w.id].MaxSize.Height = maxSize.Height
   EndIf
EndFunction
Function scui.MultiSet(GadList, TagList, Redraw) ;------------------------------
   ; docs updated 29.12.2008

   ; Used to set properties to all gadgets listed in <GadList>

   Local g
   Local gcount = helpers.CountEntries(GadList) -1
    
   For g = 0 To gcount
      scui.Set(GadList[g], TagList, Redraw)
   Next
EndFunction
Function scui.GrabScreen()
   ; =============================================
   ; === MODIFICARE CON I NUOVI COMANDI DI HW4 ===
   ; =============================================
   ; docs updated 29.12.2008

   ; This routine will grab the screen and will save it to the brush #MYBRUSH_SCREENGRAB
   Local BGFilename = GetTempFileName()

   SaveSnapshot(BGFilename, #SNAPDISPLAY)
   LoadBrush(#MYBRUSH_SCREENGRAB, BGFilename)
   DeleteFile(BGFilename)
EndFunction
Function scui.PauseObjectRendering() ;------------------------------------------
   ; docs updated 30.12.2008

   ; Pause automatic gadget rendering at creation time
   
   scui.AutoRendering = False
EndFunction
Function scui.ResumeObjectRendering() ;-----------------------------------------
   ; docs updated 30.12.2008

   ; Restore automatic gadget rendering at creation time
   
   scui.AutoRendering = True
EndFunction
Function helpers.SmartAreaCrop(Viewport, Area) ;------------------| PRIVATE |---
   ; docs updated 30.12.2008

   ; If needed crop Area within Viewport, if the crop occurs then
   ; the new Area definition will be returned

	ViewPort_Width = Viewport.xEnd - Viewport.xStart + 1
	ViewPort_Height = Viewport.yEnd - Viewport.yStart + 1
	Area_Width = Area.xEnd - Area.xStart + 1
	Area_Height = Area.yEnd - Area.yStart + 1
	
	If Collision(#BOX, Viewport.xStart, Viewport.yStart, Viewport_Width, Viewport_Height, 
	                   Area.xStart, Area.yStart, Area_Width, Area_Height)
		; C'e' una collisione, effettua il crop 
		If Area.xEnd > Viewport.xEnd Then Area.xEnd = Viewport.xEnd
		If Area.xStart < Viewport.xStart Then Area.xStart = Viewport.xStart
		If Area.yEnd > Viewport.yEnd Then Area.yEnd = Viewport.yEnd
		If Area.yStart < Viewport.yStart Then Area.yStart = Viewport.yStart
		Return(Area)
	Else
		Return(nil)
	EndIf
EndFunction
Function scui.GrabScreenPart(Area)
   ; =============================================
   ; === MODIFICARE CON I NUOVI COMANDI DI HW4 ===
   ; =============================================
   ; docs updated 30.12.2008

   ; Returns the brush id where the screen part described by <Area> has been saved

   ; Area is a tabel with the format
   ; - x, y, w, h 
   Local BrushID = -1 ; helpers.GetBrushID()
   Local BGFilename = GetTempFileName()

   SaveSnapshot(BGFilename, #SNAPDISPLAY)
   BrushID = LoadBrush(Nil, BGFilename)
   DeleteFile(BGFilename)
   
   CropBrush(BrushID, Area.x, Area.y, Area.w, Area.h)
   Return(BrushID)
EndFunction
Function scui.AddChilds(ParentID, ChildList, ChildOptions, ChildInfos) ;-------
   ; docs updated 30.12.2008

   ; Setup the IFOs listed in ChildList as childs of ParentID

   ; Verifica la correttezza dei parametri
   If helpers.IsNil(ParentID)           = 1 Then Return
   If GetType(ParentID) = #STRING Then ParentID = scui.GetIFOID(ParentID)
   If ParentID < 0 Then Return

   If helpers.IsNil(scui.IFO[ParentID]) = 1 Then Return
   If helpers.IsNil(ChildList)          = 1 Then Return
   If helpers.CountEntries(ChildList)   = 0 Then Return
   If helpers.IsNil(ChildOptions)       = 1 Then ChildOptions = {}

   Local ParentObj = scui.IFO[ParentID]

   ; Controlla se esiste gia' una ChildList nel Parent
	Local Grp
   If helpers.FieldIsNil(ParentObj, "childlist") = 0
		Grp = helpers.CountEntries(ParentObj.ChildList) + 1
	Else
		Grp = 1
		ParentObj.ChildList = {}
		ParentObj.ChildInfos = {}
	EndIf
	
   ParentObj.ChildList[Grp] = {}
	ParentObj.ChildInfos[Grp] = ChildInfos
	; Esiste gia' una ChildList, aggiunge i nuovi childs
	Local ChildsToAdd = helpers.CountEntries(ChildList)
	Local c
	Local cta = 1
	scui.RenderObject(ParentID)
	For c = 1 To ChildsToAdd
		If GetType(ChildList[cta-1]) = #STRING Then ChildList[cta-1] = scui.GetIFOID(ChildList[cta-1])
      If ChildList[cta-1] = #DIVIDER
         /* Crea un BevelBox nullo come divider */
         ChildList[cta-1] = scui.NewObject( #IFOCLASS_BEVELBOX , "<--DIVIDER." .. scui.IFO.IDCounter .. "-->", nil, nil, 
                                            { Bevel = { Type     = #BEVELTYPE_NONE ,
                                                        Outline  = { Type   = #BEVELTYPE_NONE },
                                                        FillMode = #BEVELFILL_NONE } } )
      EndIf
		If ChildList[cta-1] > 0
			Local Resize = True
			Local Move   = True
			Local ResizeInfo   = { Vertical = True, Horizontal = True }
			Local Type   = #CHILDTYPE_USER
			If helpers.FieldIsNil(ChildOptions, "resizewithparent") = 0 Then Resize = ChildOptions.ResizeWithParent
			If helpers.FieldIsNil(ChildOptions, "movewithparent")   = 0 Then Move   = ChildOptions.MoveWithParent
			If helpers.FieldIsNil(ChildOptions, "resizeinfo")       = 0 
				If helpers.FieldIsNil(ChildOptions.ResizeInfo, "vertical"  ) = 0 Then ResizeInfo.Vertical = ChildOptions.ResizeInfo.Vertical
				If helpers.FieldIsNil(ChildOptions.ResizeInfo, "horizontal") = 0 Then ResizeInfo.Horizontal = ChildOptions.ResizeInfo.Horizontal
			EndIf
			If helpers.FieldIsNil(ChildOptions, "type")             = 0 Then Type   = ChildOptions.TypeWithParent
			ParentObj.ChildList[Grp][c] = { Id = ChildList[cta-1],
												ResizeWithParent = Resize,
												MoveWithParent   = Move,
												ResizeInfo       = { Vertical = ResizeInfo.Vertical, Horizontal = ResizeInfo.Horizontal },
												Type             = Type }
			scui.IFO[ChildList[cta-1]].Daddy = ParentID
			cta = cta + 1
		EndIf
	Next
	If ChildInfos.Layout = 0
		
		Return
	EndIf
   If helpers.FieldIsNil(ChildInfos, "gap") = 1 Then ChildInfos.Gap = 1
   
	If ChildInfos.Layout = #LAYOUTMODE_VERTICAL 
		; === VERTICAL ===
		pObj = scui.Get(ParentID)
		Local xStart = pObj.Position.x + ChildInfos.Borders.Left + 1
		Local yStart = pObj.Position.y + ChildInfos.Borders.Top + 1
		Local xSize  = pObj.Size.x - ChildInfos.Borders.Left - ChildInfos.Borders.Right - 2
		Local ySize  = pObj.Size.y - ChildInfos.Borders.Top - ChildInfos.Borders.Bottom - (ChildsToAdd - 1)*(ChildInfos.Gap+1) - 2
		For Local c = 1 To ChildsToAdd
		If ChildInfos.Weights[c-1] < 0
				ChildInfos.Weights[c-1] = -ChildInfos.Weights[c-1]
				ParentObj.ChildList[Grp][c].ResizeInfo.Vertical = False
			EndIf
			scui.Set(ChildList[c-1], { Position = { x = xStart, y = yStart }, Size = { x = xSize, y = ySize * ChildInfos.Weights[c-1] } }, 1)
			yStart = yStart + (ChildInfos.Gap+1) + ySize * ChildInfos.Weights[c-1]
		Next
		;scui.RenderObject(ParentID)
	ElseIf ChildInfos.Layout = #LAYOUTMODE_HORIZONTAL
		; === HORIZONTAL ===
		pObj = scui.Get(ParentID)
		Local xStart = pObj.Position.x + ChildInfos.Borders.Left + 1
		Local yStart = pObj.Position.y + ChildInfos.Borders.Top + 1
		Local xSize  = pObj.Size.x - ChildInfos.Borders.Left - ChildInfos.Borders.Right - (ChildsToAdd - 1)*(ChildInfos.Gap+1) - 2
		Local ySize  = pObj.Size.y - ChildInfos.Borders.Top - ChildInfos.Borders.Bottom - 2
		
		For Local c = 1 To ChildsToAdd
			If ChildInfos.Weights[c-1] < 0
				ChildInfos.Weights[c-1] = -ChildInfos.Weights[c-1]
				ParentObj.ChildList[Grp][c].ResizeInfo.Horizontal = False
			EndIf
			scui.Set(ChildList[c-1], { Position = { x = xStart, y = yStart }, Size = { x = xSize * ChildInfos.Weights[c-1], y = ySize } }, 1)
			xStart = xStart + (ChildInfos.Gap+1) + xSize * ChildInfos.Weights[c-1]
		Next
		;scui.RenderObject(ParentID)
	EndIf
EndFunction
Function scui.SetMasterIFO(id) ;----------------------------------| PRIVATE |---
   ; docs updated 30.12.2008

   ; Set the MasterIFO, the father of all child gadgets

   Local mcnt = helpers.CountEntries(scui.MasterIFOs)
   If GetType(id) = #STRING Then id = scui.GetIFOID(id)
   ;DebugPrint("Setting Master IFO", id)
   scui.MasterIFOs[mcnt] = { id = id, w = GetAttribute(#DISPLAY, 0, #ATTRWIDTH), h = GetAttribute(#DISPLAY, 0, #ATTRHEIGHT) }
EndFunction
Function scui.MoveChilds(Obj, xOffset, yOffset) ;-----------------| PRIVATE |---
   ; docs updated 30.12.2008

   ; Move the specified object childs recursively

	If (xOffset = 0) And (yOffset = 0) Then Return
	If helpers.FieldIsNil(Obj, "childlist") = 0
		; Ci sono dei figli calcolo lo spostamento in offset e li sposto  |
		Local GrpCnt = helpers.CountEntries(Obj.ChildList)
		For Local g = 1 To GrpCnt
			Local childs = helpers.CountEntries(Obj.ChildList[g])
			For Local ccnt = 1 To childs
				If Obj.ChildList[g][ccnt].MoveWithParent
					ChildData = scui.Get(Obj.ChildList[g][ccnt].Id)
					Local NewX = ChildData.Position.x + xOffset
					Local NewY = ChildData.Position.y + yOffset
					;DebugPrint(xOffset, yOffset)
					scui.Set(Obj.ChildList[g][ccnt].Id, { Position = { x = NewX, y = NewY } } )
				EndIf
			Next
		Next
	EndIf
EndFunction
Function scui.ResizeChilds(Obj, xFact, yFact) ;-------------------| PRIVATE |---
	; docs updated 30.12.2008
   ; Resize the specified object childs recursively
   ; GESTIONE CHILDLIST -------------------------------------------------
	If (xFact = 1) And (yFact = 1) Then Return
	If helpers.FieldIsNil(Obj, "childlist") = 0
		; Ci sono dei figli innanzitutto calcolo l'offset rispetto al     |
		; padre per ridimensionarlo correttamente                         |
		Local GrpCnt = helpers.CountEntries(Obj.ChildList)
		For Local g = 1 To GrpCnt
			Local childs = helpers.CountEntries(Obj.ChildList[g])

			If Obj.ChildInfos[g].Layout = 1
				; VERTICAL
				Local pObj = scui.Get(Obj.oName)
				Local GadHeight
				Local ChildsToAdd = helpers.CountEntries(Obj.ChildList[g])
				Local xStart = pObj.Position.x + Obj.ChildInfos[g].Borders.Left + 1
				Local yStart = pObj.Position.y + Obj.ChildInfos[g].Borders.Top + 1
				Local xSize  = pObj.Size.x - Obj.ChildInfos[g].Borders.Left - Obj.ChildInfos[g].Borders.Right - 2
				Local ySize  = pObj.Size.y - Obj.ChildInfos[g].Borders.Top - Obj.ChildInfos[g].Borders.Bottom - (ChildsToAdd - 1)*(Obj.ChildInfos[g].Gap+1) - 2
				
				Local Corrector = 0
				Local FixedCnt  = 0
				Local FixedSize = 0
				For Local c = 1 To ChildsToAdd
					Local GadData = scui.Get(Obj.ChildList[g][c].id)
					Local GadHeight_Fixed  = GadData.Size.y
					Local GadHeight_Resize = ySize * (Obj.ChildInfos[g].Weights[c-1])
					Local LessSpace = GadHeight_Fixed - GadHeight_Resize
					If Obj.ChildList[g][c].ResizeInfo.Vertical = False
						FixedCnt = FixedCnt + 1
						FixedSize = FixedSize + LessSpace
					EndIf
				Next
				If (ChildsToAdd-FixedCnt)<>0 
               Corrector = (FixedSize/ySize)/(ChildsToAdd-FixedCnt)
            Else
               Corrector = 0
            EndIf
				For Local c = 1 To ChildsToAdd
					Local GadData = scui.Get(Obj.ChildList[g][c].id)
					Local GadHeight_Fixed  = GadData.Size.y
					Local GadHeight_Resize = ySize * (Obj.ChildInfos[g].Weights[c-1] - Corrector)
					;Local LessSpace = GadHeight_Fixed - GadHeight_Resize
					
					If Obj.ChildList[g][c].ResizeInfo.Vertical = True
						GadHeight = GadHeight_Resize
					Else
						GadHeight = GadHeight_Fixed
						;If c <> ChildsToAdd Then Corrector = Corrector + (LessSpace/ySize)/(ChildsToAdd-c)
					EndIf
					If GadHeight < 1
						DebugPrint("Too many fixed width gadgets or parent's area too small for its childs, can fit childs into its parent!")
						End
					EndIf
               

	 				scui.Set(Obj.ChildList[g][c].id, { Position = { x = xStart, y = yStart }, Size = { x = xSize, y = GadHeight } } )
					yStart = yStart + (Obj.ChildInfos[g].Gap+1) + GadHeight

				Next
				
			ElseIf Obj.ChildInfos[g].Layout = 2
				; HORIZONTAL
				Local pObj = scui.Get(Obj.oName)
				Local ChildsToAdd = helpers.CountEntries(Obj.ChildList[g])
				Local xStart = pObj.Position.x + Obj.ChildInfos[g].Borders.Left + 1
				Local yStart = pObj.Position.y + Obj.ChildInfos[g].Borders.Top + 1
				Local xSize  = pObj.Size.x - Obj.ChildInfos[g].Borders.Left - Obj.ChildInfos[g].Borders.Right - (ChildsToAdd - 1)*(Obj.ChildInfos[g].Gap+1) - 2
				Local ySize  = pObj.Size.y - Obj.ChildInfos[g].Borders.Top - Obj.ChildInfos[g].Borders.Bottom - 2
				
				Local GadWidth
				Local Corrector = 0
				Local FixedCnt  = 0
				Local FixedSize = 0
				For Local c = 1 To ChildsToAdd
					Local GadData = scui.Get(Obj.ChildList[g][c].id)
					Local GadWidth_Fixed  = GadData.Size.x
					Local GadWidth_Resize = xSize * (Obj.ChildInfos[g].Weights[c-1])
					Local LessSpace = GadWidth_Fixed - GadWidth_Resize
					If Obj.ChildList[g][c].ResizeInfo.Horizontal = False
						FixedCnt = FixedCnt + 1
						FixedSize = FixedSize + LessSpace
					EndIf
				Next
				If (ChildsToAdd-FixedCnt) <> 0
               Corrector = (FixedSize/xSize)/(ChildsToAdd-FixedCnt)
            Else
               Corrector = 0
            EndIf
				For Local c = 1 To ChildsToAdd
               Local GadData = scui.Get(Obj.ChildList[g][c].id)
					Local GadWidth_Fixed  = GadData.Size.x
					Local GadWidth_Resize = xSize * (Obj.ChildInfos[g].Weights[c-1] - Corrector)
					;Local LessSpace = GadWidth_Fixed - GadWidth_Resize
					
					If Obj.ChildList[g][c].ResizeInfo.Horizontal = True
						GadWidth = GadWidth_Resize
					Else
						GadWidth = GadWidth_Fixed
						;If c <> ChildsToAdd Then Corrector = Corrector + (LessSpace/xSize)/(ChildsToAdd-c)
					EndIf
					If GadWidth < 1
						DebugPrint("Too many fixed width gadgets, can fit childs into its parent!")
						End
					EndIf
	 				scui.Set(Obj.ChildList[g][c].id, { Position = { x = xStart, y = yStart }, Size = { x = GadWidth, y = ySize } } )
					xStart = xStart + (Obj.ChildInfos[g].Gap+1) + GadWidth

				Next
				
			Else
				For Local ccnt = 1 To childs
					If Obj.ChildList[g][ccnt].ResizeWithParent
						If Obj.ChildList[g][ccnt].ResizeInfo.Vertical   = False Then yFact = 1
						If Obj.ChildList[g][ccnt].ResizeInfo.Horizontal = False Then xFact = 1
						ChildData = scui.Get(Obj.ChildList[g][ccnt].Id)
						; Calcola l'offset rispetto al padre                        |
						Local xOffset = ChildData.Position.x - Obj.oData.Bevel.Position.x
						Local yOffset = ChildData.Position.y - Obj.oData.Bevel.Position.y
						; Ridimensiona l'offset e calcola la nuova posizione        |
						xOffset = xOffset * xFact
						yOffset = yOffset * yFact
						Local NewXP = Obj.oData.Bevel.Position.x + xOffset
						Local NewYP = Obj.oData.Bevel.Position.y + yOffset
						; Calcola la nuova dimensione del child                     |
						Local NewXS = ChildData.Size.x * xFact
						Local NewYS = ChildData.SIze.y * yFact
						; Setta il child con i nuovi dati       
						scui.Set(Obj.ChildList[g][ccnt].Id, { Position = { x = NewXP, y = NewYP }, 
																	  Size     = { x = NewXS, y = NewYS } } )
					EndIf
				Next
			EndIf
		Next
	EndIf
EndFunction

Function scui.RenderStack_Put(BrushID) ;--------------------------| PRIVATE |---
   ; Docs updated 05.01.2009
   
   ; Add the given brush to the stack rendering.
   ;DebugPrint("RENDER STACK PUT")
   Local StackSize = helpers.CountEntries(scui.RenderStack)
   
   ;DebugPrint("   Current Stack")
   ;helpers.DumpTable(scui.RenderStack, 3)
   InsertItem(scui.RenderStack, BrushID)
   SelectBrush(BrushID)
   ;DebugPrint("   Selected Brush:", BrushID)
EndFunction
Function scui.RenderStack_Get() ;---------------------------------| PRIVATE |---
   ; Docs updated 05.01.2009
   
   ; Remove the latest added brush from the rendering stack.
   
   ;DebugPrint("RENDER STACK GET")
   Local StackSize = helpers.CountEntries(scui.RenderStack)
   ;DebugPrint("   Current Stack")
   ;helpers.DumpTable(scui.RenderStack)
   
   Local BrushID = -1
	If StackSize > 1
      BrushID = scui.RenderStack[StackSize - 1]
      SelectBrush(BrushID)
      ;DebugPrint("   Selected Brush:", BrushID)
      RemoveItem(scui.RenderStack)
   Else
      RemoveItem(scui.RenderStack)
      ;DebugPrint("   Performed END SELECT")
      EndSelect
   EndIf
EndFunction
Function scui.GetMasterParent(id) ;-------------------------------| PRIVATE |---
   ; Docs updated 05.01.2009
   ; Retrieve the id's master parent IFO
   
   If helpers.FieldIsNil(scui.IFO[id], "oparent") = 0
      Local Master = scui.GetMasterParent(scui.IFO[id].oParent)
      If helpers.IsNil(Master) = 0
         Return(Master)
      Else
         Return(scui.IFO[id].oParent)
      EndIf
   EndIf
EndFunction

Function scui.HandleRMB(msg) ;------------------------------------| PRIVATE |---
   Local DisplayId = msg.id
   Local w = scui.Win.FindByHandler(DisplayID)
   
   If Not(helpers.FieldIsNil(scui.Windows[w.id], "menuitems"))
      Local items_count = helpers.CountEntries(scui.Windows[w.id].MenuItems)
      Local list = {}
      list.MenuName = scui.Windows[w.id].Title
      
      For Local i = 0 To items_count - 1
         DebugPrint(scui.Windows[w.id].TopItems[i].id, scui.Windows[w.id].TopItems[i].caption)
         DebugPrint(scui.Windows[w.id].MenuItems[scui.Windows[w.id].TopItems[i].id])
         Local state = #IFO_ENABLED
         If helpers.CountEntries(scui.Windows[w.id].MenuItems[scui.Windows[w.id].TopItems[i].id]) = 0 Then state = #IFO_DISABLED
         list[i] = { Type = #IFOCLASS_SUBMENU ,
                     Status = state ,
                     data = { Caption = scui.Windows[w.id].TopItems[i].caption,
                              Items = scui.Windows[w.id].MenuItems[scui.Windows[w.id].TopItems[i].id] }}
      Next
      
      Local position = { MouseX() + GetAttribute(#DISPLAY, w.HWId, #ATTRXPOS),
                         MouseY() + GetAttribute(#DISPLAY, w.HWId, #ATTRYPOS) + GetAttribute(#DISPLAY, w.HWId, #ATTRBORDERTOP) }

      scui.Win.PopUp(position, list, { MenuTitle = True, Draggable = True })
   EndIf
EndFunction

Function scui.Initialize(taglist) ;---------------------------------------------
   ; Inizializza tutte le variabili e le strutture necessarie a ScuiLib
   For Local i = 1 To scui.IFO.IDCounter
      ;If scui.IFO[i].oInteractive = 1
         If helpers.FieldIsNil(scui.IFO[i], "oparent") = 1
            scui.RemoveObject(i) ; DeleteButton(i)
         EndIf
      ;EndIf
   Next
   
   ; Se esistono dei display definiti li elimina
   Local wcnt = helpers.CountEntries(scui.Windows) - 1
   For Local i = 1 To wcnt
      FreeDisplay(scui.Windows[i].HWId)
   Next

   ;scui.ActionStatus = ""
   scui.IFO = { IDCounter = 0 }
   scui.Windows  = { }
   scui.WinOrder = { #SCREENID }
   scui.Keyboard = { }
   scui.Keyboard[#SCREENID] = { Mode = #KEYBOARD_IFOMODE,
                 		           ActiveIFO = -1,
                   		        Shortcuts = { } }
   scui.ActiveWindow = #SCREENID
   scui.LayoutList = { }
   scui.RefreshWindows = False
   scui.AutoRendering = True
   scui.LockRMB = False
   scui.RenderStack = { }
   scui.MasterIFOs = { }
   scui.Menu = { }
   scui.RWin = { }
   scui.MainMinSize = { }
   scui.OnWindowResizeFunc = scui.NULLFUNC
   scui.RootDisplay = 1
   scui.QuickFind = {} ; nomi gadget, relazione nome --> id
   scui.Icons = {}
   scui.Pictures = {}
   
   ;Cls
   
   ; Setup default values
   Local Name        = #SCREENID
   Local Title       = Name  ; se il titolo non viene definito sara' usato il nome della finestra
   Local Position    = { GetAttribute(#DISPLAY, 1, #ATTRXPOS), GetAttribute(#DISPLAY, 1, #ATTRYPOS) }
   Local Size        = { GetAttribute(#DISPLAY, 1, #ATTRWIDTH), GetAttribute(#DISPLAY, 1, #ATTRWIDTH) }
   Local Resizeable  = True
   Local Closeable   = True
   Local Moveable    = True
   Local Borderless  = False
   Local Moveable    = True
   Local Hideable    = True
   Local OnClose     = Nil
   Local OnMove      = Nil
   Local OnActivate  = Nil
   Local OnLostFocus = Nil
   Local OnHide      = Nil
   Local OnShow      = Nil
   Local OnSize      = Nil
   Local OnDrop      = Nil
   Local RootGadget  = Nil
   Local AutoEnd     = True
   Local AutoClose   = True
   
   ; Check tags
   If helpers.FieldIsNil(taglist, "title"      ) = 0 Then Title       = taglist.Title
   If helpers.FieldIsNil(taglist, "position"   ) = 0 Then Position    = taglist.Position
   If helpers.FieldIsNil(taglist, "size"       ) = 0 Then Size        = taglist.Size
   If helpers.FieldIsNil(taglist, "resizeable" ) = 0 Then Resizeable  = taglist.Resizeable
   If helpers.FieldIsNil(taglist, "closeable"  ) = 0 Then Closeable   = taglist.Closeable
   If helpers.FieldIsNil(taglist, "moveable"   ) = 0 Then Moveable    = taglist.Moveable
   If helpers.FieldIsNil(taglist, "hideable"   ) = 0 Then Hideable    = taglist.Hideable
   If helpers.FieldIsNil(taglist, "borderless" ) = 0 Then Borderless  = taglist.Borderless
   If helpers.FieldIsNil(taglist, "onclose"    ) = 0 Then OnClose     = taglist.OnClose
   If helpers.FieldIsNil(taglist, "onmove"     ) = 0 Then OnMove      = taglist.OnMove
   If helpers.FieldIsNil(taglist, "onsize"     ) = 0 Then OnSize      = taglist.OnSize
   If helpers.FieldIsNil(taglist, "onhide"     ) = 0 Then OnHide      = taglist.OnHide
   If helpers.FieldIsNil(taglist, "onshow"     ) = 0 Then OnShow      = taglist.OnShow
   If helpers.FieldIsNil(taglist, "onactivate" ) = 0 Then OnActivate  = taglist.OnActivate
   If helpers.FieldIsNil(taglist, "oninactivate")= 0 Then OnInactivate= taglist.OnInactivate
   If helpers.FieldIsNil(taglist, "ondrop"     ) = 0 Then OnDrop      = taglist.OnDrop
   If helpers.FieldIsNil(taglist, "autoend"    ) = 0 Then AutoEnd     = taglist.AutoEnd
   If helpers.FieldIsNil(taglist, "autoclose"  ) = 0 Then AutoClose   = taglist.AutoClose
   
   
   ; Se Modal = True devo impostare che la finestra non puo' essere chiusa ne
   ; nascosta
   If Modal
      Closeable = False
      Hideable  = False
   EndIf
   
   ; SETUP THE DEFAULT HOLLYWOOD DISPLAY
   SelectDisplay(1, True)

   SetDisplayAttributes({ Borderless = Borderless })

   SetDisplayAttributes({ X = Position[0], Y = Position[1],
                          Width = Size[0], Height = Size[1],
                          Title = Title,
                          Sizeable = Resizeable,
                          Fixed = Not(Moveable) })
  
   ; Sembra che AROS non supporti questa tag perchè mi chiude la finestra
   ; senza motivi apparenti, quindi se mi trovo su AROS ignoro questa tag
   Local v = GetVersion()
   If v.platform <> "AROS"
      SetDisplayAttributes({ NoClose = Not(Closeable) } )
   EndIf

   ; Attach the event handler
   InstallEventHandler({ SizeWindow = scui.Win.HandleResizeEvent })
   InstallEventHandler({ MoveWindow = scui.Win.HandleMoveEvent })
   InstallEventHandler({ ActiveWindow = scui.Win.HandleActiveEvent })
   InstallEventHandler({ InactiveWindow = scui.Win.HandleInactiveEvent })
   InstallEventHandler({ HideWindow = scui.Win.HandleHideEvent })
   InstallEventHandler({ ShowWindow = scui.Win.HandleShowEvent })
   InstallEventHandler({ CloseWindow = scui.Win.HandleCloseEvent })
   InstallEventHandler({ OnDropFile = scui.Win.HandleDropEvent })
   InstallEventHandler({ OnKeyDown = scui.Keyboard_Handler , OnKeyUp = scui.Keyboard_Handler })
   InstallEventHandler({ OnRightMouseUp = scui.HandleRMB })

   ; === CREA LA PRIMA FINESTRA LEGATA ALLO SCREEN DI HOLLYWOOD ===
   Local scrSize_W, scrSize_H = scui.GetScreenSize()
   scui.Windows[0] = { Name        = Name ,
                        Title       = Title,
                        Position    = { 100, 100 },
                        Size        = { 100, 100 },
                        HWID        = 1,
                        Resizeable  = Resizeable,
                        Hideable    = Hideable,
                        DontOpen    = DontOpen,
                        Borderless  = Borderless,
                        Closeable   = Closeable,
                        Moveable    = Moveable,
                        OnClose     = OnClose,
                        OnMove      = OnMove,
                        OnSize      = OnSize,
                        OnHide      = OnHide,
                        OnShow      = OnShow,
                        OnGotFocus  = OnGotFocus,
                        OnDrop      = OnDrop,                        
                        OnLostFocus = OnLostFocus,
                        RootGadget  = Name .. ".root",
                        ActionStatus = "",
                        Modal       = False,
                        TopMenu     = TopMenu,

;                    --- INTERNALS ---
                        Opened      = True ,
                        Hidden      = False ,
                        AutoEnd     = AutoEnd,
                        AutoClose   = AutoClose,
                        MaxSize     = { Width = scrSize_W, Height = scrSize_H },
                        MinSize     = { Width = Size[0], Height = Size[1] } }


   ; Create a Root Bevel to attach all user's gadgets
   ;scui.PauseObjectRendering()
   
   ; *** DOVRO' CREARE UN LAYOUT PER CREARE IL BEVEL COME FOSSE TRASPARENTE ***

        
   scui.NewObject( #IFOCLASS_BEVELBOX , 
                   Name .. ".root", 
                   { x = 0, y = 0 }, 
                   { x = Size[0] - 1, y = Size[1] - 1 },
                   nil, nil, nil, nil, nil, nil, Name )

EndFunction
Function scui.HandleMenuItem(msg) ;-------------------------------| PRIVATE |---
   Local WinName = scui.IFO[msg.id].Owner
   Local w = scui.Win.FindByName(WinName)
   
   Local item_count = helpers.CountEntries(scui.Windows[w.id].MenuItems[msg.id])
   If item_count > 0
      Local position = { MouseX() + GetAttribute(#DISPLAY, w.HWId, #ATTRXPOS),
                         MouseY() + GetAttribute(#DISPLAY, w.HWId, #ATTRYPOS) + GetAttribute(#DISPLAY, w.HWId, #ATTRBORDERTOP) }

      scui.Win.PopUp(position, scui.Windows[w.id].MenuItems[msg.id])
   EndIf
EndFunction
Function scui.Win.AttachMenu(WinName, ItemList) ;------------------------------
   ; ItemList[0] = ITEM NAME
   ; ItemList[1] = ITEM MENU
   
   Local w = scui.Win.FindByName(WinName)
   Local win_height = GetAttribute(#DISPLAY, w.HWId, #ATTRHEIGHT)
   Local win_width = GetAttribute(#DISPLAY, w.HWId, #ATTRWIDTH)
   
   Local TopMenuHeight = scui.theme.MenuHeight
   If TopMenuHeight = #MENUHEIGHT_AUTO
      TopMenuHeight = TextHeight("gl") + 12
   EndIf
   
   Local topfrac = 1/win_height * TopMenuHeight
   scui.NewObject( #IFOCLASS_BEVELBOX , 
                   WinName .. ".topmenu", 
                   { x = 0, y = 0 }, 
                   { x = win_width - 1, y = TopMenuHeight - 1 },
                   nil, nil, nil, nil, nil, nil, Name )
   scui.NewObject( #IFOCLASS_BEVELBOX , 
                   WinName .. ".bg", 
                   { x = 0, y = TopMenuHeight }, 
                   { x = win_width - 1, y = win_height - 1 - TopMenuHeight},
                   nil, nil, nil, nil, nil, nil, Name )
                   
   scui.AddChilds( WinName .. ".root", { WinName .. ".topmenu", WinName .. ".bg" }, nil,
                                { Layout = #LAYOUTMODE_VERTICAL , 
                                  Borders = { Top = 0, Bottom = 0, Left = 0, Right = 0 }, 
                   Weights = { -topfrac, 1-topfrac } , Gap = 1 } )
   Local items_count = helpers.CountEntries(ItemList)
   Local item_list = {}
   Local item_weights = {}
   Local item_weight = 0
   Local item_name = ""

   Local pixel_weight = 1/win_width
   
   scui.Windows[w.id].MenuItems = {}
   scui.Windows[w.id].TopItems = {}
   scui.PauseObjectRendering()
   For Local i = 0 To items_count - 1
      
      item_name = "*TOPMENU*Item_" .. StrStr(i)
      Local item_id = scui.NewObject( #IFOCLASS_BUTTON , item_name,  nil, nil, { Bevel  = scui.theme.PopUp_Button_NBox,
                                                                          Text   = scui.theme.PopUp_Button_NText,
                                                                          HBevel = scui.theme.PopUp_Button_HBox,
                                                                          HText  = scui.theme.PopUp_Button_HText,
                                                                          PBevel = scui.theme.PopUp_Button_PBox,
                                                                          PText  = scui.theme.PopUp_Button_PText,
                                                                          DBevel = scui.theme.PopUp_Button_DBox,
                                                                          DText  = scui.theme.PopUp_Button_DText }, 
                                                                        { Values = { ItemList[i][0] }}, { OnPushed  = scui.HandleMenuItem } )
      item_weight = pixel_weight * TextWidth( ItemList[i][0] )
      item_list[i] = item_name
      item_weights[i] = -item_weight
      
      scui.Windows[w.id].MenuItems[item_id] = ItemList[i][1]
      scui.Windows[w.id].TopItems[i] = { id = item_id, caption = ItemList[i][0] }
   Next

   scui.AddChilds( WinName .. ".topmenu", item_list, nil,
                                { Layout = #LAYOUTMODE_HORIZONTAL , 
                                  Borders = { Top = 1, Bottom = 1, Left = 1, Right = 1 }, 
                   Weights = item_weights, Gap = 0 } )
                    
   scui.ResumeObjectRendering()
   scui.Win.RenderGUI(WinName)

EndFunction
Function scui.Language.Initialize() ;------------------------------------------
   scui.Language.Current = {}       ; Current Language Definition
   scui.Language.MarkList = {}      ; Marked Object to be translated
EndFunction
Function scui.AppID() ;------------------------------------------| OBSOLETE |---
   ; Generate a Random ID
   Local r0 = StrStr(Rnd(100))
   Local r1 = StrStr(Rnd(100))
   Local r2 = StrStr(Rnd(100))
   Local r3 = StrStr(Rnd(100))   
   id = "SL" .. r0 .. r1 .. r2 .. r3
   idLen = StrLen(id)
   Nr2Add = 10 - idLen
   For Local i = 1 To Nr2Add Do id = id .. "0"
   
   Return(id)
   
EndFunction
Function scui.GetARexxPortName() ;-------------------------------| OBSOLETE |---
	; Return the current project's ARexx port name or nil
	If helpers.FieldIsNil(scui, "applicationid") = 0 Then Return(scui.ApplicationID)
	
EndFunction
Function scui.GetMasterARexxPortName() ;-------------------------| OBSOLETE |---
	; Usefull only for RWin client, it returns the Master ARexx port name or nil
	If helpers.FieldIsNil(scui, "masterid") = 0 Then Return(scui.MasterID)

EndFunction
Function scui.ParseRexx(Message) ;-------------------------------| OBSOLETE |---
   ; Interpreta i messaggi ricevuti sulla porta Rexx
   DebugPrint(IIF(scui.Behaviour = #SCUILIB_MASTER, "MASTER -->", "CHILD --> ") .. "Message From Rexx Port!")
   Local Cmd = Message.Command
   
   ;helpers.DumpTable(Message)

   If scui.Behaviour = #SCUILIB_MASTER
		Switch Cmd
         ;---| L'utente a premuto il CLOSE GADGET della finestra |-------------
         ;   | KEY: CLOSEWIN, PRM: CHILDID
         Case "CLOSEWIN" ; <===================================================
            DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Child Win ".. Message.RawArgs .. " has a CLOSE request ")
            ; Cerca l'id della finestra che ha inviato il messaggio
            Local w_ind = scui.RWin_FindById(Message.RawArgs)
            ; Verifica se la finestra e' chiudibile
            If scui.RWin[w_ind].Closeable
               ; Verifica se deve essere lanciato l'evento <BeforeClose>
               If helpers.FieldIsNil(scui.RWin[w_ind], "beforeclose") = 0
                  Local Result = scui.RWin[w_ind].BeforeClose(scui.RWin[w_ind])
                  If (Result = True) Or (helpers.IsNil(Result) = 1)
                     ; Invia il messaggio di chiusura alla finestra
                     SendRexxCommand(scui.RWin[w_ind].WinID, "CLOSE")
                     scui.RWin[w_ind].Opened = False
                     ; Verifica se deve essere lanciato l'evento <AfterClose>
                     If helpers.FieldIsNil(scui.RWin[w_ind], "afterclose") = 0 Then scui.RWin[w_ind].AfterClose(scui.RWin[w_ind])
                  EndIf
               Else
                  ; <BeforeClose> non e' definito, chiudo la finestra e controllo <AfterClose>
                  ; Invia il messaggio di chiusura alla finestra
                  SendRexxCommand(scui.RWin[w_ind].WinID, "CLOSE")
                  ; Verifica se deve essere lanciato l'evento <AfterClose>
                  If helpers.FieldIsNil(scui.RWin[w_ind], "afterclose") = 0 Then scui.RWin[w_ind].AfterClose(scui.RWin[w_ind])
               EndIf
            Else
               ; Se e' stato previsto un messaggio apre un requester di sistema
               If helpers.FieldIsNil(scui.RWin[w_ind], "closemsg") = 0 Then SystemRequest("Message", scui.RWin[w_ind].CloseMsg, "OK")
            EndIf
         ;---------------------------------------------------------------------
         
         ;---| L'utente a SPOSTATO la finestra |-------------------------------
         ;   | KEY: MOVEWIN, PRM: CHILDID, NEWX, NEWY
         Case "MOVEWIN" ; <===================================================
            ; Splitta i parametri ricevuti
            Local prms = SplitStr(Message.RawArgs, " ")
            DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : ") .. "Child Win ".. prms[0] .. " has MOVED @ ", prms[1], prms[2])
            ; Cerca l'id della finestra che ha inviato il messaggio
            Local w_ind = scui.RWin_FindById(prms[0])
            ; Verifica l'evento OnMove
            If helpers.FieldIsNil(scui.RWin[w_ind], "onmove") = 0 Then scui.RWin[w_ind].OnMove(scui.RWin[w_ind])
            ; Aggiorna le nuove coordinate
            scui.RWin[w_ind].Position[0] = prms[1]
            scui.RWin[w_ind].Position[1] = prms[2]
            
         ;---| L'utente a RIDIMENSIONATO la finestra |-------------------------
         ;   | KEY: SIZEWIN, PRM: CHILDID, NEWX, NEWY
         Case "SIZEWIN" ; <===================================================
            ; Splitta i parametri ricevuti
            Local prms = SplitStr(Message.RawArgs, " ")
            DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Child Win ".. prms[0] .. " has RESIZED @ ", prms[1], prms[2])
            ; Cerca l'id della finestra che ha inviato il messaggio
            Local w_ind = scui.RWin_FindById(prms[0])
            ; Verifica l'evento OnSize
            If helpers.FieldIsNil(scui.RWin[w_ind], "onsize") = 0 Then scui.RWin[w_ind].OnSize(scui.RWin[w_ind])
            ; Aggiorna le nuove coordinate
            scui.RWin[w_ind].Size[0] = prms[1]
            scui.RWin[w_ind].Size[1] = prms[2]

         ;---| Il Child ha comunicato i dati di un nuovo oggetto |------------
         ;   | KEY: OBJECTID, PRM: CHILDID, OBJNAME, OBJID, OBJDF
         Case "OBJECTID" ; <==================================================
				Local prms = SplitStr(Message.RawArgs, " ")
				DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Received New Object Data -->", prms[0], prms[1], prms[2], prms[3])
				
				; *** Elimino i dati temporanei e memorizzo i dati definitivi ***
				Local w_ind = scui.RWin_FindById(prms[0])

				If helpers.FieldIsNil(scui.RWin[w_ind], "ifo") = 1 Then scui.RWin[w_ind].IFO = {}
				Local objID = Val(prms[2])
				scui.RWin[w_ind].IFO[objID] = {}
				Filez.LoadTable(scui.RWin[w_ind].IFO[objID], prms[3])
				If helpers.FieldIsNil(scui.RWin[w_ind].Temp[prms[1]], "actions") = 0
					scui.RWin[w_ind].IFO[objID].Actions = scui.RWin[w_ind].Temp[prms[1]].Actions
				EndIf
				scui.RWin[w_ind].Temp[prms[1]] = nil
				DeleteFile(prms[3])

         ;---| Il Child ha comunicato un evento |-----------------------------
         ;   | KEY: EVENT, PRM: CHILDID, OBJID, EVENTTYPE
         Case "EVENT" ; <=====================================================
				Local prms = SplitStr(Message.RawArgs, " ")
				DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Received a Child's Object Event -->", prms[0], prms[1], prms[2])
				; Ricrea l'evento ricevuto per spedirlo all'apposita funzione
				Local msg = { id = Val(prms[1]), action = prms[2], RootChild = prms[0] }
				scui.HandleObject(msg)

         ;---| Il Child ha comunicato che è stato iconificato |---------------
         ;   | KEY: HIDEWIN, PRM: CHILDID
         Case "HIDEWIN" ; <===================================================
				Local prms = SplitStr(Message.RawArgs, " ")
				DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Received form Child: Inconified -->", prms[0])
            ; Verifica l'evento OnHide
            If helpers.FieldIsNil(scui.RWin[w_ind], "onhide") = 0 Then scui.RWin[w_ind].OnHide(scui.RWin[w_ind])

         ;---| Il Child ha comunicato che è stato de-iconificato |------------
         ;   | KEY: SHOWWIN, PRM: CHILDID
         Case "SHOWWIN" ; <===================================================
				Local prms = SplitStr(Message.RawArgs, " ")
				DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Received form Child: DE-Inconified -->", prms[0])
            ; Verifica l'evento OnHide
            If helpers.FieldIsNil(scui.RWin[w_ind], "onshow") = 0 Then scui.RWin[w_ind].OnShow(scui.RWin[w_ind])
				
				
				
				
				
			Default
				; === REDIRIGE IL COMANDO AREXX VERSO LA FUNZIONE UTENTE, SE DEFINITA ===
				; === FUNZIONA SOLO PER IL MASTER =======================================
		      If helpers.FieldIsNil(scui, "rexxfunc") = 0 Then scui.RexxFunc(Message)
				
      EndSwitch
      
       
   Else
      Switch Cmd
         ;---| Il Master ha inviato un comando di controllo |------------------
         ;   | KEY: DUMMY, PRM: -
         Case "DUMMY" ; <======================================================
            ; Messaggio per testare la porta arexx e basta
            DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Received a DUMMY command from its Master")
				DeleteFile("T:" .. scui.ApplicationID .. ".SLTMP")
				Wait(5)
				scui.ChildInit = False
				
         ;---------------------------------------------------------------------
         
         ;---| Il Master ha inviato il comando CLOSE |-------------------------
         ;   | KEY: CLOSE, PRM: -
         Case "CLOSE" ; <======================================================
            DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Received a CLOSE command from its Master, shutting down.")
            End
         ;---------------------------------------------------------------------

         ;---| Il Master ha inviato il comando MOVE |--------------------------
         ;   | KEY: MOVE, PRM: NEWX, NEWY
         Case "MOVE" ; <=======================================================
            DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Received a MOVE command from its Master.")
            Local prms = SplitStr(Message.RawArgs, " ")
            MoveDisplay(prms[0], prms[1])
         ;---------------------------------------------------------------------
         
         ;---| Il Master ha inviato il comando SIZE |--------------------------
         ;   | KEY: SIZE, PRM: NEWX, NEWY
         Case "SIZE" ; <=======================================================
            DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Received a SIZE command from its Master.")
            Local prms = SplitStr(Message.RawArgs, " ")

            ; Questo pezzetto di codice qua sotto dovra' essere modificato con HW4
            Local x = GetAttribute(#DISPLAY, 0, #ATTRXPOS)
            Local y = GetAttribute(#DISPLAY, 0, #ATTRYPOS)
            ChangeDisplaySize(prms[0], prms[1])				
            MoveDisplay(x, y)
				scui.Win.HandleResizeEvent()
         ;---------------------------------------------------------------------

         ;---| Il Master ha inviato il comando NEWOBJECT |---------------------
         ;   | KEY: NEWOBJECT, PRM: CLASS, NAME, XPOS, YPOS, XSIZE, YSIZE, ODATADF, OSTRINGDF, OACTIONSDF
         Case "NEWOBJECT" ; <==================================================
				DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "Received a NEWOBJECT command from its Master.")
				Local prms = SplitStr(Message.RawArgs, " ")
				Local oData    = {}
				Local oString  = {}
				Local oActions = {}
				Filez.LoadTable(oString,  prms[7])
				Filez.LoadTable(oActions, prms[8])
				DeleteFile(prms[6])
				DeleteFile(prms[7])
				DeleteFile(prms[8])
				Local oPos  = { x = Val(prms[2]), y = Val(prms[3]) }
				Local oSize = { x = Val(prms[4]), y = Val(prms[5]) }

				; oClass, oName, oPosition, oSize, oData, oString , oActions, IFOParent, ForceID, NoDraw, Owner, RootChild
				Local id = scui.NewObject(Val(prms[0]), prms[1], oPos, oSize, oData, oString, oActions, nil, nil, nil, nil, True)
				
				;*** Faccio il dump dell'oggetto creato
				Local NewObjDF = GetTempFileName()
				Filez.SaveTable(scui.IFO[id], NewObjDF)
				
				;*** Adesso che ho creato il gadget restituisco al master il suo ID ***
				Local cmd = "OBJECTID" .. " " .. scui.ApplicationID .. " " .. "\"" .. prms[1] .. "\"" .. " " .. id .. " " .. "\"" .. NewObjDF .. "\""
				SendRexxCommand(scui.MasterID, cmd)
         ;---------------------------------------------------------------------

         ;---| Il Master ha inviato il comando LAYADDCHILD |-------------------
         ;   | KEY: LAYADDCHILDS, PRM: PARENTNAME, CHILDLIST_DF, CHILDOPTS_DF, CHILDINFOS_DF
			Case "LAYADDCHILDS"
				DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "<AddChilds> Received")
				Local prms = SplitStr(Message.RawArgs, " ")

				Local ChildList    = {}
				Local ChildOptions = {}
				Local ChildInfos   = {}

				Filez.LoadTable(ChildList,    prms[1])
				Filez.LoadTable(ChildOptions, prms[2])
				Filez.LoadTable(ChildInfos,   prms[3])
				
				DeleteFile(prms[1])
				DeleteFile(prms[2])
				DeleteFile(prms[3])
				
				scui.AddChilds(prms[0], ChildList, ChildOptions, ChildInfos)
         ;---------------------------------------------------------------------

         ;---| Il Master ha inviato il comando MASTERIFO |---------------------
         ;   | KEY: MASTERIFO, PRM: ID
			Case "MASTERIFO"
				DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "<SetMasterIFO> Received")

				Local prms = SplitStr(Message.RawArgs, " ")
				
				scui.SetMasterIFO(prms[0])
         ;---------------------------------------------------------------------

         ;---| Il Master ha inviato il comando WINMINSIZE |--------------------
         ;   | KEY: WINMINSIZE, PRM: WIDTH, HEIGHT
			Case "WINMINSIZE"
				Local prms = SplitStr(Message.RawArgs, " ")
				DebugPrint(IIF(scui.behaviour = #SCUILIB_MASTER, "MASTER: ", "CHILD : "), "<MainWindowMinSize> Received")

				Local w = Val(prms[0])
				Local h = Val(prms[1])
				
				scui.Win.MinSize({ Width = w, Height = h })
         ;---------------------------------------------------------------------

         ;---| Il Master ha inviato il comando PAUSEOBJREND |------------------
         ;   | KEY: PAUSEOBJREND, PRM: -
			Case "PAUSEOBJREND"
				scui.PauseObjectRendering()
         ;---------------------------------------------------------------------

         ;---| Il Master ha inviato il comando RESUMEOBJREND |-----------------
         ;   | KEY: RESUMEOBJREND, PRM: -
			Case "RESUMEOBJREND"
				scui.ResumeObjectRendering()
         ;---------------------------------------------------------------------

         ;---| Il Master ha inviato il comando HIDE |--------------------------
         ;   | KEY: HIDE, PRM: -
			Case "HIDE"
				HideDisplay()
            SendRexxCommand(scui.MasterID, "HIDEWIN" .. " " .. RWin_ChildPort)

         ;---------------------------------------------------------------------

         ;---| Il Master ha inviato il comando HIDE |--------------------------
         ;   | KEY: SHOW, PRM: -
			Case "SHOW"
				ShowDisplay()
            SendRexxCommand(scui.MasterID, "SHOWWIN" .. " " .. RWin_ChildPort)


				


      EndSwitch
   EndIf
   

   
EndFunction
Function scui.SetRexxFunction(FuncName) ;------------------------| OBSOLETE |---
   ; Quando viene ricevuto un messaggio sulla porta ARexx che non fa
   ; parte dei messaggi di sistema delle RWin sarà dirottato su questa funzione
   ; per permettere al programmatore di gestire la porta ARexx come
   ; desidera, altrimenti i messaggi saranno semplicemente scartati.
   
   scui.RexxFunc = FuncName
EndFunction

Function scui.GetScreenSize() ;----------------------------------| OBSOLETE |---
;*** HELPERS ***
   Return(GetAttribute(#DISPLAY, 0, #ATTRMAXWIDTH), GetAttribute(#DISPLAY, 0, #ATTRMAXHEIGHT))
EndFunction
Function scui.Win.GetMaxSize(WinName) ;-----------------------------------------
   Local w = scui.Win.FindbyName(WinName)
   Return(GetAttribute(#DISPLAY, w.HWId, #ATTRMAXWIDTH), GetAttribute(#DISPLAY, w.HWId, #ATTRMAXHEIGHT))
EndFunction
Function scui.GetHostSize() ;---------------------------------------------------
   Return(GetAttribute(#DISPLAY, 0, #ATTRHOSTWIDTH), GetAttribute(#DISPLAY, 0, #ATTRHOSTHEIGHT))
EndFunction
Function scui.Win.GetSize(WinName) ;--------------------------------------------
   Local w = scui.Win.FindbyName(WinName)
   Return(GetAttribute(#DISPLAY, w.HWId, #ATTRWIDTH), GetAttribute(#DISPLAY, w.HWId, #ATTRHEIGHT))
EndFunction
Function scui.Win.GetPos(WinName)
   Local w = scui.Win.FindbyName(WinName)
   Return(GetAttribute(#DISPLAY, w.HWId, #ATTRXPOS), GetAttribute(#DISPLAY, w.HWId, #ATTRYPOS))
EndFunction

Function scui.PauseEventHandling() ;--------------------------------------------
   scui.EventHandling = False
EndFunction
Function scui.ResumeEventHandling() ;-------------------------------------------
   scui.EventHandling = True
EndFunction

;---------------- 24.02.2009 ----------------

/* ---| MECCANISMO DI TRADUZIONE |----------------------------
   * Viene definito un catalogo di una lingua con al suo interno
     delle coppie TAG - TRADUZIONE dove TAG e' una stringa senza
     spazi in minuscolo mentre TRADUZIONE e' una tabella contenente
     una o piu' stringhe per supportare anche gli elementi multilinea
   * Una volta creata la Gui devono essere abbinati i gadget alle
     TAG precedentemente definite quindi per ogni gadget che intendo
     tradurre abbino la TAG della stringa del catalogo, se necessario
     specifico anche per quale aspetto del gadget questo abbinamento
     e' valido.
   * La funzione scui.Language.LoadCatalog() carica e applica la
     nuova lingua a tutti i gadget precedentemente marcati.
   * E' possibile inoltre tradurre anche stringhe non utilizzate nei
     gadget semplicemente definendoli nel catalogo e invocando la 
     funzione scui.Language.GetTranslation(TAG) che restituira'
     una tabella con una o piu' stringhe tradotte nella lingua corrente.
   
*/
Function scui.Language.ListAvailable(path) ;---------------------| OBSOLETE |---
   Return(Filez.Search(path, "#?.Language", False))
EndFunction
Function scui.Language.LoadCatalog(filename, applynow) ;------------------------
   scui.Language.Current = {}    ; Wipe current definitions

   ; La tabella e' indicizzata con le tag dei gadget
   ; e l'elemento contiene una tabella con uno o piu'
   ; traduzioni per gli elementi multilinea
   Filez.LoadTable(scui.Language.Current, filename)
   If applynow Then scui.Language.TranslateGUI()
EndFunction
Function scui.Language.MarkObjects(MarkList) ;----------------------------------
   ; Formato MarkList
   ; { { IFOName-id, TranslationTag, Aspect },
   ;   ... }
   
   ;scui.Language.MarkList = MarkList
   
   Local marked = helpers.CountEntries(scui.Language.MarkList) + 1
   Local tomark = helpers.CountEntries(MarkList)
   Local endind = marked + tomark - 1
   
   For Local i = marked To endind
      Local ind = i - marked
      Local Obj = scui.Get(MarkList[ind][0])
      scui.Language.MarkList[i] = { MarkList[ind][0], MarkList[ind][1], MarkList[ind][2] }
   Next

EndFunction
Function scui.Language.GetTranslation(tag) ;------------------------------------
   Return(scui.Language.Current[tag])
EndFunction
Function scui.Language.GetString(tag, index) ;----------------------------------
   If helpers.IsNil(index) = 1 Then index = 0
   Return(scui.Language.Current[tag][index])
EndFunction

Function scui.Language.TranslateGUI(WinName) ;----------------------------------
   ; Aggiorna tutti gli oggetti nella MarkList, se WinName = Nil aggiorna
   ; tutte le finestre altrimenti solo quella specificata
   
   ; Durante la traduzione, non saranno considerati i gadget orfani
   
   Local Translated
   Local ind, data = NextItem(scui.Language.MarkList)
   
   While GetType(ind) <> #NIL
      ; Se necessario converte il nome dell'oggetto con il suo id
		If GetType(data[0]) = #STRING Then data[0] = scui.GetIFOID(data[0])
      
      ; Adesso per ogni classe supportata cerca di tradurre il contenuto
      ; in base alla tag assegnata
      Obj = scui.IFO[data[0]]

      ; Controlla se il gadget fa parte di una finestra chiusa, in caso affermativo
      ; marca la finestra cosi' che quando sara' aperta sara' anche tradotta
      Local wname = Obj.Owner
      
      Local wid = scui.Win.FindByName(wname)
      If Not(helpers.IsNil(wid))
         If scui.Windows[wid.id].Opened
            Translated = scui.Language.Current[data[1]]
            
            Local can_translate = True
            
            If Not(helpers.IsNil(WinName))
               If WinName <> wname Then can_translate = False
            Else
               can_translate = True
               can_translate = True
            EndIf

            If can_translate
/*
#LANG_NORMAL    = 1
#LANG_HILIGHTED = 2
#LANG_PUSHED    = 4
#LANG_DISABLED  = 8
#LANG_NDISABLED = 16
#LANG_PDISABLED = 32
#LANG_ALL       = 0
*/

               Switch Obj.oClass
                  Case #IFOCLASS_SWITCH
                     Switch data[2]
                        Case #LANG_ALL
                           scui.Set(data[0], { AllTexts = { Content = { Values = Translated }}}, 1)
                        
                        Case #LANG_NORMAL
                           scui.Set(data[0], { Text = { Content = { Values = Translated }}})
                           scui.Set(data[0], { HText = { Content = { Values = Translated }}})
                           scui.Set(data[0], { NDText = { Content = { Values = Translated }}}, 1)
                        Case #LANG_HILIGHTED
                           scui.Set(data[0], { HText = { Content = { Values = Translated }}}, 1)
                        Case #LANG_PUSHED
                           scui.Set(data[0], { PText = { Content = { Values = Translated }}})
                           scui.Set(data[0], { PDText = { Content = { Values = Translated }}}, 1)
                        Case #LANG_NDISABLED
                           scui.Set(data[0], { NDText = { Content = { Values = Translated }}}, 1)
                        Case #LANG_PDISABLED
                           scui.Set(data[0], { PDText = { Content = { Values = Translated }}}, 1)
                     EndSwitch
                     
                  Case #IFOCLASS_LABEL
                     ; Aspect Ignored
                     scui.Set(data[0], { Text = { Content = { Values = Translated } } }, 1)
                  
                  Case #IFOCLASS_BUTTON
                     Switch data[2]
                        Case #LANG_ALL
                           ; Cambia tutti gli stati
                           scui.Set(data[0], { AllTexts = { Content = { Values = Translated } } }, 1)
                        
                        Case #LANG_NORMAL
                           scui.Set(data[0], { Text = { Content = { Values = Translated } } }, 1)
                           
                        Case #LANG_HILIGHTED
                           scui.Set(data[0], { HText = { Content = { Values = Translated } } }, 1)
                           
                        Case #LANG_PUSHED
                           scui.Set(data[0], { PText = { Content = { Values = Translated } } }, 1)
                           
                        Case #LANG_DISABLED
                           scui.Set(data[0], { DText = { Content = { Values = Translated } } }, 1)
                     
                     EndSwitch
                     
                  Case #IFOCLASS_OPTIONS
                     Switch data[2]
                        Case #LANG_ALL
                           ; Cambia tutti gli stati
                           scui.Set(data[0], { Options = Translated[0] }, 1)
                        
                     EndSwitch

               EndSwitch
               
            EndIf
            
         Else
            scui.Windows[wid.id].NeedTranslation = True
         
         EndIf
      EndIf
      
      ind, data = NextItem(scui.Language.MarkList, ind)
   Wend

EndFunction
Function scui.OnWindowResize(func) ;-----------------------------| OBSOLETA |---
   ; OBSOLETA
   If helpers.IsNil(func) = 0
      scui.OnWindowResizeFunc = func
   Else
      scui.OnWindowResizeFunc = scui.NULLFUNC
   EndIf
EndFunction

; --- NEW WINDOWS MANAGEMENT ---

Function scui.Win.New(taglist) ;------------------------------------------------
/* +--------------------------------------------------------------------------+
   | Define a new ScuiLib window using the parameters specified in the taglist|
   | table. Below there are the tags accepted by the taglist:                 |
   |   Title         Title of the new window                          [String]|
   |   Position      Position with the format { xx, yy }               [Table]|
   |   Size          Size with the format { ww, hh }                   [Table]|
   |   Resizeable    True if you want a resizeable window            [Boolean]|
   |   Closeable     True if you want a closeable window             [Boolean]|
   |   Moveable      True if you want a draggable window             [Boolean]|
   |   DontOpen      True if you do not want to open the new window  [Boolean]|
   |   Borderless    True if you want a borderless window            [Boolean]|
   |   Modal         If you want a Modal window (not fully working)    *******|
   |   Hideable      If you want a window that can be hide           [Boolean]|
   |   OnClose       Attach a custom function to the close event    [Function]|
   |   OnMove        Attach a custom function to the move event     [Function]|
   |   OnActivate    Attach a custom function to the activate event [Function]|
   |   OnDeactivate  Attach a custom func. to the deactivate event  [Function]|
   |   OnHide        Attach a custom function to the hide event     [Function]|
   |   OnShow        Attach a custom function to the show event     [Function]|
   |   OnSize        Attach a custom function to the resize event   [Function]|
   |   AutoClose     True if you want to close automatically the window when  |
   |                 it receives a close message.                    [Boolean]|
   +--------------------------------------------------------------------------+
   | Returns a table with the following fields:                               |
   |   Result        True if the windows has been created            [Boolean]|
   |   Window        A table containing a dump of the window structure or a   |
   |                 description of the raised error                   [Table]|
   +--------------------------------------------------------------------------+
   | Notes:                                                                   |
   |  -Only the <Name> tag is mandatory, if you omit this tag the window will |
   |   not be generated.                                                      |
   |  -If the window title is not specified will be initialized with the      |
   |   window name.                                                           |
   |  -Here are the default values that will be used if you don't specify the |
   |   relative tags:                                                         |
   |   - Title       = taglist.Name   <-- Window's Name                       |
   |   - Position    = {  #CENTER,  #CENTER }                                 |
   |   - Size        = { 50, 50 }                                             |
   |   - Resizeable  = True                                                   |
   |   - Closeable   = True                                                   |
   |   - Moveable    = True                                                   |
   |   - DontOpen    = False                                                  |
   |   - Borderless  = False                                                  |
   |   - Modal       = False                                                  |
   |   - Hideable    = True                                                   |
   |   - OnClose     = Nil                                                    |
   |   - OnMove      = Nil                                                    |
   |   - OnActivate  = Nil                                                    |
   |   - OnDeactivate= Nil                                                    |
   |   - OnHide      = Nil                                                    |
   |   - OnShow      = Nil                                                    |
   |   - OnSize      = Nil                                                    |
   |   - RootGadget  = Nil                                                    |
   |   - AutoClose   = True                                                   |
   +--------------------------------------------------------------------------+
*/
;---| L'unico parametro obbligatorio e' il nome della finestra
   If helpers.FieldIsNil(taglist, "name") = 1
      Local msg = "{scui.Win.New()} ERROR: The window name cannot be <nil>."
      DebugPrint(msg)
      Return(False, msg)
   EndIf
   
;---| Verifica che questa finestra non sia stata gia' definita
   If Not(helpers.IsNil(scui.Win.FindByName(taglist.Name)))
      Local msg = "{scui.Win.New()} ERROR: The window name <" .. WinName .. "> is already used."
      DebugPrint(msg)
      Return(False, msg)
   EndIf
   
;---| Imposta i valori di default
   Local Title       = taglist.Name  ; se il titolo non viene definito sara' usato il nome della finestra
   Local Position    = {  #CENTER,  #CENTER }
   Local Size        = { 50, 50 }
   Local Resizeable  = True
   Local Closeable   = True
   Local Moveable    = True
   Local DontOpen    = False
   Local Borderless  = False
   Local Modal       = False
   Local Hideable    = True
   Local OnClose     = Nil
   Local OnMove      = Nil
   Local OnActivate  = Nil
   Local OnDeactivate= Nil
   Local OnHide      = Nil
   Local OnShow      = Nil
   Local OnSize      = Nil
   Local RootGadget  = Nil
   Local AutoClose   = True
   
;---| Controlla le tag specificate nella taglist
   If helpers.FieldIsNil(taglist, "title"      ) = 0 Then Title       = taglist.Title
   If helpers.FieldIsNil(taglist, "position"   ) = 0 Then Position    = taglist.Position
   If helpers.FieldIsNil(taglist, "size"       ) = 0 Then Size        = taglist.Size
   If helpers.FieldIsNil(taglist, "resizeable" ) = 0 Then Resizeable  = taglist.Resizeable
   If helpers.FieldIsNil(taglist, "closeable"  ) = 0 Then Closeable   = taglist.Closeable
   If helpers.FieldIsNil(taglist, "moveable"   ) = 0 Then Moveable    = taglist.Moveable
   If helpers.FieldIsNil(taglist, "hideable"   ) = 0 Then Hideable    = taglist.Hideable
   If helpers.FieldIsNil(taglist, "dontopen"   ) = 0 Then DontOpen    = taglist.DontOpen
   If helpers.FieldIsNil(taglist, "borderless" ) = 0 Then Borderless  = taglist.Borderless
   If helpers.FieldIsNil(taglist, "onclose"    ) = 0 Then OnClose     = taglist.OnClose
   If helpers.FieldIsNil(taglist, "onmove"     ) = 0 Then OnMove      = taglist.OnMove
   If helpers.FieldIsNil(taglist, "onsize"     ) = 0 Then OnSize      = taglist.OnSize
   If helpers.FieldIsNil(taglist, "onhide"     ) = 0 Then OnHide      = taglist.OnHide
   If helpers.FieldIsNil(taglist, "onshow"     ) = 0 Then OnShow      = taglist.OnShow
   If helpers.FieldIsNil(taglist, "onactivate" ) = 0 Then OnActivate  = taglist.OnActivate
   If helpers.FieldIsNil(taglist, "ondeactivate")= 0 Then OnDeactivate= taglist.OnDeactivate
   If helpers.FieldIsNil(taglist, "autoclose"  ) = 0 Then AutoClose   = taglist.AutoClose
   If helpers.FieldIsNil(taglist, "modal"      ) = 0 Then Modal       = taglist.Modal
   
;---| Controllo se devo creare una finestra modale, in caso affermativo questa
;   | non potra' essere chiusa ne nascosta, ne tantomeno potrà perdere il focus,
;   | quest'ultima peculiarita' sara' gestita dall'handler che monitorizza la
;   | disattivazione delle finestre.
   If Modal
      Closeable = False
      Hideable  = False
   EndIf
   
;---| Crea la nuova finestra (Hollywood display)
;   | *** In futuro potrei estendere la taglist per permettere di settare   ***
;   | *** altri patametri quali la BGPic, il colore di sfondo, il puntatore ***
;   | *** del mouse, la modalita' di scaling, ecc..                         ***
   Local HWDisplay = CreateDisplay(nil, { Width  = Size[0],
                                          Height = Size[1],
                                          Color = #BLACK ,
                                          x = Position[0],
                                          y = Position[1],
                                          Title = Title,
                                          Borderless = Borderless,
                                          Sizeable = Resizeable,
                                          Fixed = Not(Moveable),
                                          NoHide = Not(Hideable),
                                          NoModeSwitch = False,         ; <-- Non gestito
                                          
                                          Active = True ,               ; <-- lo attivo per disegnarci i gadget
                                          HidePointer = False,          ; <-- Non gestito
                                          ScaleMode = #SCALEMODE_NONE , ; <-- Non gestito
                                          ; ScaleWidth, ScaleHeight, SmoothScale,
                                          ; DragRegion, SizeRegion, Layers
                                          } )

                                          
;---| Calcola la posizione della nuova entry e memorizza le informazioni
   Local scrSize_W, scrSize_H = scui.GetHostSize()
   Local id = helpers.CountEntries(scui.Windows)
   scui.Windows[id] = { Name        = taglist.Name,
                        Title       = Title,
                        Position    = { Position[0], Position[1] },
                        Size        = { Size[0], Size[1] },
                        HWID        = HWDisplay,
                        Resizeable  = Resizeable,
                        Hideable    = Hideable,
                        DontOpen    = DontOpen,
                        Borderless  = Borderless,
                        Closeable   = Closeable,
                        Moveable    = Moveable,
                        OnClose     = OnClose,
                        OnMove      = OnMove,
                        OnSize      = OnSize,
                        OnHide      = OnHide,
                        OnShow      = OnShow,
                        OnActivate  = OnActivate,
                        OnDeactivate= OnDeactivate,
                        RootGadget  = taglist.Name .. ".root",
                        ActionStatus = "",
                        Modal       = Modal,

;                    --- INTERNALS ---
                        Opened      = False ,
                        Hidden      = False ,
                        Active      = False ,
                        AutoClose   = AutoClose,
                        MaxSize     = { Width = scrSize_W, Height = scrSize_H },
                        MinSize     = { Width = Size[0], Height = Size[1] } }

   scui.Keyboard[taglist.Name] = { Mode = #KEYBOARD_IFOMODE,
                                   ActiveIFO = -1,
                                   Shortcuts = { } }

;---| Attiva la nuova finestra per ricevere il rendering
   SelectDisplay(HWDisplay, True)
   
   ; Sembra che AROS non supporti questa tag perchè mi chiude la finestra
   ; senza motivi apparenti, quindi se mi trovo su AROS ignoro questa tag
   Local v = GetVersion()
   If v.platform <> "AROS"
      SetDisplayAttributes({ NoClose = Not(Closeable) } )
   EndIf
   
;---| Crea un bevel box da usare come root gadget per questa finestra
;   | *** Successivamente questo gadget sara' creato da un modello memorizzato
;   | *** nelle preferenze come per tutti gli altri gadget
   ;scui.PauseObjectRendering()
   scui.NewObject( #IFOCLASS_BEVELBOX , 
                   taglist.Name .. ".root", 
                   { x = 0, y = 0 }, 
                   { x = Size[0] - 1, y = Size[1] - 1 },
                   nil, nil, nil, nil, nil, nil, taglist.Name )
   ;scui.ResumeObjectRendering()


;---| Verifico se devo aprire la finestra
   If DontOpen = False
      ; Apre la finestra
      OpenDisplay(HWDisplay, True)
      scui.Windows[id].Opened = True
      
      ; Attach the event handlers
      InstallEventHandler({ SizeWindow = scui.Win.HandleResizeEvent })
      InstallEventHandler({ MoveWindow = scui.Win.HandleMoveEvent })
      InstallEventHandler({ ActiveWindow = scui.Win.HandleActiveEvent })
      InstallEventHandler({ InactiveWindow = scui.Win.HandleInactiveEvent })
      InstallEventHandler({ HideWindow = scui.Win.HandleHideEvent })
      InstallEventHandler({ ShowWindow = scui.Win.HandleShowEvent })
      InstallEventHandler({ CloseWindow = scui.Win.HandleCloseEvent })
      InstallEventHandler({ OnKeyDown = scui.Keyboard_Handler , OnKeyUp = scui.Keyboard_Handler })
      InstallEventHandler({ OnRightMouseUp = scui.HandleRMB })

   Else
      OpenDisplay(HWDisplay, False)
      scui.Windows[id].Opened = True
      scui.Windows[id].Hidden = True
      HideDisplay()  ; <=== PER ORA NON POSSO USARE IL CLOSE PERCHE' MI DA ERRORE SU WAITEVENT
                     ;      DEVO INDAGARE ****************************************************
   EndIf

   
   InsertItem(scui.WinOrder, taglist.Name)
   
	Return(True, scui.Windows[id], id)

EndFunction
Function scui.Win.FindByName(WinName) ;-----------------------------------------
   ; Una tabella con il nome, l'id e l'handler della finestra
   Local Found = -1
   Local Count = helpers.CountEntries(scui.Windows)
   For Local i = 0 To Count - 1
      If scui.Windows[i].Name = WinName
         Found = i
         Break
      EndIf
   Next
   
   If Found <> -1
      Return({ Name = scui.Windows[Found].Name, Id = Found, HWId = scui.Windows[Found].HWID })
   Else
      Return()
   EndIf

EndFunction
Function scui.Win.FindByHandler(WinHandler) ;-----------------------------------
   ; Una tabella con il nome, l'id e l'handler della finestra
   Local Found = -1
   Local Count = helpers.CountEntries(scui.Windows)
   If GetType(WinHandler) <> #NUMBER
      Local T2 = GetType(WinHandler)
      For Local i = 0 To Count - 1
         Local T1 = GetType(scui.Windows[i].HWId)
         If T1 = T2
            If scui.Windows[i].HWId = WinHandler
               Found = i
               Break
            EndIf
         EndIf
      Next
   Else
      Found = 0
   EndIf
      
   If Found <> -1
      Return({ Name = scui.Windows[Found].Name, Id = Found, HWId = scui.Windows[Found].HWID })
   Else
      Return()
   EndIf

EndFunction
Function scui.Win.Select(WinName) ;---------------------------------------------
   If helpers.IsNil(WinName)
      SelectDisplay(scui.RootDisplay, True)
      scui.Win.SelectedDisplay = #SCREENID

   Else
      Local w = scui.Win.FindByName(WinName)
      If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.Select() is called with a non-existing window named <" .. WinName .. ">")
         Return()
      EndIf

      scui.Win.SelectedDisplay = WinName
      SelectDisplay(w.HWId, True)
   EndIf
EndFunction
Function scui.Win.AttachGadgets(WinName, RootGadget) ;--------------------------
   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.AttachGadgets() is called with a non-existing window named <" .. WinName .. ">")
         Return()
   EndIf

   If Not(helpers.IsNil(RootGadget))
      Local root = ""
      If helpers.FieldIsNil(scui.QuickFind, WinName .. ".bg")
         root = WinName .. ".root"
      Else
         root = WinName .. ".bg"
      EndIf
      
      scui.AddChilds( root, { RootGadget }, nil,
   				                    { Layout = #LAYOUTMODE_VERTICAL , 
                                     Borders = { Top = -1, Bottom = -1, Left = -1, Right = -1 }, 
   					     Weights = { 1 }, Gap = 0 } )
   EndIf
   scui.SetMasterIFO(w.Name .. ".root")
   
EndFunction
Function scui.Win.Resize(WinName, NewWidth, NewHeight) ;------------------------
   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.Resize() is called with a non-existing window named <" .. WinName .. ">")
         Return()
   EndIf

   scui.Win.SelectedDisplay = WinName
   SelectDisplay(w.HWId, True)
   
   scui.Windows[w.id].Size = { NewWidth, NewHeight }

   ChangeDisplaySize(NewWidth, NewHeight, { X = #KEEPPOSITION, Y = #KEEPPOSITION })
   
EndFunction
Function scui.Win.Move(WinName, NewX, NewY) ;-----------------------------------
   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.Move() is called with a non-existing window named <" .. WinName .. ">")
         Return()
   EndIf

   scui.Win.SelectedDisplay = WinName
   SelectDisplay(w.HWId, True)
   
   scui.Windows[w.id].Position = { NewX, NewY }
   

   MoveDisplay(NewX, NewY)
   
EndFunction
Function scui.Win.Activate(WinName) ;-------------------------------------------
   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.Activate() is called with a non-existing window named <" .. WinName .. ">")
         Return()
   EndIf

   scui.Win.SelectedDisplay = WinName
   SelectDisplay(w.HWId, False)
   
EndFunction
Function scui.Win.Hide(WinName) ;-----------------------------------------------
   ; E' possibile nascondere solo finestre aperte!
   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.Hide() is called with a non-existing window named <" .. WinName .. ">")
         Return()
   EndIf

   If Not(scui.Windows[w.id].Hidden)
      If scui.Windows[w.id].Opened
         SelectDisplay(w.HWId)
         scui.Windows[w.id].Hidden = True
         HideDisplay()
         ;scui.Win.HandleHideEvent({ id = w.id, event = "HideWindow" }) 
         Return(True)
      EndIf
   Else
      DebugPrint("** WARNING ** >> scui.Win.Hide() is trying to hide an already hidden window named <" .. WinName .. ">")
   EndIf
   Return(False)
EndFunction
Function scui.Win.Show(WinName) ;-----------------------------------------------
   ; E' possibile mostrare solo finestre aperte!
   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.Show() is called with a non-existing window named <" .. WinName .. ">")
         Return()
   EndIf

   If scui.Windows[w.id].Hidden
      If scui.Windows[w.id].Opened
         SelectDisplay(w.HWId)
         scui.Windows[w.id].Hidden = False
         ShowDisplay()
         ;scui.Win.HandleShowEvent({ id = w.id, event = "ShowWindow" })
         Return(True)
      EndIf
   Else
      DebugPrint("** WARNING ** >> scui.Win.Show() is trying to Show an already visible window named <" .. WinName .. ">")
   EndIf
   Return(False)
EndFunction
Function scui.Win.RemoveHandlers(WinName) ;-----------------------| PRIVATE |---
   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.RemoveHandlers() is called with a non-existing window named <" .. WinName .. ">")
         Return()
   EndIf

   scui.Win.Select(WinName)
   
   ;scui.DisableGadgets(WinName)
   InstallEventHandler({ SizeWindow = 0,
                         MoveWindow = 0,
                         ActiveWindow = 0,
                         InactiveWindow = 0,
                         HideWindow = 0,
                         ShowWindow = 0,
                         CloseWindow = 0,
                         OnKeyUp = 0,
                         OnKeyDown = 0 })

EndFunction
Function scui.Win.ActivateHandlers(WinName) ;---------------------| PRIVATE |---
   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.ActivateHandlers() is called with a non-existing window named <" .. WinName .. ">")
         Return()
   EndIf

   scui.Win.Select(WinName)
   
   InstallEventHandler({ SizeWindow = scui.Win.HandleResizeEvent })        ; PROBLEMA SEGNALATO
   InstallEventHandler({ MoveWindow = scui.Win.HandleMoveEvent })          ; PROBLEMA SEGNALATO
   InstallEventHandler({ ActiveWindow = scui.Win.HandleActiveEvent })
   InstallEventHandler({ InactiveWindow = scui.Win.HandleInactiveEvent })
   InstallEventHandler({ HideWindow = scui.Win.HandleHideEvent })          ; NESSUN EVENTO GENERATO: SEGNALATO
   InstallEventHandler({ ShowWindow = scui.Win.HandleShowEvent })          ; NESSUN EVENTO GENERATO: SEGNALATO
   InstallEventHandler({ CloseWindow = scui.Win.HandleCloseEvent })
   InstallEventHandler({ OnKeyDown = scui.Keyboard_Handler , OnKeyUp = scui.Keyboard_Handler })

EndFunction
Function scui.Win.Close(WinName) ;----------------------------------------------
   ; E' possibile chiudere solo finestre non nascoste!
   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         DebugPrint("** WARNING ** >> scui.Win.Close() is called with a non-existing window named <" .. WinName .. ">")
         Return()
   EndIf

   If scui.Windows[w.id].Opened
      If Not(scui.Windows[w.id].Hidden)
         If GetAttribute(#DISPLAY, w.HWID, #ATTRACTIVE)
            ; Activate the previous window
            Local c = helpers.CountEntries(scui.WinOrder) - 1
            If c > 0
               ; Scambia la posizione dell'ultima (quella sicuramente attiva)
               ; e la penultima (quella da attivare)
               Local dummy = scui.WinOrder[c - 1]
               scui.WinOrder[c - 1] = scui.WinOrder[c]
               scui.WinOrder[c] = dummy
               scui.Win.Activate(scui.WinOrder[c])
            EndIf
         EndIf

         CloseDisplay(w.HWId)
         scui.Windows[w.id].Opened = False
         Return(True)
      EndIf
   Else
      DebugPrint("** WARNING ** >> scui.Win.Close() is trying to Close an already closed window named <" .. WinName .. ">")
   EndIf
   Return(False)
EndFunction
Function scui.Win.Open(WinName) ;-----------------------------------------------
;---| This function will open a defined window with the given name.
;   | Remember that it's possible to open only unhidden windows.
;   | Return False in case of an error otherwise returns True.
;   +---------------------------------------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.Open(WinName)", 
               WinName})

   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
      scui.Debug({"SCUILIB: scui.Win.Open() *** WARNING *** The window <" .. WinName .. "> does not exists!"})
   Else
      If Not(scui.Windows[w.id].Opened)
         If Not(scui.Windows[w.id].Hidden)
            ; Prima di aprire la finestra guardo se si trova fuori dai bordi dello
            ; schermo perchè in caso affermativo Hollywood si incazza, pertanto
            ; la riporto all'interno dello schermo
            Local wscreen, hscreen = scui.GetHostSize()
            Local wwindow, hwindow = scui.Win.GetSize(WinName)
            Local wdelta = wscreen - wwindow - 4
            Local hdelta = hscreen - hwindow - 4

            Local force_move = False
            Local xpos = scui.Windows[w.id].Position[0]
            Local ypos = scui.Windows[w.id].Position[1]
            
            If wdelta < xpos
               xpos = wdelta
               force_move = True
            EndIf

            If hdelta < ypos
               ypos = hdelta
               force_move = True
            EndIf
            
            If force_move
               scui.Win.Move(WinName, xpos, ypos)
            EndIf
            
            ; Adesso che sono sicuro che la finestra è all'interno posso aprirla
            OpenDisplay(w.HWId)
            scui.Windows[w.id].Opened = True
            
            ; Verifica se questa finestra deve essere tradotta o meno
            If Not(helpers.FieldIsNil(scui.Windows[w.id], "needtranslation"))
               If scui.Windows[w.id].NeedTranslation
                  scui.Language.TranslateGUI(WinName)
                  scui.Windows[w.id].NeedTranslation = Nil
               EndIf
            EndIf
            Return(True)
            
         Else
            scui.Debug({"SCUILIB: scui.Win.Open() *** WARNING *** Cannot open an Hidden window <" .. WinName .. ">"})
         EndIf
      Else
         scui.Debug({"SCUILIB: scui.Win.Open() *** WARNING *** The window <" .. WinName .. "> is already opened!"})
      EndIf
   EndIf
   Return(False)
EndFunction
Function scui.Win.Free(WinName) ;-----------------------------------------------
;---| This function will free the specified window deallocating its resources.
;   | Returns True if the operation was successfully completed otherwise returns
;   | False.
;   +---------------------------------------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.Free(WinName)", 
               WinName})

   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
      scui.Debug({"SCUILIB: scui.Win.Free() *** WARNING *** The window <" .. WinName .. "> does not exists!"})
      Return(False)
   Else
      scui.Win.RemoveHandlers(WinName)

/*
      ; Activate the root window   
      scui.Win.Activate(WinName)
*/

      ; Delete the gadgets owned by this window
      Local cnt = scui.IFO.IDCounter
      For Local i = 1 To cnt
         If scui.IFO[i].Owner = WinName
            scui.RemoveObject(i)
         EndIf
      Next

      ;If GetAttribute(#DISPLAY, w.HWID, #ATTRACTIVE)
         ; Activate the last window
         Local c = helpers.CountEntries(scui.WinOrder)
         Local found = -1
         For local i = 0 to (c - 1)
            If scui.WinOrder[i] = WinName
               RemoveItem(scui.WinOrder, i)
               Break
            EndIf
         Next
         If c > 1
            ;DebugPrint("FREE:", scui.WinOrder[c - 2])
            scui.Win.Activate(scui.WinOrder[c - 2])
         EndIf
      ;EndIf

      scui.Keyboard[w.Name] = Nil
      
      ; Free the window resources and the window itself
      FreeDisplay(w.HWId)
      RemoveItem(scui.Windows, w.id)

      Return(True)
   EndIf
EndFunction
Function scui.Win.Set(WinName, taglist) ;---------------------------------------
;---| Sets the attributes of the specified window, returns True if all is ok
;   | otherwise returns False if an error occurs.
;   | Actually the suppoerted tags are:
;   |  - Borderless : can be True or False
;   |  - Resizeable : can be True or False
;   |  - Closeable : can be True or False
;   +---------------------------------------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.Set(WinName)", 
               WinName})

   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         scui.Debug({"SCUILIB: scui.Win.Set() *** WARNING *** The window <" .. WinName .. "> does not exists!"})
         Return(False)
   Else
      Local Borderless = scui.Windows[w.id].Borderless
      Local Resizeable = scui.Windows[w.id].Resizeable
      Local Closeable  = scui.Windows[w.id].Closeable

      If helpers.FieldIsNil(taglist, "borderless") = 0 Then Borderless = taglist.Borderless
      If helpers.FieldIsNil(taglist, "resizeable") = 0 Then Resizeable = taglist.Resizeable
      If helpers.FieldIsNil(taglist, "closeable")  = 0 Then Closeable  = taglist.Closeable

      scui.Win.Select(WinName)
      SetDisplayAttributes( { NoClose    = Not(Closeable),
                              Sizeable   = Resizeable,
                              Borderless = Borderless })

      scui.Windows[w.id].Borderless = Borderless
      scui.Windows[w.id].Resizeable = Resizeable
      scui.Windows[w.id].Closeable  = Closeable
   EndIf
EndFunction
Function scui.Win.GetPosition(WinName) ;----------------------------------------
   Local w = scui.Win.FindbyName(WinName)
   Return(GetAttribute(#DISPLAY, w.HWId, #ATTRXPOS), GetAttribute(#DISPLAY, w.HWId, #ATTRYPOS))
EndFunction
Function scui.Win.Get(WinName) ;------------------------------------------------
;---| Returns a table of the specified window, if the window does not exists
;   | nothing will be returned.
;   +---------------------------------------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.Get(WinName)", 
               WinName})

   Local w = scui.Win.FindByName(WinName)
   If helpers.IsNil(w)
         scui.Debug({"SCUILIB: scui.Win.Get() *** WARNING *** The window <" .. WinName .. "> does not exists!"})
         Return()
   EndIf

   Local Width, Height = scui.Win.GetSize(WinName)
   Local PosX, PosY    = scui.Win.GetPosition(WinName)
   Local w = scui.Windows[w.id]
   Return( { Position   = { x = PosX,  y = PosY },
             Size       = { w = Width, h = Height },
             Borderless = w.Borderless,
             Closeable  = w.Closeable,
             Resizeable = w.Resizeable,
             Opened     = w.Opened,
             Hidden     = w.Hidden } )
             
EndFunction
Function scui.Win.RenderGUI(WinName) ;------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.RenderGUI(WinName)", 
               WinName})

   If helpers.IsNil(WinName)
      Local wc = helpers.CountEntries(scui.Windows) - 1
      For Local i = 0 To wc
         scui.RenderObject(scui.Windows[i].RootGadget)
      Next
   Else
      Local w = scui.Win.FindByName(WinName)
      If helpers.IsNil(w)
            scui.Debug({"SCUILIB: scui.Win.Get() *** WARNING *** The window <" .. WinName .. "> does not exists!"})
            Return()
      EndIf
      scui.RenderObject(scui.Windows[w.id].RootGadget)
   EndIf
   
EndFunction
Function scui.Win.Status_New(Title, TextTable) ;--------------------------------
;---| Define and open a new Status Window, remember that only one of this
;   | kind of windows can be opened at a time so in it's already opened this
;   | function will fail.
;   | Returns True if the window is successfully created and opened, returns
;   | False in case of an error or warning.
;   | Title: the window's title
;   | TextTable: a table of 5 string entries
;   +---------------------------------------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.Status_New(Title, TextTable)", 
              Title,
              TextTable})

   If Not(scui.Win.Exists("*STATUS*"))
      scui.Win.New(   { Name        = "*STATUS*",
                        Title       = Title,
                        Position    = { #CENTER , #CENTER },
                        Size        = { 300, 120 },
                        Resizeable  = False ,
                        Hideable    = False ,
                        DontOpen    = False ,
                        Borderless  = False ,
                        Closeable   = False ,
                        OnClose     = Nil ,
                        OnMove      = Nil ,
                        OnSize      = Nil ,
                        OnHide      = Nil ,
                        OnShow      = Nil ,
                        OnActivate  = Nil ,
                        OnDeactivate= Nil ,
                        Modal       = False ,
                        AutoClose   = False } )
                        
      scui.Win.Select("*STATUS*")
      scui.PauseObjectRendering()
      scui.NewObject( #IFOCLASS_BEVELBOX , "*STATUS*GROUP*")
      scui.NewObject( #IFOCLASS_LABEL , "*STATUS*LABEL1*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Style = #TEXTSTYLE_BOLD , Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[0]}} )
      scui.NewObject( #IFOCLASS_LABEL , "*STATUS*LABEL2*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Style = #TEXTSTYLE_ITALIC , Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[1]}} )
      scui.NewObject( #IFOCLASS_LABEL , "*STATUS*LABEL3*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[2]}} )
      scui.NewObject( #IFOCLASS_LABEL , "*STATUS*LABEL4*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[3]}} )
      scui.NewObject( #IFOCLASS_LABEL , "*STATUS*LABEL5*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[4]}} )

      scui.AddChilds( "*STATUS*GROUP*", { "*STATUS*LABEL1*", "*STATUS*LABEL2*", "*STATUS*LABEL3*" , "*STATUS*LABEL4*" , "*STATUS*LABEL5*" }, nil,
                                   { Layout = #LAYOUTMODE_VERTICAL , 
                                     Borders = { Top = 0, Bottom = 0, Left = 0, Right = 0 }, 
                              Weights = { 0.32,              0.17,              0.17,               0.17,               0.17 }, Gap = 0 } )

      scui.ResumeObjectRendering()

      scui.Win.AttachGadgets("*STATUS*", "*STATUS*GROUP*")
   Else
      scui.Debug({"SCUILIB: scui.Win.Status_New() *** WARNING *** The Status Window already exists!"})
   EndIf
EndFunction
Function scui.Win.Status_Update(TextTable) ;------------------------------------
;---| This function will update an opened Status Window, returns True if
;   | update was successfully otherwise returns False.
;   | TextTable: a table with a maximum of 5 string entries
;   +---------------------------------------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.Status_Update(TextTable)",
               TextTable})

   If scui.Win.Exists("*STATUS*")
      If Not(helpers.IsNil(TextTable))
         Local l = helpers.CountEntries(TextTable) - 1
         For Local i = 0 To l
            Local labname = "*STATUS*LABEL" .. i+1 .. "*"
            Local lv = scui.Get(labname)
            If lv.Text.Content.Values[0] <> TextTable[i]
               scui.Set(labname, { Text = { Content = { Values = { TextTable[i] }}}}, 1)
            EndIf
         Next
      EndIf
      Return(True)
   Else
      scui.Debug({"SCUILIB: scui.Win.Gauge_Update() *** WARNING *** The Gauge Status Window does not exists!"})
   EndIf
   Return(False)
EndFunction
Function scui.Win.Status_Remove() ;---------------------------------------------
;---| Remove the Status Window from the screen, if the window is opened
;   | it will be closed automatically.
;   | Returns True if the window is successfully removed or False in case of
;   | an error/warning.
;   +---------------------------------------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.Status_Remove()"})

   If scui.Win.Exists("*STATUS*")
      Local result1 = scui.Win.Close("*STATUS*")
      Local result2 = scui.Win.Free("*STATUS*")
      If (result1 And result2)
         Return(True)
      Else
         scui.Debug({"SCUILIB: scui.Win.Status_Remove() *** WARNING *** An error on <scui.Win.Close> and/or <scui.Win.Free> has occurred!"})
      EndIf
   Else
      scui.Debug({"SCUILIB: scui.Win.Status_Remove() *** WARNING *** The Status Window does not exists!"})
   EndIf
   Return(False)
EndFunction
Function scui.Win.Gauge_New(Title, TextTable, GaugePattern, MMin, MMax) ;-------
;---| Define and open a new Gauge Status Window, remember that only one of this
;   | kind of windows can be opened at a time so in it's already opened this
;   | function will fail.
;   | Returns True if the window is successfully created and opened, returns
;   | False in case of an error or warning.
;   | Title: the window's title
;   | TextTable: a table of 5 string entries
;   | GaugePattern: a string pattern for the progress bar (see the Gauge docs)
;   | MMin: Minimum progress bar value
;   | MMax: Maximum progress bar value
;   +---------------------------------------------------------------------------
/*   scui.Debug({"SCUILIB: scui.Win.Gauge_New(Title, TextTable, GaugePattern, MMin, MMax)",
              Title,
              TextTable,
              GaugePattern,
              MMin,
              MMax})
              */
   Local hw, hh = SCUI.GetHostSize()
   
   If Not(scui.Win.Exists("*GAUGE*"))
      scui.Win.New(   { Name        = "*GAUGE*",
                        Title       = Title,
                        Position    = { #CENTER , #CENTER },
                        Size        = { hw/4, hh/5 },
                        Resizeable  = False ,
                        Hideable    = False ,
                        DontOpen    = False ,
                        Borderless  = False ,
                        Closeable   = False ,
                        OnClose     = Nil ,
                        OnMove      = Nil ,
                        OnSize      = Nil ,
                        OnHide      = Nil ,
                        OnShow      = Nil ,
                        OnActivate  = Nil ,
                        OnDeactivate= Nil ,
                        Modal       = False ,
                        AutoClose   = False } )

      scui.Win.Select("*GAUGE*")
      scui.PauseObjectRendering()
      scui.NewObject( #IFOCLASS_BEVELBOX , "*GAUGE*BG*")
      scui.NewObject( #IFOCLASS_LABEL , "*GAUGE*LABEL1*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Style = #TEXTSTYLE_BOLD + #ANTIALIAS, Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[0]}} )
      scui.NewObject( #IFOCLASS_LABEL , "*GAUGE*LABEL2*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Style = #TEXTSTYLE_ITALIC  + #ANTIALIAS, Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[1]}} )
      scui.NewObject( #IFOCLASS_LABEL , "*GAUGE*LABEL3*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[2]}} )
      scui.NewObject( #IFOCLASS_LABEL , "*GAUGE*LABEL4*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[3]}} )
      scui.NewObject( #IFOCLASS_LABEL , "*GAUGE*LABEL5*", nil, nil, { Bevel = scui.theme.EmptyBevel, Text = { Alignment = #TEXTALIGN_VCENTER + #TEXTALIGN_HCENTER } }, { Values = { TextTable[4]}} )
      scui.NewObject( #IFOCLASS_GAUGE , "*GAUGE*BAR*"   , nil, nil,
                      { Format = GaugePattern }, 
                      { MMin = MMin, MMax = MMax, Current = 0 } )

      scui.AddChilds( "*GAUGE*BG*", { "*GAUGE*LABEL1*", "*GAUGE*LABEL2*", "*GAUGE*LABEL3*", "*GAUGE*LABEL4*", "*GAUGE*LABEL5*", "*GAUGE*BAR*" }, nil,
                                   { Layout = #LAYOUTMODE_VERTICAL , 
                                     Borders = { Top = 0, Bottom = 0, Left = 0, Right = 0 }, 
                          Weights = { 0.16,             0.16,             0.16,             0.16,             0.16,             0.20 }, Gap = 0 } )
      scui.ResumeObjectRendering()

      scui.Win.AttachGadgets("*GAUGE*", "*GAUGE*BG*")
      Return(True)
   Else
      scui.Debug({"SCUILIB: scui.Win.Gauge_New() *** WARNING *** The Gauge Status Window already exists!"})
   EndIf
   Return(False)
EndFunction
Function scui.Win.Gauge_Update(TextTable, Current) ;----------------------------
;---| This function will update an opened Gauge Status Window, returns True if
;   | update was successfully otherwise returns False.
;   | TextTable: a table with a maximum of 5 string entries
;   | Current: current value of the progress bar
;   +---------------------------------------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.Gauge_Update(TextTable, Current)",
               TextTable,
               Current})

   If scui.Win.Exists("*GAUGE*")
      If Not(helpers.IsNil(TextTable))
         Local l = helpers.CountEntries(TextTable) - 1
         For Local i = 0 To l
            Local labname = "*GAUGE*LABEL" .. i+1 .. "*"
            Local lv = scui.Get(labname)
            If lv.Text.Content.Values[0] <> TextTable[i]
               scui.Set(labname, { Text = { Content = { Values = { TextTable[i] }}}}, 1)
            EndIf
         Next
      EndIf
      scui.Set("*GAUGE*BAR*", { Value = Current }, 1)
      Return(True)
   Else
      scui.Debug({"SCUILIB: scui.Win.Gauge_Update() *** WARNING *** The Gauge Status Window does not exists!"})
   EndIf
   Return(False)
EndFunction
Function scui.Win.Gauge_Remove() ;----------------------------------------------
;---| Remove the Gauge Status Window from the screen, if the window is opened
;   | it will be closed automatically.
;   | Returns True if the window is successfully removed or False in case of
;   | an error/warning.
;   +---------------------------------------------------------------------------
   scui.Debug({"SCUILIB: scui.Win.Gauge_Remove()"})

   If scui.Win.Exists("*GAUGE*")
      Local result1 = scui.Win.Close("*GAUGE*")
      Local result2 = scui.Win.Free("*GAUGE*")
      If (result1 And result2)
         Return(True)
      Else
         scui.Debug({"SCUILIB: scui.Win.Gauge_Remove() *** WARNING *** An error on <scui.Win.Close> and/or <scui.Win.Free> has occurred!"})
      EndIf
   Else
      scui.Debug({"SCUILIB: scui.Win.Gauge_Remove() *** WARNING *** The Gauge Status Window does not exists!"})
   EndIf
   Return(False)
EndFunction
Function scui.Win.Exists(WinName) ;---------------------------------------------
;---| Returns True if the <WinName> window is defined otherwise returns False.
;   +---------------------------------------------------------------------------
   Local tw = scui.Win.FindByName(WinName)

   If helpers.IsNil(tw)
      Return(False)
   Else
      Return(True)
   EndIf

EndFunction

Function scui.Icon.Add(IconName, Filename, Size) ;------------------------------
   ; Aggiunge una Icona al sistema
   ; STRUTTURA
   ;     Icons[IconName].
   ;        Filename
   ;        BrushId
  
   ; Controlla se esiste già
   If helpers.FieldIsNil(scui.Icons, IconName)
   
      ; Controlla se il file esiste
      If Exists(Filename)
      
         ; Controlla se il file specificato è una immagine
         If IsPicture(Filename)
         
            ; Creazione elemento
            Local icon_id = LoadBrush(nil, Filename, { LoadAlpha = True })
            
            ; Controlla se dev'essere ridimensionata
            If Not(helpers.IsNil(Size))
               Local bw = GetAttribute(#BRUSH, icon_id, #ATTRWIDTH)
               Local bh = GetAttribute(#BRUSH, icon_id, #ATTRHEIGHT)
               Local dw = bw - Size.w
               Local dh = bh - Size.h

               If dw > dh
                  Local wFactor = Size.w/bw
                  Local ysize = (bh * wFactor)
                  ScaleBrush(icon_id, Size.w, ysize, True)
               Else
                  Local hFactor = Size.h/bh
                  Local xsize = (bw * hFactor)
                  ScaleBrush(icon_id, xsize, Size.h, True)
               EndIf
               
            EndIf
            
            scui.Icons[IconName] = { Filename = Filename,
                                     BrushId  = icon_id   }
                                     
         Else
            DebugPrint("THE ICON FILENAME IS NOT AN IMAGE:" .. Filename)
         EndIf
      Else
         DebugPrint("ICON FILENAME DOES NOT EXISTS:" .. Filename)
      EndIf
   
   Else
      ; DebugPrint("ICON NAME ALREADY DEFINED!")
   EndIf
EndFunction
Function scui.Icon.Remove(IconName) ;-------------------------------------------
   ; Controlla se l'icona esiste
   If helpers.FieldIsNil(scui.Icons, IconName)
      DebugPrint("ICON NAME DOES NOT EXISTS")
   Else
      FreeBrush(scui.Icons[IconName].BrushId)
      scui.Icons[IconName] = Nil
   EndIf
EndFunction
Function scui.Icon.TClone(NewIconName, IconToCloneName, TintParams) ;-----------
   If helpers.FieldIsNil(scui.Icons, NewIconName)
   
      If Not(helpers.FieldIsNil(scui.Icons, IconToCloneName))
      
         Local icon_id = CopyBrush(scui.Icons[IconToCloneName].BrushId, nil)
         TintBrush(icon_id, TintParams.Color, TintParams.Level)
         
         scui.Icons[NewIconName] = { Filename = scui.Icons[IconToClonename].Filename,
                                     BrushId  = icon_id }
      
      Else
         DebugPrint("ICON DOES NOT EXISTS")
      EndIf
   
   Else
      DebugPrint("ICON NAME ALREADY EXISTS")
   EndIf
EndFunction
Function scui.Icon.Draw(IconName, Position) ;-----------------------------------
   ; Verifica se l'icona esiste
   If helpers.FieldIsNil(scui.Icons, IconName)
      DebugPrint("ICON NAME DOES NOT EXISTS")
   Else
      DisplayBrush(scui.Icons[IconName].BrushId, Position.x, Position.y)
   EndIf
EndFunction
Function scui.RemoveIcon(GadgetName, State)
   ; Sgancia le icone dal gadget
   Local gid = scui.GetIFOId(GadgetName)
   If gid < 0 Then scui.Debug({ "scui.RemoveIcon: Unknown GadgetName -->" .. GadgetName })
   
   Switch scui.IFO[gid].oClass
      Case  #IFOCLASS_BUTTON
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Text.Icon = Nil
            Case #IFOSTATUS_HILIGHTED
               scui.IFO[gid].oData.HText.Icon = Nil
            Case #IFOSTATUS_PUSHED
               scui.IFO[gid].oData.PText.Icon = Nil
            Case #IFOSTATUS_DISABLED
               scui.IFO[gid].oData.DText.Icon = Nil
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Text.Icon = Nil
               scui.IFO[gid].oData.HText.Icon = Nil
               scui.IFO[gid].oData.PText.Icon = Nil
               scui.IFO[gid].oData.DText.Icon = Nil
         EndSwitch
         
      Case #IFOCLASS_SWITCH
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Text.Icon = Nil
            Case #IFOSTATUS_HILIGHTED
               scui.IFO[gid].oData.HText.Icon = Nil
            Case #IFOSTATUS_PUSHED
               scui.IFO[gid].oData.PText.Icon = Nil
            Case #IFOSTATUS_DISABLED
               scui.IFO[gid].oData.DNText.Icon = Nil
               scui.IFO[gid].oData.DPText.Icon = Nil
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Text.Icon = Nil
               scui.IFO[gid].oData.HText.Icon = Nil
               scui.IFO[gid].oData.PText.Icon = Nil
               scui.IFO[gid].oData.DNText.Icon = Nil
               scui.IFO[gid].oData.DPText.Icon = Nil
         EndSwitch

      Case #IFOCLASS_LABEL
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Text.Icon = Nil
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Text.Icon = Nil
         EndSwitch

   EndSwitch
   
   scui.RenderObject(gid)

EndFunction
Function scui.AttachIcon(GadgetName, State, IconName, Alignment, AdjustText, Gap)
   ; Aggancia l'icona <IconName> al gadget <GadgetName>, in particolare l'icona
   ; viene associata allo stato <State> del gadget che puo' essere:
   ; BUTTON: #IFOSTATUS_NORMAL, #IFOSTATUS_PUSHED, #IFOSTATUS_HILIGHTED, #IFOSTATUS_DISABLED, #IFOSTATUS_ALL
   ; SWITCH: #IFOSTATUS_NORMAL, #IFOSTATUS_PUSHED, #IFOSTATUS_HILIGHTED, #IFOSTATUS_DISABLED, #IFOSTATUS_ALL
   ; LABEL : #IFOSTATUS_NORMAL, #IFOSTATUS_ALL
   ; <Alignment> specifica come deve essere allineata l'icona e puo' essere una
   ; combinazione delle seguenti costanti:
   ; Orizzintale: #ICONALIGN_LEFT, #ICONALIGN_HCENTER, #ICONALIGN_RIGHT
   ; Verticale  : #ICONALIGN_TOP, #ICONALIGN_VCENTER, #ICONALIGN_BOTTOM
   ; Generale   : #ICONALIGN_CENTER
   ; <AdjustText>, se impostato a TRUE, indica se il testo deve essere adattato
   ; per evitare sovrapposizioni.
   ; Per finire <Gap> indica la distanza fra l'icona e l'eventuale testo.
   
   Local gid = scui.GetIFOId(GadgetName)
   If gid < 0 Then scui.Debug({ "scui.AttachIcon: Unknown GadgetName -->" .. GadgetName })
   
   If helpers.IsNil(Gap) Then Gap = scui.theme.IconText_Gap
   
   Switch scui.IFO[gid].oClass
      Case  #IFOCLASS_BUTTON
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Text.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
            Case #IFOSTATUS_HILIGHTED
               scui.IFO[gid].oData.HText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
            Case #IFOSTATUS_PUSHED
               scui.IFO[gid].oData.PText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
            Case #IFOSTATUS_DISABLED
               scui.IFO[gid].oData.DText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Text.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
               scui.IFO[gid].oData.HText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
               scui.IFO[gid].oData.PText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
               scui.IFO[gid].oData.DText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
         EndSwitch
         
      Case #IFOCLASS_SWITCH
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Text.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
            Case #IFOSTATUS_HILIGHTED
               scui.IFO[gid].oData.HText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
            Case #IFOSTATUS_PUSHED
               scui.IFO[gid].oData.PText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
            Case #IFOSTATUS_DISABLED
               scui.IFO[gid].oData.DNText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
               scui.IFO[gid].oData.DPText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Text.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
               scui.IFO[gid].oData.HText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
               scui.IFO[gid].oData.PText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
               scui.IFO[gid].oData.DNText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
               scui.IFO[gid].oData.DPText.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
         EndSwitch

      Case #IFOCLASS_LABEL
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Text.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Text.Icon = { Name  = IconName, Align = Alignment, AdjText = AdjustText, Gap = Gap }
         EndSwitch

   EndSwitch
   
   scui.RenderObject(gid)
   
EndFunction
Function scui.Win.GetFullSize(WinName) ;----------------------------------------
   ; Returns the window SIZE Including window's borders
   Local win = scui.Win.FindByName(WinName)
   
   Local w = GetAttribute(#DISPLAY, win.HWId, #ATTRWIDTH) + GetAttribute(#DISPLAY, win.HWId, #ATTRBORDERLEFT) + GetAttribute(#DISPLAY, win.HWId, #ATTRBORDERRIGHT)
   Local h = GetAttribute(#DISPLAY, win.HWId, #ATTRWIDTH) + GetAttribute(#DISPLAY, win.HWId, #ATTRBORDERTOP) + GetAttribute(#DISPLAY, win.HWId, #ATTRBORDERBOTTOM)
   
   Return(w, h)
EndFunction
Function scui.ClosePopUp(msg) ;-----------------------------------| PRIVATE |---
   ; Private function used to close all PopUp windows
   Local wcount = helpers.CountEntries(scui.Windows)
   For Local i = (wcount-1) To 0 Step -1
      If Not(helpers.FieldIsNil(scui.Windows[i], "ismenu"))
         scui.Win.Close(scui.Windows[i].Name)
         scui.Win.Free(scui.Windows[i].Name)
      EndIf
   Next
EndFunction
Function scui.ClosePopUpDeactivate(msg) ;-------------------------| PRIVATE |---
   ; Private function used to close all PopUp window if anyone is active
   ; or to close only the secondary windows if one parent is active
   Local wcount = helpers.CountEntries(scui.Windows)
   Local CloseAll = True
   Local Active = -1
   For Local i = 0 To wcount - 1
      If Not(helpers.FieldIsNil(scui.Windows[i], "ismenu"))
         If GetAttribute(#DISPLAY, scui.Windows[i].HWId, #ATTRACTIVE) = 1
            CloseAll = False
            Active = i
         EndIf
      EndIf
   Next
   If CloseAll
      scui.ClosePopUp()
   Else
      ; Verifica se deve chiudere un sottomenu'
      If Active = wcount - 1 Then Return
      For Local i = (wcount - 1) To (Active + 1) Step -1
         If Not(helpers.FieldIsNil(scui.Windows[i], "ismenu"))
            scui.Win.Close(scui.Windows[i].Name)
            scui.Win.Free(scui.Windows[i].Name)
         EndIf
      Next
   EndIf
EndFunction

Function scui.Win.PopUp_MakeItems(WName, CycleName)
; SOLO PER MULTIPAGE
   Local w = scui.Win.FindByName(WName)
   Local win = scui.Windows[w.id]
   
   Local items_count = win.ItemsCount - 1
   Local items       = win.ItemList
   Local first_item  = win.FirstShowed
   Local last_item   = first_item + win.ItemsPerPage - 1
   
   Local blank_items = 0
   
   DebugPrint("Removing old items")
   For Local i = 0 To helpers.CountEntries(win.ItemGadgets) - 1
      scui.RemoveObject(win.ItemGadgets[i])
   Next
   
   If last_item > items_count
      blank_items = last_item - items_count
      last_item   = items_count
   EndIf
   
      
   
   Local item_list    = {}
   Local item_weights = {}
   Local weight       = 1/(Win.ItemsPerPage + IIF(win.HasTitle, 1, 0) + 1)
   
   Local count_start = 0
   If win.HasTitle
      count_start = 1
      item_list[0] = win.TitleGadget
      item_weights[0] = weight
   EndIf
   
   scui.PauseObjectRendering()
   
   Local cnt = 0
   DebugPrint("Creating Items FROM:", first_item, "TO:", last_item, "END SHOULD BE:", first_item + win.ItemsPerPage - 1, "Items COunt:", items_count)
   DebugPrint("count_start:", count_start)
   For Local i = first_item To last_item
      Local it = 0
      
      If helpers.FieldIsNil(items[i], "status") Then items[i].Status = #IFO_ENABLED
      
      Switch items[i].Type
         Case #IFOCLASS_BUTTON
            item_name = WName .. "*Item_" .. StrStr(i+count_start)

            it = scui.NewObject( #IFOCLASS_BUTTON , item_name,  nil, nil, { Bevel  = scui.theme.PopUp_Button_NBox,
                                                                       Text   = scui.theme.PopUp_Button_NText,
                                                                       HBevel = scui.theme.PopUp_Button_HBox,
                                                                       HText  = scui.theme.PopUp_Button_HText,
                                                                       PBevel = scui.theme.PopUp_Button_PBox,
                                                                       PText  = scui.theme.PopUp_Button_PText,
                                                                       DBevel = scui.theme.PopUp_Button_DBox,
                                                                       DText  = scui.theme.PopUp_Button_DText,
                                                                       Enabled = items[i].Status }, { Values = { items[i].data.Caption }}, { OnPushed  = items[i].data.Action } )
            scui.IFO[it].menu_item = 0
            item_weight = weight
            InsertItem(win.ItemGadgets, it)
            If Not(helpers.IsNil(CycleName)) Then scui.IFO[it].CycleName = CycleName

        Case #IFOCLASS_LABEL
            item_name = WName .. "*Item_" .. StrStr(i+count_start)

            it = scui.NewObject( #IFOCLASS_LABEL , item_name , nil, nil, { Bevel = scui.theme.PopUp_LabelBevel, 
                                                                      Text  = scui.theme.PopUp_LabelText }, { Values = { items[i].data.Caption }} )
            scui.IFO[it].menu_item = 0
            item_weight = weight
            InsertItem(win.ItemGadgets, it)

        Case #IFOCLASS_SWITCH
            item_name = WName .. "*Item_" .. StrStr(i+count_start)

            it = scui.NewObject( #IFOCLASS_SWITCH , item_name, nil, nil, { Bevel  = scui.theme.PopUp_Switch_NBox,
                                                                      HBevel = scui.theme.PopUp_Switch_HBox,
                                                                      PBevel = scui.theme.PopUp_Switch_PBox,
                                                                      DPBevel= scui.theme.PopUp_Switch_DPBox, 
                                                                      DNBevel= scui.theme.PopUp_Switch_DNBox,
                                                                      Text   = scui.theme.PopUp_Switch_Text,
                                                                      HText  = scui.theme.PopUp_Switch_HText,
                                                                      PText  = scui.theme.PopUp_Switch_PText,
                                                                      DPText = scui.theme.PopUp_Switch_DPText,
                                                                      DNText = scui.theme.PopUp_Switch_DNText,
                                                                      Enabled = items[i].Status } , { Value = items[i].data.Value, Values = { items[i].data.Caption }}, 
                                                                    { OnChanged = items[i].data.Action } )
            scui.IFO[it].menu_item = 0
            item_weight = weight
            InsertItem(win.ItemGadgets, it)

        Case #IFOCLASS_OPTIONS
            item_name = WName .. "*Item_" .. StrStr(i+count_start)
            item_weight = weight * helpers.CountEntries(items[i].data.OptionsList)

            ; Tema in base al tipo di popup che può essere standard o cycle
            If helpers.FieldIsNil(tags, "cyclename")
               ; *** STANDARDS ***
               it = scui.NewObject( #IFOCLASS_OPTIONS , item_name, nil, nil, { Container = scui.theme.PopUp_Options_Container,
                                                                          NSwitch  = scui.theme.PopUp_Options_NBox,
                                                                          HSwitch  = scui.theme.PopUp_Options_HBox,
                                                                          PSwitch  = scui.theme.PopUp_Options_PBox,
                                                                          SwiNText = scui.theme.PopUp_Options_NText,    
                                                                          SwiHText = scui.theme.PopUp_Options_HText,    
                                                                          SwiPText = scui.theme.PopUp_Options_PText,    
                                                                          NLabel   = scui.theme.PopUp_Options_LabelBox,
                                                                          LabelText= scui.theme.PopUp_Options_LabelText,
                                                                          Enabled = items[i].Status },
                                                      { Columns = 1, Rows = helpers.CountEntries(items[i].data.OptionsList),
                                                        Mode = items[i].data.OptionsMode,
                                                        Options = items[i].data.OptionsList,
                                                        DefaultOptions = items[i].data.DefaultOptions,
                                                        SwitchWidth = ItemHeight,
                                                        SwitchPosition = OptionsSwitchPosition ,
                                                        SwitchMode = OptionsSwitchType },
                                                        { OnChanged = items[i].data.Action } )
               scui.IFO[it].menu_item = 0
               item_weight = weight * helpers.CountEntries(items[i].data.OptionsList)
               InsertItem(win.ItemGadgets, it)

            Else
               ; *** CYCLE ***
               it = scui.NewObject( #IFOCLASS_OPTIONS , item_name, nil, nil, { Container = scui.theme.PopUp_Cycle_Container,
                                                                          NSwitch  = scui.theme.PopUp_Cycle_NBox,
                                                                          HSwitch  = scui.theme.PopUp_Cycle_HBox,
                                                                          PSwitch  = scui.theme.PopUp_Cycle_PBox,
                                                                          SwiNText = scui.theme.PopUp_Cycle_NText,    
                                                                          SwiHText = scui.theme.PopUp_Cycle_HText,    
                                                                          SwiPText = scui.theme.PopUp_Cycle_PText,    
                                                                          NLabel   = scui.theme.PopUp_Cycle_LabelBox,
                                                                          LabelText= scui.theme.PopUp_Cycle_LabelText,
                                                                          Enabled = items[i].Status },
                                                      { Columns = 1, Rows = helpers.CountEntries(items[i].data.OptionsList),
                                                        Mode = items[i].data.OptionsMode,
                                                        Options = items[i].data.OptionsList,
                                                        DefaultOptions = items[i].data.DefaultOptions,
                                                        SwitchWidth = ItemHeight,
                                                        SwitchPosition = OptionsSwitchPosition ,
                                                        SwitchMode = OptionsSwitchType },
                                                        { OnChanged = items[i].data.Action } )
               scui.IFO[it].menu_item = 0
               scui.IFO[it].CycleName = tags.CycleName

            EndIf
            

        Case #IFOCLASS_SUBMENU
            item_name = WName .. "*Item_" .. StrStr(i+count_start)
            item_weight = weight
            it = scui.NewObject( #IFOCLASS_BUTTON , item_name,  nil, nil, { Bevel  = scui.theme.PopUp_Button_NBox,
                                                                       Text   = scui.theme.PopUp_Button_NText,
                                                                       HBevel = scui.theme.PopUp_Button_HBox,
                                                                       HText  = scui.theme.PopUp_Button_HText,
                                                                       PBevel = scui.theme.PopUp_Button_PBox,
                                                                       PText  = scui.theme.PopUp_Button_PText,
                                                                       DBevel = scui.theme.PopUp_Button_DBox,
                                                                       DText  = scui.theme.PopUp_Button_DText,
                                                                       Enabled = items[i].Status }, { Values = { items[i].data.Caption }} )
            scui.IFO[it].menu_item = 1
            scui.IFO[it].menu_sub  = items[i].data.items

      EndSwitch
      item_list[cnt + count_start] = item_name
      item_weights[cnt + count_start] = item_weight
      cnt = cnt + 1
   Next
   
   ;count_start = last_item + 1
   
   For Local i = (last_item + 1) To (first_item + win.ItemsPerPage - 2)
      scui.Windows[w.id].LastPage = True
      DebugPrint("Creating BLANK item ", i)

      item_name = WName .. "*Item_" .. StrStr(i+count_start)

      it = scui.NewObject( #IFOCLASS_LABEL , item_name , nil, nil, { Bevel = scui.theme.PopUp_LabelBevel, 
                                                                Text  = scui.theme.PopUp_LabelText }, { Values = { "" }} )
      scui.IFO[it].menu_item = 0
      item_weight = weight
      InsertItem(win.ItemGadgets, it)

      item_list[cnt + count_start] = item_name
      item_weights[cnt + count_start] = item_weight
      cnt = cnt + 1
   Next
   
   item_list[cnt + count_start] = win.PagerBox
   item_weights[cnt + count_start] = weight
DebugPrint("POSITION:", cnt + count_start, " PAGERBOX ID:", win.PagerBox)
   scui.AddChilds( WName .. "*BG", item_list, nil,
                                { Layout = #LAYOUTMODE_VERTICAL , 
                                  Borders = { Top = 1, Bottom = 1, Left = 2, Right = 2 }, 
                    Weights = item_weights, Gap = 1 } )

   scui.ResumeObjectRendering()
   scui.Win.RenderGUI(WName)

EndFunction

Function scui.Win.PopUp(position, items, tags, CycleName ) ;-----------------| PRIVATE |---
   ; Create a PopUp window.
   ; <position> represent the coordinates where we want to open the PopUp
   ; <items> is a table where the menu structure is defined
   ;
   ; <Items> has the collowing structure:
   ; items = { MenuName = menu_name,
   ;           { item1, item2, item3, ... }
   ; item1 can be a Button, a Switch, a Label, an Option Box or a SubItem
   ;
   ; BUTTON
   ; item1 = { Type = #IFOCLASS_BUTTON, status = #IFO_ENABLED|#IFO_DISABLED,
   ;           data = { Caption = "button_text", 
   ;                    Action = function_name  } }
   ;
   ; SWITCH
   ; item1 = { Type = #IFOCLASS_SWITCH, status = #IFO_ENABLED|#IFO_DISABLED,
   ;           data = { Caption = "button_text", 
   ;                    Value = 0|1, 
   ;                    Action = function_name  } }
   ;
   ; OPTIONS
   ; item1 = { Type = #IFOCLASS_OPTIONS, status = #IFO_ENABLED|#IFO_DISABLED,
   ;           data = { OptionsList = { ... }, 
   ;                    DefaultOptions = { ... }, 
   ;                    OptionsMode = #OPTMODE_FREE|#OPTMODE_ONLYONE, 
   ;                    Action = function_name}
   ; 
   ; LABEL
   ; item1 = { Type = #IFOCLASS_LABEL,
   ;           data = { Caption = label_text } }
   ;
   ; SUBITEM
   ; item1 = { Type = #IFOCLASS_SUBMENU,
   ;         { complete menu structure with MenuName and subitems if needed }
   ;
   ; TAGS
   ; <MenuTitle>     True|False, use the MenuName as Menu title, if False do not
   ;                 show the menu title.
   ; <ItemHeight>    Use #POPUP_ITEMHEIGHT_AUTO for auto size or specify a 
   ;                 value expressed in pixels.
   ; <PopUpWidth>    Use #POPUP_MENUWIDTH_AUTO for auto size or specify a value
   ;                 expressed in pixels.
   ; <Draggable>     True|False, set to True if you want this pop-up to be
   ;                 draggable: MenuTitle must be set to True too
   
   ; CycleName

   ; Impostazioni di default
   Local MenuTitle = True
   Local ItemHeight  = #POPUP_ITEMHEIGHT_AUTO
   Local WindowWidth = #POPUP_MENUWIDTH_AUTO
   Local Draggable = False
   
   Local FullHeightGap = 20
   Local FullHeightPos = 0

   ; Verifica le preferenze specificate
   If Not(helpers.IsNil(tags))
      If Not(helpers.FieldIsNil(tags, "menutitle"  )) Then MenuTitle   = tags.MenuTitle
      If Not(helpers.FieldIsNil(tags, "itemheight" )) Then ItemHeight  = tags.ItemHeight
      If Not(helpers.FieldIsNil(tags, "popupwidth" )) Then WindowWidth = tags.PopUpWidth
      If Not(helpers.FieldIsNil(tags, "draggable"  )) Then Draggable   = tags.Draggable
   EndIf
   
   ; Calcola l'altezza automatica
   If ItemHeight = #POPUP_ITEMHEIGHT_AUTO
      ItemHeight = TextHeight("gl") + 8
   EndIf

   ; Numero elementi nel menu
   Local items_count = helpers.CountEntries(items) - 1

   ; Calcola la larghezza del PopUp automatica
   If WindowWidth = #POPUP_MENUWIDTH_AUTO
      WindowWidth = TextWidth(items.MenuName)
      For Local i = 0 To items_count - 1
         If items[i].Type = #IFOCLASS_OPTIONS
            Local c = helpers.CountEntries(items[i].data.OptionsList)
            For Local ii = 0 To c-1
               Local ww = TextWidth(items[i].data.OptionsList[ii]) + ItemHeight
               If ww > WindowWidth Then WindowWidth = ww
            Next
         Else
            Local ww = TextWidth(items[i].data.Caption)
            If ww > WindowWidth Then WindowWidth = ww
         EndIf
      Next
      
      WindowWidth = WindowWidth + 16
   EndIf
   
   ; Legge le impostazioni per gli Options
   Local OptionsSwitchPosition = #OPT_RIGHTSWITCH
   Local OptionsSwitchType     = #OPTSWITCH_FULLWIDTH
   
   If helpers.IsNil(tags, "cyclename")
      OptionsSwitchPosition = scui.theme.SwitchesMode
      OptionsSwitchType     = scui.theme.SwitchesType
   EndIf
   
   ; Rettifica il numero delle righe in caso di elementi Options   
   Local rows = 0
   For Local i = 0 To items_count - 1
      If items[i].Type = #IFOCLASS_OPTIONS 
         rows = rows + helpers.CountEntries(items[i].data.OptionsList)
      Else
         rows = rows + 1
      EndIf
   Next
   
   ; Nome finestra
   Local WName = items.MenuName

   ; Se la finestra esiste gia' esce
   If scui.Win.Exists(WName)
      DebugPrint("Cannot create PopUp: window name already in use")
      Return
   EndIf
   
   Local items_to_show = 0
   
   ; Se ci sono elementi da visualizzare crea il PopUp
   If items_count > 0
      Local WindowHeight = rows * ItemHeight
      ; Se devo mostrare il titolo incremento il numero delle righe
      If MenuTitle
         WindowHeight = WindowHeight + ItemHeight
         rows = rows + 1
      EndIf 

      ; Verifica le coordinate
      Local win_xend = position[0] + WindowWidth
      Local win_yend = position[1] + WindowHeight
      Local scr_xend, scr_yend = scui.GetHostSize()
      Local delta_x = scr_xend - win_xend
      Local delta_y = scr_yend - win_yend
      
      If delta_x < 0 Then position[0] = position[0] + delta_x - 1
      If delta_y < 0 Then position[1] = position[1] + delta_y - 1
      
      ; Se il PopUp non entra nello schermo esce (almeno per ora)
      Local MultiPage = False
      Local ItemsToShow = -1
      If position[0] < 0 Or position[1] < 0
         ;DebugPrint("TOO MUCH ITEMS IN POPUP MENU!")
         ;Return

         MultiPage = True
         ; Calcolo quante righe posso inserire al massimo nel popup e aggiungo
         ; anche una riga dove inseriro' i pulsanti di spostamento pagina
         
         ; Innanzitutto recupero l'altezza utile per gli elementi
         Local AreaHeight = scr_yend - FullHeightGap
         FullHeightPos = FullHeightGap / 2
         position[1] = FullHeightPos
         
         ; Tolgo subito la dimensione necessaria alla riga per cambiare le pagine
         WindowHeight = AreaHeight
         Local YSize = AreaHeight - ItemHeight
         
         ; Adesso eseguo un ciclo che si fermera' quando l'area diventa negativa
         ; in maniera da contare quanti elementi posso includere nel popup
         Local counter = -1
         
         
         While YSize > 0

            counter = counter + 1
            If counter > items_count Then YSize = 0
            
            If items[counter].Type = #IFOCLASS_OPTIONS
               YSize = YSize - helpers.CountEntries(items[counter].data.OptionsList) * ItemHeight
            Else
               YSize = YSize - ItemHeight
            EndIf

         Wend
         

         ItemHeight = WindowHeight / counter

         ItemsToShow = counter
         items_to_show = ItemsToShow

         If MenuTitle Then ItemsToShow = ItemsToShow - 1
         
      EndIf
      
      ; Creazione finestra
      scui.Win.New(   { Name        = WName,
                        Title       = Title,
                        Position    = { position[0] , position[1] },
                        Size        = { WindowWidth, WindowHeight },
                        Resizeable  = False ,
                        Hideable    = False ,
                        DontOpen    = False ,
                        Borderless  = True ,
                        Closeable   = False ,
                        OnClose     = Nil ,
                        OnMove      = Nil ,
                        OnSize      = Nil ,
                        OnHide      = Nil ,
                        OnShow      = Nil ,
                        OnActivate  = Nil ,
                        OnDeactivate= scui.ClosePopUpDeactivate ,
                        Modal       = False ,
                        AutoClose   = False } )

      scui.Win.Activate(WName)

      ; Verifica se il PopUp puo' essere spostato o meno
      If Not(Draggable Or MenuTitle) Then SetDisplayAttributes({ Fixed = True })
      
      Local www = scui.Win.FindByName(WName)
      scui.Windows[www.id].IsMenu = True
            
      ; Main Container Box
      scui.NewObject( #IFOCLASS_BEVELBOX , WName .. "*BG" , { x = 0, y = 0 }, { x = WindowWidth-1, y = WindowHeight-1 }, { Bevel = scui.theme.PopUp_Container } )

      ; Crea i pulsanti del popup
      Local item_list = {}
      Local item_weights = {}
      Local item_weight = 0
      Local item_name = ""
      Local count_start = 0

      scui.PauseObjectRendering()

      Local title_gad = -1
      
      If MenuTitle
         item_name = WName .. "*Item_" .. StrStr(0)
         item_weight = 1/rows
         If MultiPage Then item_weight = 1/(ItemsToShow + 1)
         it = scui.NewObject( #IFOCLASS_LABEL , item_name , nil, nil, { Bevel = scui.theme.PopUp_TLabelBevel, 
                                                                   Text  = scui.theme.PopUp_TLabelText }, { Values = { WName }} )
         scui.IFO[it].menu_item = 0
         title_gad = it
         item_list[0] = item_name
         item_weights[0] = item_weight
         count_start = 1
      EndIf
      
      If MultiPage
         items_count = ItemsToShow
         scui.Windows[www.id].ItemGadgets  = {}
         scui.Windows[www.id].ItemList     = Items
         scui.Windows[www.id].FirstShowed  = 0
         scui.Windows[www.id].ItemsCount   = helpers.CountEntries(Items) - 1
         scui.Windows[www.id].ItemsPerPage = items_to_show
         scui.Windows[www.id].HasTitle     = IIF(MenuTitle, True , False)
         scui.Windows[www.id].TitleGadget  = title_gad
         scui.Windows[www.id].LastPage     = False
      EndIf

      
      For Local i = 0 To items_count - 1

         Local it = 0
         
         If helpers.FieldIsNil(items[i], "status") Then items[i].Status = #IFO_ENABLED
         
         Switch items[i].Type
            Case #IFOCLASS_BUTTON
               item_name = WName .. "*Item_" .. StrStr(i+count_start)
               item_weight = 1/rows

               it = scui.NewObject( #IFOCLASS_BUTTON , item_name,  nil, nil, { Bevel  = scui.theme.PopUp_Button_NBox,
                                                                          Text   = scui.theme.PopUp_Button_NText,
                                                                          HBevel = scui.theme.PopUp_Button_HBox,
                                                                          HText  = scui.theme.PopUp_Button_HText,
                                                                          PBevel = scui.theme.PopUp_Button_PBox,
                                                                          PText  = scui.theme.PopUp_Button_PText,
                                                                          DBevel = scui.theme.PopUp_Button_DBox,
                                                                          DText  = scui.theme.PopUp_Button_DText,
                                                                          Enabled = items[i].Status }, { Values = { items[i].data.Caption }}, { OnPushed  = items[i].data.Action } )
               scui.IFO[it].menu_item = 0
               If MultiPage
                  item_weight = 1/(ItemsToShow + 1)
                  InsertItem(scui.Windows[www.id].ItemGadgets, it)
               EndIf
               If Not(helpers.IsNil(CycleName))
                  scui.IFO[it].CycleName = CycleName
               EndIf
               
           Case #IFOCLASS_LABEL
               item_name = WName .. "*Item_" .. StrStr(i+count_start)
               item_weight = 1/rows

               it = scui.NewObject( #IFOCLASS_LABEL , item_name , nil, nil, { Bevel = scui.theme.PopUp_LabelBevel, 
                                                                         Text  = scui.theme.PopUp_LabelText }, { Values = { items[i].data.Caption }} )
               scui.IFO[it].menu_item = 0
               If MultiPage
                  item_weight = 1/(ItemsToShow + 1)
                  InsertItem(scui.Windows[www.id].ItemGadgets, it)
               EndIf

           Case #IFOCLASS_SWITCH
               item_name = WName .. "*Item_" .. StrStr(i+count_start)
               item_weight = 1/rows

               it = scui.NewObject( #IFOCLASS_SWITCH , item_name, nil, nil, { Bevel  = scui.theme.PopUp_Switch_NBox,
                                                                         HBevel = scui.theme.PopUp_Switch_HBox,
                                                                         PBevel = scui.theme.PopUp_Switch_PBox,
                                                                         DPBevel= scui.theme.PopUp_Switch_DPBox, 
                                                                         DNBevel= scui.theme.PopUp_Switch_DNBox,
                                                                         Text   = scui.theme.PopUp_Switch_Text,
                                                                         HText  = scui.theme.PopUp_Switch_HText,
                                                                         PText  = scui.theme.PopUp_Switch_PText,
                                                                         DPText = scui.theme.PopUp_Switch_DPText,
                                                                         DNText = scui.theme.PopUp_Switch_DNText,
                                                                         Enabled = items[i].Status } , { Value = items[i].data.Value, Values = { items[i].data.Caption }}, 
                                                                       { OnChanged = items[i].data.Action } )
               scui.IFO[it].menu_item = 0
               If MultiPage
                  item_weight = 1/(ItemsToShow + 1)
                  InsertItem(scui.Windows[www.id].ItemGadgets, it)
               EndIf

           Case #IFOCLASS_OPTIONS
               item_name = WName .. "*Item_" .. StrStr(i+count_start)
               item_weight = (1/rows) * helpers.CountEntries(items[i].data.OptionsList)

               ; Tema in base al tipo di popup che può essere standard o cycle
               If helpers.FieldIsNil(tags, "cyclename")
                  ; *** STANDARDS ***
                  it = scui.NewObject( #IFOCLASS_OPTIONS , item_name, nil, nil, { Container = scui.theme.PopUp_Options_Container,
                                                                             NSwitch  = scui.theme.PopUp_Options_NBox,
                                                                             HSwitch  = scui.theme.PopUp_Options_HBox,
                                                                             PSwitch  = scui.theme.PopUp_Options_PBox,
                                                                             SwiNText = scui.theme.PopUp_Options_NText,    
                                                                             SwiHText = scui.theme.PopUp_Options_HText,    
                                                                             SwiPText = scui.theme.PopUp_Options_PText,    
                                                                             NLabel   = scui.theme.PopUp_Options_LabelBox,
                                                                             LabelText= scui.theme.PopUp_Options_LabelText,
                                                                             Enabled = items[i].Status },
                                                         { Columns = 1, Rows = helpers.CountEntries(items[i].data.OptionsList),
                                                           Mode = items[i].data.OptionsMode,
                                                           Options = items[i].data.OptionsList,
                                                           DefaultOptions = items[i].data.DefaultOptions,
                                                           SwitchWidth = ItemHeight,
                                                           SwitchPosition = OptionsSwitchPosition ,
                                                           SwitchMode = OptionsSwitchType },
                                                           { OnChanged = items[i].data.Action } )
                  scui.IFO[it].menu_item = 0
                  If MultiPage
                     item_weight = 1/(ItemsToShow + 1) * helpers.CountEntries(items[i].data.OptionsList)
                     InsertItem(scui.Windows[www.id].ItemGadgets, it)
                  EndIf

               Else
                  ; *** CYCLE ***
                  it = scui.NewObject( #IFOCLASS_OPTIONS , item_name, nil, nil, { Container = scui.theme.PopUp_Cycle_Container,
                                                                             NSwitch  = scui.theme.PopUp_Cycle_NBox,
                                                                             HSwitch  = scui.theme.PopUp_Cycle_HBox,
                                                                             PSwitch  = scui.theme.PopUp_Cycle_PBox,
                                                                             SwiNText = scui.theme.PopUp_Cycle_NText,    
                                                                             SwiHText = scui.theme.PopUp_Cycle_HText,    
                                                                             SwiPText = scui.theme.PopUp_Cycle_PText,    
                                                                             NLabel   = scui.theme.PopUp_Cycle_LabelBox,
                                                                             LabelText= scui.theme.PopUp_Cycle_LabelText,
                                                                             Enabled = items[i].Status },
                                                         { Columns = 1, Rows = helpers.CountEntries(items[i].data.OptionsList),
                                                           Mode = items[i].data.OptionsMode,
                                                           Options = items[i].data.OptionsList,
                                                           DefaultOptions = items[i].data.DefaultOptions,
                                                           SwitchWidth = ItemHeight,
                                                           SwitchPosition = OptionsSwitchPosition ,
                                                           SwitchMode = OptionsSwitchType },
                                                           { OnChanged = items[i].data.Action } )
                  scui.IFO[it].menu_item = 0
                  scui.IFO[it].CycleName = tags.CycleName

               EndIf
               

           Case #IFOCLASS_SUBMENU
               item_name = WName .. "*Item_" .. StrStr(i+count_start)
               item_weight = 1/rows
               it = scui.NewObject( #IFOCLASS_BUTTON , item_name,  nil, nil, { Bevel  = scui.theme.PopUp_Button_NBox,
                                                                          Text   = scui.theme.PopUp_Button_NText,
                                                                          HBevel = scui.theme.PopUp_Button_HBox,
                                                                          HText  = scui.theme.PopUp_Button_HText,
                                                                          PBevel = scui.theme.PopUp_Button_PBox,
                                                                          PText  = scui.theme.PopUp_Button_PText,
                                                                          DBevel = scui.theme.PopUp_Button_DBox,
                                                                          DText  = scui.theme.PopUp_Button_DText,
                                                                          Enabled = items[i].Status }, { Values = { items[i].data.Caption }} )
               scui.IFO[it].menu_item = 1
               scui.IFO[it].menu_sub  = items[i].data.items

         EndSwitch
         item_list[i+count_start] = item_name
         item_weights[i+count_start] = item_weight
      Next
      
If MultiPage

      ; Verifico se devo agganciare i pulsanti di cambio pagina
      ; Pager buttons container
      Local pagerbox = scui.NewObject( #IFOCLASS_BEVELBOX , WName .. "*PagerBox" , Nil, Nil, { Bevel = scui.theme.PopUp_Container } )
      item_list[items_count] = WName .. "*PagerBox"
      item_weights[items_count] = item_weight
      scui.Windows[www.id].PagerBox = pagerbox
      
      Local it = scui.NewObject( #IFOCLASS_BUTTON , WName .. "*Pager*Prev",  nil, nil, { Enabled = #IFO_DISABLED }, { Values = { "<<" }}, { OnPushed  = scui.NULLFUNC }); scui.HandleCyclePager } )
      scui.IFO[it].menu_item = -1
      scui.IFO[it].CycleName = CycleName
      Local it = scui.NewObject( #IFOCLASS_BUTTON , WName .. "*Pager*Next",  nil, nil, { Enabled = #IFO_ENABLED }, { Values = { ">>" }}, { OnPushed  = scui.NULLFUNC }); scui.HandleCyclePager } )                                                                 
      scui.IFO[it].menu_item = -1
      scui.IFO[it].CycleName = CycleName
EndIf
      scui.Win.AttachGadgets(WName , WName .. "*BG")

      scui.AddChilds( WName .. "*BG", item_list, nil,
   				                    { Layout = #LAYOUTMODE_VERTICAL , 
                                     Borders = { Top = 1, Bottom = 1, Left = 2, Right = 2 }, 
   					     Weights = item_weights, Gap = 1 } )
If MultiPage
      scui.AddChilds( WName .. "*PagerBox", { WName .. "*Pager*Prev", WName .. "*Pager*Next"}, nil,
   				                    { Layout = #LAYOUTMODE_HORIZONTAL , 
                                     Borders = { Top = 1, Bottom = 1, Left = 1, Right = 1 }, 
   					     Weights = { 0.5, 0.5 }, Gap = 1 } )
EndIf

      scui.ResumeObjectRendering()
      scui.Win.RenderGUI(WName)
      Return(WName)
     
   EndIf
   
EndFunction
Function helpers.WaitForArexxPort(PortName, Command, Timeout_ms)
   ; Attende fino a che la porta arexx non viene rilevata o fino
   ; a che non avviene il timeout
   ; ritorna true se la porta viene rilevata, altrimenti ritorna false
   Local running = True
   Local timer_id = StartTimer(Nil)
   Local result = False
   Local err_code = 0
   
   While running = True
      ExitOnError(False)
      SendRexxCommand(PortName, Command)
      err_code = GetLastError()
      ExitOnError(True)
      
      If err_code = 0
         result = True
         running = False
      EndIf
      If GetTimer(timer_id) > Timeout_ms
         result = False
         running = False
      EndIf
      Wait(10)
   Wend
   
   Return(result)
EndFunction

Function scui.Picture.Add(PictureName, Filename, Size, Alpha)
   ; Aggiunge una Immagine al sistema
   ; STRUTTURA
   ;     Pictures[IconName].
   ;        Filename
   ;        BrushId
   
   ; Controlla se esiste già
   If helpers.FieldIsNil(scui.Pictures, PictureName)
   
      ; Controlla se il file esiste
      If Exists(Filename)

         ; Controlla se il file specificato è una immagine
         If IsPicture(Filename)
         
            ; Creazione elemento
            Local picture_id = -1
            If Alpha
               picture_id = LoadBrush(nil, Filename, { LoadAlpha = True })
            Else
               picture_id = LoadBrush(nil, Filename)
            EndIf

            ; Controlla se dev'essere ridimensionata
            If Not(helpers.IsNil(Size))
               Local bw = GetAttribute(#BRUSH, picture_id, #ATTRWIDTH)
               Local bh = GetAttribute(#BRUSH, picture_id, #ATTRHEIGHT)
               Local dw = bw - Size.w
               Local dh = bh - Size.h

               If dw > dh
                  Local wFactor = Size.w/bw
                  Local ysize = (bh * wFactor)
                  ScaleBrush(picture_id, Size.w, ysize, True)
               Else
                  Local hFactor = Size.h/bh
                  Local xsize = (bw * hFactor)
                  ScaleBrush(picture_id, xsize, Size.h, True)
               EndIf
               
            EndIf
            
            scui.Pictures[PictureName] = { Filename = Filename,
                                           BrushId  = picture_id   }
                                     
         Else
            DebugPrint("THE PICTURE FILENAME IS NOT AN IMAGE")
         EndIf
      Else
         DebugPrint("PICTURE FILENAME DOES NOT EXISTS:", Filename)
      EndIf
   
   Else
      ;DebugPrint("PICTURE NAME ALREADY DEFINED!")
   EndIf
EndFunction
Function scui.Picture.Remove(PictureName)
   ; Controlla se l'icona esiste
   If helpers.FieldIsNil(scui.Pictures, PictureName)
      DebugPrint("PICTURE NAME DOES NOT EXISTS:", PictureName)
   Else
      FreeBrush(scui.Pictures[PictureName].BrushId)
      scui.Picturess[PictureName] = Nil
   EndIf
EndFunction
Function scui.Picture.Draw(PictureName, Position)
   ; Verifica se l'icona esiste
   If helpers.FieldIsNil(scui.Pictures, PictureName)
      DebugPrint("PICTURE NAME DOES NOT EXISTS:", PictureName)
   Else
      DisplayBrush(scui.Pictures[PictureName].BrushId, Position.x, Position.y)
   EndIf
EndFunction
Function scui.Picture.GetBrushID(PictureName)
   ; Verifica se l'icona esiste
   If helpers.FieldIsNil(scui.Pictures, PictureName)
      DebugPrint("PICTURE NAME DOES NOT EXISTS:", PictureName)
   Else
      Return(scui.Pictures[PictureName].BrushId)
   EndIf
EndFunction
Function scui.RemovePicture(GadgetName, State)
   ; Sgancia le icone dal gadget
   Local gid = scui.GetIFOId(GadgetName)
   If gid < 0 Then scui.Debug({ "scui.RemovePicture: Unknown GadgetName -->" .. GadgetName })
   
   Switch scui.IFO[gid].oClass
      Case  #IFOCLASS_BUTTON
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Bevel.Picture = Nil
            Case #IFOSTATUS_HILIGHTED
               scui.IFO[gid].oData.HBevel.Picture = Nil
            Case #IFOSTATUS_PUSHED
               scui.IFO[gid].oData.PBevel.Picture = Nil
            Case #IFOSTATUS_DISABLED
               scui.IFO[gid].oData.DBevel.Picture = Nil
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Bevel.Picture = Nil
               scui.IFO[gid].oData.HBevel.Picture = Nil
               scui.IFO[gid].oData.PBevel.Picture = Nil
               scui.IFO[gid].oData.DBevel.Picture = Nil
         EndSwitch
         
      Case #IFOCLASS_SWITCH
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Bevel.Picture = Nil
            Case #IFOSTATUS_HILIGHTED
               scui.IFO[gid].oData.HBevel.Picture = Nil
            Case #IFOSTATUS_PUSHED
               scui.IFO[gid].oData.PBevel.Picture = Nil
            Case #IFOSTATUS_DISABLED
               scui.IFO[gid].oData.DNBevel.Picture = Nil
               scui.IFO[gid].oData.DPBevel.Picture = Nil
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Bevel.Picture = Nil
               scui.IFO[gid].oData.HBevel.Picture = Nil
               scui.IFO[gid].oData.PBevel.Picture = Nil
               scui.IFO[gid].oData.DNBevel.Picture = Nil
               scui.IFO[gid].oData.DPBevel.Picture = Nil
         EndSwitch

      Case #IFOCLASS_LABEL
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Bevel.Picture = Nil
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Bevel.Picture = Nil
         EndSwitch

   EndSwitch
   
   scui.RenderObject(gid)

EndFunction
Function scui.AttachPicture(GadgetName, State, PictureName, Mode)
   ; Aggancia l'icona <IconName> al gadget <GadgetName>, in particolare l'icona
   ; viene associata allo stato <State> del gadget che puo' essere:
   ; BUTTON: #IFOSTATUS_NORMAL, #IFOSTATUS_PUSHED, #IFOSTATUS_HILIGHTED, #IFOSTATUS_DISABLED, #IFOSTATUS_ALL
   ; SWITCH: #IFOSTATUS_NORMAL, #IFOSTATUS_PUSHED, #IFOSTATUS_HILIGHTED, #IFOSTATUS_DISABLED, #IFOSTATUS_ALL
   ; LABEL : #IFOSTATUS_NORMAL, #IFOSTATUS_ALL
   ; MODE: 1 = PATTERN, 2 = IMAGE, 3 = SKIN
   
   Local gid = scui.GetIFOId(GadgetName)
   If gid < 0 Then scui.Debug({ "scui.AttachPicture: Unknown GadgetName -->" .. GadgetName })
     
   Switch scui.IFO[gid].oClass
      Case  #IFOCLASS_BUTTON
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Bevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_HILIGHTED
               scui.IFO[gid].oData.HBevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_PUSHED
               scui.IFO[gid].oData.PBevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_DISABLED
               scui.IFO[gid].oData.DBevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Bevel.Picture = { Name  = PictureName, Mode = Mode }
               scui.IFO[gid].oData.HBevel.Picture = { Name  = PictureName, Mode = Mode }
               scui.IFO[gid].oData.PBevel.Picture = { Name  = PictureName, Mode = Mode }
               scui.IFO[gid].oData.DBevel.Picture = { Name  = PictureName, Mode = Mode }
         EndSwitch
         
      Case #IFOCLASS_SWITCH
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Bevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_HILIGHTED
               scui.IFO[gid].oData.HBevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_PUSHED
               scui.IFO[gid].oData.PBevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_DISABLED
               scui.IFO[gid].oData.DNBevel.Picture = { Name  = PictureName, Mode = Mode }
               scui.IFO[gid].oData.DPBevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Bevel.Picture = { Name  = PictureName, Mode = Mode }
               scui.IFO[gid].oData.HBevel.Picture = { Name  = PictureName, Mode = Mode }
               scui.IFO[gid].oData.PBevel.Picture = { Name  = PictureName, Mode = Mode }
               scui.IFO[gid].oData.DNBevel.Picture = { Name  = PictureName, Mode = Mode }
               scui.IFO[gid].oData.DPBevel.Picture = { Name  = PictureName, Mode = Mode }
         EndSwitch

      Case #IFOCLASS_LABEL
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Bevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Bevel.Picture = { Name  = PictureName, Mode = Mode }
         EndSwitch

         Case #IFOCLASS_BEVELBOX
         Switch State
            Case #IFOSTATUS_NORMAL
               scui.IFO[gid].oData.Bevel.Picture = { Name  = PictureName, Mode = Mode }
            Case #IFOSTATUS_ALL
               scui.IFO[gid].oData.Bevel.Picture = { Name  = PictureName, Mode = Mode }
         EndSwitch

   EndSwitch
   
   scui.RenderObject(gid)
   
EndFunction
Function scui.Win.Grab(WinID)
   Local w = scui.Win.FindByName(WinID)
   Local hw, hh = scui.Win.GetSize(WinID)
   Local bid = CreateBrush(Nil, hw, hh)
   SelectBrush(bid)
      DisplayBGPicPart(GetAttribute(#DISPLAY, w.HWId, #ATTRBGPIC), 0, 0, hw - 1, hh - 1, 0, 0, { Layers = True })
   EndSelect
   
   Return(bid)
EndFunction


/*** LIBRARY INITIALIZATION **************************************************/

InstallEventHandler({ OnMouseUp = scui.ResetActionStatus }) ; <--- SU TUTTE LE FINESTRE?


; DEVO INOLTRE CREARE UN LAYOUT PER IL BACKGROUND DELLA FINESTRA, OSSIA DEL
; ROOT GADGET
;

; *********************************************************************************
; * 06.01.2009 - CYCLE: Fixed bug in tag 'options'                                *
; *-------------------------------------------------------------------------------*
; *** V0.7 ************************************************************************
; * 27.01.2009 - NEWFUNC: scui.Initialize()                                       *
; *              NEWFUNC: scui.AppID()                                            *
; *              NEWFUNC: scui.ParseRexx()                                        *
; * 28.01.2009 - NEWFUNC: scui.EnableRWin()                                       *
; *              NEWFUNC: scui.SetRexxFunction()                                  *
; * 29.01.2009 - NEWFUNC: scui.RWin_New()                                         *
; *              NEWFUNC: scui.RWin_Find()                                        *
; * 30.01.2009 - NEWFUNC: scui.RWin_FindByID()                                    *
; *              NEWFUNC: scui.RWin_Close()                                       *
; * 01.02.2009 - NEWFUNC: scui.RWin_Open(WinName)                                 *
; *              NEWFUNC: scui.RWin_Free(WinName)                                 *
; *              NEWFUNC: scui.RWin_Move(WinName, Position)                       *
; *              NEWFUNC: scui.RWin_Resize(WinName)                               *
; *              NEWFUNC: scui.RWin_SetActive(WinName)                            *
; *              NEWFUNC: scui.RWin_UnsetActive()                                 *
; *              NEWFUNC: scui.RWin_Hide(WinName)                                 *
; *              NEWFUNC: scui.RWin_Show(WinName)                                 *
; * 17.02.2009 - NEWTAG: #IFOCLASS_LABEL --> oString.GroupFrame = True|False      *
; *              DEFSTRD: Added Label GroupFrames defaults                        *
; *                       - scui.theme.Label_GF_WMargins                          *
; *                       - scui.theme.Label_GF_HMargins                          *
; *                       - scui.theme.Label_GF_WOffset                           *
; *                       - scui.theme.Label_GFBevel                              *
; * 19.02.2009 - FIXED: Bug in scui.Initialize()                                  *
; * 21.02.2009 - NEWFUNC: scui.GetScreenSize()                                    *
; *              NEWFEAT: Images in image gadgets can be centered with the tag    *
; *                       <CenterImage>                                           *
; *              NEWFEAT: Image class: flicker free rendering/refresh             *
; *              NEWFUNC: scui.PauseEventHandling()                               *
; *                       scui.ResumeEventHandling()                              *
; * 22.04.2009 - NEWFEAT: Added OnIn and OnOut events in Image Class              *
; 
; * LANGUAGE
; * 10.03.2009 - NEWCLASS: #IFOCLASS_SCROLLER                                     *
; * 05.04.2009 - FIXED: Bug in Image objects rendering                            *
; * 14.07.2009 - FIXED: Image gadgets can be created without a source picture too *
; * 28.07.2009 - NEWFEAT: #IFOCLASS_IMAGE accepts <Image> tag with Scui.Set()     *
; * 28.07.2009 - NEWFEAT: #IFOCLASS_IMAGE accepts <HContainer> tag with Scui.Set()*
; * 05.08.2009 - NEWFUNC: helpers.FormatSize(size, target, template, decimals,    *
; *                                                                     thousands)*
; * 27.09.2009 - FIXED: 2 bugs in function scui.Win.HandleResizeEvent()           *
; * 01.10.2009 - NEWFUNC: scui.OnWindowResize(func)                               *
; * 17.12.2009 - STARTED NEW WINDOWS MANAGEMENT                                   *
; * 27.12.2009 - Adesso sull'evento OnExit lo StringBox restituisce anche il suo
; *              contenuto all'interno del campo <value>
; * 27.12.2009 - NUOVO SET DI COMANDI PER GESTIRE LE FINESTRE                     *
; *              scui.Win.New()
; *              scui.Win.FindByName()
; *              scui.Win.FindByHandler()
; *              scui.Win.Select()
; *              scui.Win.AttachGadgets()
; *              scui.Win.Resize()
; *              scui.Win.Move()
; *              scui.Win.Activate()
; *              scui.Win.Hide()
; *              scui.Win.Show()
; *              scui.Win.Close()
; *              scui.Win.Free()
; *              scui.Win.RemoveHandlers()
; *              scui.Win.ActivateHandlers()
; *              scui.Win.MinSize()
; *              scui.Win.MaxSize()
; *              scui.Win.Exists()
; *              scui.Win.Status_New()
; *              scui.Win.Status_Update()
; *              scui.Win.Status_Remove()
; *              scui.Win.Gauge_New()
; *              scui.Win.Gauge_Update()
; *              scui.Win.Gauge_Remove()
; *              
; * 13.01.2010 - Great speedup in gadget seeking, using a quick_look table now
; * 13.01.2010 - Now the translator routines work in a multi window environment
; *              translation on the fly works greatly now
; * 29.01.2010 - Fixed a bug when opening display out of the screen, automatically
; *              the window we are opening is restored inside the screen area
; * 29.01.2010 - Started the Icon System:
; *                 scui.Icon.Add()
; *                 scui.Icon.Remove()
; *                 scui.Icon.TClone()
; *                 scui.Icon.Draw()
; * 29.01.2010 - Started support for icon inside gadgets:
; *                 scui.AttachIcon()
; * 29.01.2010 - Now scui.DrawText support the Icon drawing
; * 29.01.2010 - Removed the functions related with the FWindow system and RWindow
; *              system.
; * 17.02.2010 - Now Cycle gadgets works with PopUp windows
; * --- UNTRACKED CHANGES ---
; * 24.04.2010 - Listview: fixed a bug in column sorting when there was hidden columns
; * 30.04.2010 - Listview: section HandleObject, removed direct row rendering
; *                        to avoid a double refresh (see comments in the code)
; * 19.05.2010 - Fixed a bug in scui.ActivateHandlers()
; * 13.08.2010 - Added scui.Win.Grab()
; * 26.08.2010 - Box skinning (9 Sectors Method) fixed
; * 08.09.2010 - Fixed a bug in <scui.Win.HandleResizeEvent()> that was raised
; *              in situation of fast window resizing and low rendering speed



; --- APPUNTI
; PER I LISTVIEW SAREBBE BELLO AGGIUNGERE LA POSSIBILITA' DI GENERARE UN EVENTO
; SULLA RICHIESTA DI ORDINAMENTO E POTER UTILIZZARE UNA CUSTOM ROUTINE
; AL POSTO DI QUELLA DI DEFAULT